using Alteridem.WinTouch;
using Common;
using GenerarClasses;
using SharpCompress.Common;
//using SharpCompress.Reader;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Ipc;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using WilsonProgramming;
using WindowsFormUtilities;

namespace ZipPla
{
    public partial class CatalogForm : Form, IMultipleLanguages
    {
        private const bool IgnoreFileError = true;

        private bool AllowFullpower = true;

        ZipPlaAddressBar zabLocation;

        const string ZipPlaCoverImageFileWithoutExtension = "{ZipPlaCoverFile}";
        const string ZipPlaCoverImageFileExtension = ".jpg";
        const string ZipPlaCoverImageFileWithoutExtensionInLower = "{zipplacoverfile}";
        const string ZipPlaCoverImageFileWithExtension = ZipPlaCoverImageFileWithoutExtension + ZipPlaCoverImageFileExtension;
        const string ZipPlaCoverImageFileWithExtensionInLower = ZipPlaCoverImageFileWithoutExtensionInLower + ZipPlaCoverImageFileExtension;

        private bool HideZipPlaCoverImageFile = true;

        //private static readonly Regex zipPlaCoverImageFileRegex = new Regex(@"(?:^|\/|\\)\{ZipPlaCoverFile\}\.(?:jpe?g|png|bmp|gif)$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        //private static readonly Regex zipPlaCoverImageTypeRegex = new Regex(@".(?:jpe?g|png|bmp|gif)$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        //bool isZipPlaCoverImageFile(string path) { return path != null && zipPlaCoverImageFileRegex.IsMatch(path); }
        //bool isZipPlaCoverImageType(string path) { return path != null && zipPlaCoverImageTypeRegex.IsMatch(path); }
        bool isZipPlaCoverImageFile(string path)
        {
            if (path == null || path.Length < ZipPlaCoverImageFileWithExtensionInLower.Length) return false;
            if (path == ZipPlaCoverImageFileWithExtensionInLower) return true;
            var pos = path.Length - ZipPlaCoverImageFileWithExtensionInLower.Length - 1;
            if (pos < 0) return false;
            var c = path[pos];
            return (c == '\\' || c == '/') && path.Substring(pos).ToLower() == ZipPlaCoverImageFileWithExtensionInLower;
        }
        bool isZipPlaCoverImageType(string path)
        {
            return path != null && path.EndsWith(ZipPlaCoverImageFileExtension, StringComparison.OrdinalIgnoreCase);
        }

        private DataGridViewSorter dgvSorter;
        private MouseGesture mgCatalog, mgFileList;

        private Dictionary<string, string> aliasesToFilteringStrings;
        private bool invariantFilteringList;

        private string thumbnailCache = GPSizeThumbnail.AlternateDataStream;

        private bool allowRenameByCmsRightClick = true;

        private DragAndDropAction dragAndDropAction;

        private const bool startApplicationWithAccessKey = true;

        private bool AllowRightDragFromThumbnail = true;
        private bool AllowRightDragFromDetail = true;

        ItemLoadLevel archiveLoadLevel = ItemLoadLevel.Full;
        ItemLoadLevel ArchiveLoadLevel { get { return archiveLoadLevel; } set { SetItemLoadLevel(ref archiveLoadLevel, archivesFilesPDFFielsToolStripMenuItem, value, checkAllLoadLevel: false); } }
        ItemLoadLevel imageLoadLevel = ItemLoadLevel.Full;
        ItemLoadLevel ImageLoadLevel { get { return imageLoadLevel; } set { SetItemLoadLevel(ref imageLoadLevel, imageFilesToolStripMenuItem, value, checkAllLoadLevel: false); } }
        ItemLoadLevel videoLoadLevel = ItemLoadLevel.Full;
        ItemLoadLevel VideoLoadLevel { get { return videoLoadLevel; } set { SetItemLoadLevel(ref videoLoadLevel, videoFilesToolStripMenuItem, value, checkAllLoadLevel: false); } }
        ItemLoadLevel otherLoadLevel = ItemLoadLevel.Full;
        ItemLoadLevel OtherLoadLevel { get { return otherLoadLevel; } set { SetItemLoadLevel(ref otherLoadLevel, otherFilesToolStripMenuItem, value, checkAllLoadLevel: false); } }
        bool SetItemLoadLevel(ref ItemLoadLevel itemLoadLevel, ToolStripMenuItem toolStripMenuItem, ItemLoadLevel value, bool checkAllLoadLevel)
        {
            if (itemLoadLevel != value)
            {
                if (checkAllLoadLevel && value == ItemLoadLevel.Ignore)
                {
                    var temp = itemLoadLevel;
                    itemLoadLevel = value;
                    if (archiveLoadLevel == ItemLoadLevel.Ignore && imageLoadLevel == ItemLoadLevel.Ignore && videoLoadLevel == ItemLoadLevel.Ignore && otherLoadLevel == ItemLoadLevel.Ignore && !IsDisplay(SubfolderMode))
                    {
                        // ignore 以外でトグルする実装
                        itemLoadLevel = temp == ItemLoadLevel.Header ? ItemLoadLevel.Full : ItemLoadLevel.Header;

                        /*
                        AllowFullpower = false;
                        MessageBox.Show(this, Message.AtLeastOneKindOfItemsMustBeSelected, Message.Information, MessageBoxButtons.OK, MessageBoxIcon.Information);
                        AllowFullpower = true;
                        */

                        // 変更しない実装
                        /*
                        itemLoadLevel = temp;
                        AllowFullpower = false;
                        MessageBox.Show(this, Message.AtLeastOneKindOfItemsMustBeSelected, Message.Information, MessageBoxButtons.OK, MessageBoxIcon.Information);
                        AllowFullpower = true;
                        return false;
                        */
                    }
                }
                else
                {
                    itemLoadLevel = value;
                }
                toolStripMenuItem.CheckState = itemLoadLevel == ItemLoadLevel.Ignore ? CheckState.Unchecked : itemLoadLevel == ItemLoadLevel.Full ? CheckState.Checked : CheckState.Indeterminate;
                return true;
            }
            return false;
        }

        /*
        bool checkDirectorySize = false;
        bool CheckDirectorySize
        {
            get { return checkDirectorySize; }
            set
            {
                if (value != checkDirectorySize)
                {
                    getFolderSizeToolStripMenuItem.Checked = checkDirectorySize = value;
                }
            }
        }
        */

        SortSyncMode sortSyncMode = SortSyncMode.Directory;
        public SortSyncMode SortSyncMode
        {
            get { return sortSyncMode; }
            private set
            {
                if (value != sortSyncMode)
                {
                    sortSyncMode = value;
                    sortFilesWithTheSameOrderAsThumbnailWindowToolStripMenuItem.Checked = value != SortSyncMode.None;
                }
            }
        }

        bool synchroFromTreeToBar = true;
        bool synchroFromBarToTree = false;
        bool SynchroFromTreeToBar
        {
            get { return synchroFromTreeToBar; }
            set { setSynchroBetweenTreeAndBar(value, synchroFromBarToTree); }
        }
        bool SynchroFromBarToTree
        {
            get { return synchroFromBarToTree; }
            set { setSynchroBetweenTreeAndBar(synchroFromTreeToBar, value); }
        }

        bool collapseOthersWhenSynchronizing = false;
        bool CollapseOthersWhenSynchronizing
        {
            get { return collapseOthersWhenSynchronizing; }
            set
            {
                if (value != collapseOthersWhenSynchronizing)
                {
                    collapseOthersWhenSynchronizing = value;
                    collapseOthersWhenSynchronizingToolStripMenuItem.Checked = value;
                }
            }
        }

        void setSynchroBetweenTreeAndBar(bool treeToBar, bool barToTree)
        {
            if (treeToBar != synchroFromTreeToBar || barToTree != synchroFromBarToTree)
            {
                synchroFromTreeToBar = treeToBar;
                synchroFromBarToTree = barToTree;
                noneFolderTreeSynchronizingToolStripMenuItem.Checked = !(treeToBar || barToTree);
                folderTreeToAddressbarToolStripMenuItem.Checked = treeToBar && !barToTree;
                addressBarToFolderTreeToolStripMenuItem.Checked = !treeToBar && barToTree;
                twowayToolStripMenuItem.Checked = treeToBar && barToTree;
            }
        }

        ItemSelectionFeedback itemSelectionFeedback = ItemSelectionFeedback.IfSortMayBeSame;
        ItemSelectionFeedback ItemSelectionFeedback
        {
            get { return itemSelectionFeedback; }
            set
            {
                if (value != itemSelectionFeedback)
                {
                    itemSelectionFeedback = value;
                    noneItemSelectionFeedbackToolStripMenuItem.Checked = value == ItemSelectionFeedback.None;
                    inAppropriateCasesToolStripMenuItem.Checked = value == ItemSelectionFeedback.IfSortMayBeSame;
                    alwaysItemSelectionFeedbackToolStripMenuItem.Checked = value == ItemSelectionFeedback.Always;
                }
            }
        }

        private bool alwaysHideUI = false;
        private bool AlwaysHideUI
        {
            get { return alwaysHideUI; }
            set
            {
                SetAlwaysHideUI(value, silent: false);
            }
        }

        private void SetAlwaysHideUI(bool value, bool silent)
        {
            if (alwaysHideUI != value)
            {
                alwaysHideUI = value;
                alwaysAutomaticallyHideUIToolStripMenuItem.Checked = value;


                /*
                if (!silent)
                {
                    StopLookAheadProcess();
                    PrepareLookAheadProcess();
                }
                */
            }
        }

        CatalogFormConetxtMenu rightClickContextMenu = CatalogFormConetxtMenu.ZipPla;
        CatalogFormConetxtMenu middleClickContextMenu = CatalogFormConetxtMenu.Tag;
        CatalogFormConetxtMenu controlRightClickContextMenu = CatalogFormConetxtMenu.Explorer;
        CatalogFormConetxtMenu RightClickContextMenu
        {
            get { return rightClickContextMenu; }
            set
            {
                if (value != rightClickContextMenu)
                {
                    if (middleClickContextMenu == value) middleClickContextMenu = rightClickContextMenu;
                    else controlRightClickContextMenu = rightClickContextMenu;
                    rightClickContextMenu = value;

                    setContextMenuCheckMark();
                }
            }
        }
        CatalogFormConetxtMenu MiddleClickContextMenu
        {
            get { return middleClickContextMenu; }
            set
            {
                if (value != middleClickContextMenu)
                {
                    if (rightClickContextMenu == value) rightClickContextMenu = middleClickContextMenu;
                    else controlRightClickContextMenu = middleClickContextMenu;
                    middleClickContextMenu = value;

                    setContextMenuCheckMark();
                }
            }
        }
        CatalogFormConetxtMenu ControlRightClickContextMenu
        {
            get { return controlRightClickContextMenu; }
            set
            {
                if (value != controlRightClickContextMenu)
                {
                    if (rightClickContextMenu == value) rightClickContextMenu = controlRightClickContextMenu;
                    else middleClickContextMenu = controlRightClickContextMenu;
                    controlRightClickContextMenu = value;

                    setContextMenuCheckMark();
                }
            }
        }

        void setContextMenuCheckMark()
        {
            standardRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.ZipPla == rightClickContextMenu;
            standardMiddleclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.ZipPla == middleClickContextMenu;
            standardCtrlRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.ZipPla == controlRightClickContextMenu;

            OnlyTagRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Tag == rightClickContextMenu;
            OnlyTagMiddleclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Tag == middleClickContextMenu;
            onlyTagCtrlRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Tag == controlRightClickContextMenu;

            explorerRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Explorer == rightClickContextMenu;
            explorerMiddleclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Explorer == middleClickContextMenu;
            explorerCtrlRightclickToolStripMenuItem.Checked = CatalogFormConetxtMenu.Explorer == controlRightClickContextMenu;
        }

        private bool allowReadAheadProcess = true;
        private bool AllowReadAheadProcess
        {
            get { return allowReadAheadProcess; }
            set { SetAllowReadAheadProcess(value, silent: false); }
        }
        private void SetAllowReadAheadProcess(bool value, bool silent)
        {
            if (value != allowReadAheadProcess)
            {
                allowReadaheadProcessToolStripMenuItem.Checked = value;
                allowReadAheadProcess = value;
                if (!silent)
                {
                    if (value)
                    {
                        PrepareLookAheadProcess();
                    }
                    else
                    {
                        StopLookAheadProcess();
                    }
                }
            }
        }

        private bool loadLastViewedPageFromHistory = false;
        public bool LoadLastViewedPageFromHistory
        {
            get { return loadLastViewedPageFromHistory; }
            private set
            {
                if (value != loadLastViewedPageFromHistory)
                {
                    loadLastViewedPageFromHistory = value;
                    loadLastViewedPageFromHistoryToolStripMenuItem.Checked = value;
                }
            }
        }

        FolderSortMode folderSortMode = FolderSortMode.None;
        FolderSortMode FolderSortMode
        {
            get { return folderSortMode; }
            set { SetFolderSortMode(value, reSort: false); }
        }
        void SetFolderSortMode(FolderSortMode value, bool reSort)
        {
            if (value != folderSortMode)
            {
                reSort = reSort && ResolveFitToDirectionOfSort(value, sortMode) != ResolveFitToDirectionOfSort(folderSortMode, sortMode);
                folderSortMode = value;
                noneFolderArrangeToolStripMenuItem.Checked = value == FolderSortMode.None;
                displayFirstToolStripMenuItem.Checked = value == FolderSortMode.Ahead;
                displayLastToolStripMenuItem.Checked = value == FolderSortMode.Behind;
                fitToDirectionOfSortToolStripMenuItem.Checked = value == FolderSortMode.FitToDirectionOfSort;
                if (reSort)
                {
                    cbSortBy_SelectedValueChanged(null, null);
                }
            }
        }
        FolderSortMode ResolveFitToDirectionOfSort(FolderSortMode folderSortMode, SortMode sortMode)
        {
            if (folderSortMode == FolderSortMode.FitToDirectionOfSort)
            {
                switch (sortMode)
                {
                    case SortMode.AccessedInAsc:
                    case SortMode.CreatedInAsc:
                    case SortMode.ModifiedInAsc:
                    case SortMode.NameInAsc:
                    case SortMode.RatingInAsc:
                    case SortMode.SizeInAsc:
                    case SortMode.TypeInAsc:
                    case SortMode.VFPSInAsc:
                    case SortMode.VHeightInAsc:
                    case SortMode.VLengthInAsc:
                    case SortMode.VPageInAsc:
                    case SortMode.VRatioInAsc:
                    case SortMode.VResolutionInAsc:
                    case SortMode.VWidthInAsc:
                    case SortMode.Random:
                        return FolderSortMode.Ahead;
                    default: return FolderSortMode.Behind;
                }
            }
            else return folderSortMode;
        }

        NumberOfLinesOfName numberOfLinesOfName = NumberOfLinesOfName.Full;
        NumberOfLinesOfName NumberOfLinesOfName
        {
            get { return numberOfLinesOfName; }
            set
            {
                SetNumberOfLinesOfName(value, refresh: false);
            }
        }

        private void SetNumberOfLinesOfName(NumberOfLinesOfName value, bool refresh)
        {
            if (value == NumberOfLinesOfName.Full)
            {
                if (numberOfLinesOfName != value)
                {
                    numberOfLinesOfName = value;
                    fromTheLongestNameToolStripMenuItem.Checked = value == NumberOfLinesOfName.Full;
                    automaticlessToolStripMenuItem.Checked = value == NumberOfLinesOfName.Automatic1;
                    automaticgreaterToolStripMenuItem.Checked = value == NumberOfLinesOfName.Automatic2;
                    NumOfLineOfName1toolStripMenuItem.Checked = value == NumberOfLinesOfName.One;
                    NumOfLineOfName2toolStripMenuItem.Checked = value == NumberOfLinesOfName.Two;
                    NumOfLineOfName3toolStripMenuItem.Checked = value == NumberOfLinesOfName.Three;
                }

                if (refresh)
                {
                    tvCatalog.SetTextLinesFromText(getMaxLengthString(ZipNameArray), true);
                }
            }
            else
            {
                if (numberOfLinesOfName != value)
                {
                    numberOfLinesOfName = value;
                    fromTheLongestNameToolStripMenuItem.Checked = value == NumberOfLinesOfName.Full;
                    automaticlessToolStripMenuItem.Checked = value == NumberOfLinesOfName.Automatic1;
                    automaticgreaterToolStripMenuItem.Checked = value == NumberOfLinesOfName.Automatic2;
                    NumOfLineOfName1toolStripMenuItem.Checked = value == NumberOfLinesOfName.One;
                    NumOfLineOfName2toolStripMenuItem.Checked = value == NumberOfLinesOfName.Two;
                    NumOfLineOfName3toolStripMenuItem.Checked = value == NumberOfLinesOfName.Three;

                    int len, lin;
                    GetNameLengthAndNameLines(out len, out lin);
                    if (len > 0)
                    {
                        tvCatalog.SetTextLength(len, refresh);
                    }
                    else
                    {
                        tvCatalog.SetTextLines(lin, refresh);
                    }
                }
            }
        }

        private string getMaxLengthString(string[] array)
        {
            var maxLengthIndex = getMaxLengthIndex(array);
            if (maxLengthIndex >= 0) return array[maxLengthIndex];
            return null;
        }


        private int getMaxLengthIndex(string[] array)
        {
            if (array == null) return -1;
            float maxLength = -1;
            var maxLengthIndex = -1;
            using (var g = CreateGraphics())
            {
                for (var i = 0; i < array.Length; i++)
                {
                    var s = array[i];
                    if (s == null) continue;

                    var length = g.MeasureString(s, DefaultFont).Width; // TextRenderer.MeasureText より 10 倍程度高速

                    if (length > maxLength)
                    {
                        maxLength = length;
                        maxLengthIndex = i;
                    }
                }
            }

            return maxLengthIndex;
        }

        private void GetNameLengthAndNameLines(out int nameLength, out int nameLines)
        {
            switch (numberOfLinesOfName)
            {
                case NumberOfLinesOfName.Automatic1:
                    nameLength = 16;
                    nameLines = 0;
                    return;
                case NumberOfLinesOfName.Automatic2:
                    nameLength = 24;
                    nameLines = 0;
                    return;
                case NumberOfLinesOfName.One:
                    nameLength = 0;
                    nameLines = 1;
                    return;
                case NumberOfLinesOfName.Two:
                    nameLength = 0;
                    nameLines = 2;
                    return;
                case NumberOfLinesOfName.Three:
                    nameLength = 0;
                    nameLines = 3;
                    return;
                default: throw new Exception();
            }
        }

        private CoverBindingMode coverBindingMode = CoverBindingMode.Default;
        private CoverBindingMode CoverBindingMode
        {
            get
            {
                return coverBindingMode;
            }
            set
            {
                if (value != coverBindingMode)
                {
                    coverBindingMode = value;
                    forceFirstPageToBeSingleToolStripMenuItem.Checked = coverBindingMode == CoverBindingMode.ForceSingle;
                }
            }
        }

        private FilterRemovingMode filterRemovingMode;
        private FilterRemovingMode FilterRemovingMode
        {
            get { return filterRemovingMode; }
            set
            {
                if (value != filterRemovingMode)
                {
                    clearFilterWhenMovingLocationToolStripMenuItem.Checked = value == FilterRemovingMode.WhenMovingLocation;
                    filterRemovingMode = value;
                }
            }
        }

        // もはやこれでよい
        // ツリービューも追加
        private void explorerTreeView_TreeViewWnd_GotFocus(object sender, EventArgs e) { latestControledControl = explorerTreeView.TreeViewWnd; }
        private void dgvFileList_GotFocus(object sender, EventArgs e) { latestControledControl = dgvFileList; }
        private void dgvDirectoryList_GotFocus(object sender, EventArgs e) { latestControledControl = dgvDirectoryList; }
        private void tvCatalog_GotFocus(object sender, EventArgs e) { latestControledControl = tvCatalog; }
        private Control latestControledControl = null;
        private Control LatestControledControl
        {
            get
            {
                if (latestControledControl != null) return latestControledControl;
                if (thumbnailListToolStripMenuItem.Checked) return tvCatalog;
                return dgvFileList;
            }
            set
            {
                // 互換性用に残す
            }
        }
        // マウスホイールで直下を動かす動作を MouseEnter + Focus で実装していたとき
        /*
        private Control latestControledControl = null;
        private Control LatestControledControl
        {
            get
            {
                if (latestControledControl == null || !latestControledControl.Visible)
                {
                    if (latestControledControl == tvCatalog) return dgvFileList;
                    else return tvCatalog;
                }
                return latestControledControl;
            }
            set
            {
                latestControledControl = value;
            }
        }
        */

        public int packedImageLoaderLeftHierarchies = 0;
        public PackedImageLoaderSearchMode packedImageLoaderSearchMode = PackedImageLoaderSearchMode.Full;
        ArchivesInArchiveMode archivesInArchiveMode = ZipPla.ArchivesInArchiveMode.Ignore;
        private ArchivesInArchiveMode ArchivesInArchiveMode
        {
            get
            {
                return archivesInArchiveMode;
            }
            set
            {
                if (value != archivesInArchiveMode)
                {
                    archivesInArchiveMode = value;
                    switch (value)
                    {
                        case ArchivesInArchiveMode.Ignore:
                            packedImageLoaderLeftHierarchies = 0;
                            //packedImageLoaderAlwaysLoadLowerHierarchies = false;
                            packedImageLoaderSearchMode = PackedImageLoaderSearchMode.Full;
                            break;
                        case ArchivesInArchiveMode.IfNoOther1Level:
                            packedImageLoaderLeftHierarchies = 1;
                            //packedImageLoaderAlwaysLoadLowerHierarchies = false;
                            packedImageLoaderSearchMode = PackedImageLoaderSearchMode.UntilFoundLayer;
                            break;
                        case ArchivesInArchiveMode.UntilFound2Level:
                            packedImageLoaderLeftHierarchies = 2;
                            packedImageLoaderSearchMode = PackedImageLoaderSearchMode.UntilFoundItem;
                            break;
                        case ArchivesInArchiveMode.Always1Level:
                            packedImageLoaderLeftHierarchies = 1;
                            //packedImageLoaderAlwaysLoadLowerHierarchies = true;
                            packedImageLoaderSearchMode = PackedImageLoaderSearchMode.Full;
                            break;
                    }
                    ignoreArchivesInArchiveToolStripMenuItem.Checked = value == ArchivesInArchiveMode.Ignore;
                    onlyIfThereIsNoOtherImageToolStripMenuItem.Checked = value == ArchivesInArchiveMode.IfNoOther1Level;
                    untilFoundToolStripMenuItem.Checked = value == ArchivesInArchiveMode.UntilFound2Level;
                    alwaysLoadArchivesInArchiveToolStripMenuItem.Checked = value == ArchivesInArchiveMode.Always1Level;
                }
            }
        }

        private ReadOnMemoryMode readOnMemoryMode = ReadOnMemoryMode.None;
        private ReadOnMemoryMode ReadOnMemoryMode
        {
            get => readOnMemoryMode;
            set
            {
                if (value != readOnMemoryMode)
                {
                    readOnMemoryMode = value;
                    switch (value)
                    {
                        case ReadOnMemoryMode.None:
                            loadWholeArchiveIntoMemoryToolStripMenuItem.Checked = false;
                            exceptReadAheadProcessToolStripMenuItem.Enabled = false;
                            break;
                        case ReadOnMemoryMode.ExceptLookAhead:
                            loadWholeArchiveIntoMemoryToolStripMenuItem.Checked = true;
                            exceptReadAheadProcessToolStripMenuItem.Enabled = true;
                            exceptReadAheadProcessToolStripMenuItem.Checked = true;
                            break;
                        case ReadOnMemoryMode.Always:
                            loadWholeArchiveIntoMemoryToolStripMenuItem.Checked = true;
                            exceptReadAheadProcessToolStripMenuItem.Enabled = true;
                            exceptReadAheadProcessToolStripMenuItem.Checked = false;
                            break;
                    }
                }
            }
        }

        private bool openInPreviousImageFilterSetting = true;
        private bool OpenInPreviousImageFilterSetting
        {
            get
            {
                return openInPreviousImageFilterSetting;
            }
            set
            {
                if (value != openInPreviousImageFilterSetting)
                {
                    openInPreviousImageFilterSetting = value;
                    startInPreviousImageFilterSettingToolStripMenuItem.Checked = value;
                }
            }
        }


        private InitialFullscreenMode builtInViewerInitialFullscreenMode = InitialFullscreenMode.Default;
        private InitialFullscreenMode BuiltInViewerInitialFullscreenMode
        {
            get
            {
                return builtInViewerInitialFullscreenMode;
            }
            set
            {
                SetBuiltInViewerInitialFullscreenMode(value, silent: false);
            }
        }

        private void SetBuiltInViewerInitialFullscreenMode(InitialFullscreenMode value, bool silent)
        {
            if (builtInViewerInitialFullscreenMode != value)
            {
                builtInViewerInitialFullscreenMode = value;
                startInPreviousFullscreenModeToolStripMenuItem.Checked = value == InitialFullscreenMode.Default;
                alwaysStartInWindowModeToolStripMenuItem.Checked = value == InitialFullscreenMode.ForceWindow;
                openInFullscreenToolStripMenuItem.Checked = value == InitialFullscreenMode.ForceFullscreen;

                /*
                if (!silent)
                {
                    StopLookAheadProcess();
                    PrepareLookAheadProcess();
                }*/
            }
        }

        private SelectionHighlightMode selectionHilightMode = SelectionHighlightMode.WhenMouseLeaves;
        private SelectionHighlightMode SelectionHilightMode
        {
            get
            {
                return selectionHilightMode;
            }
            set
            {
                if (value != selectionHilightMode)
                {
                    selectionHilightMode = value;
                    hilightSelectedItemsWhenMouseLeavaesToolStripMenuItem.Checked = value == SelectionHighlightMode.WhenMouseLeaves;
                    if (value == SelectionHighlightMode.None) unselectedItemMaskOff();
                }
            }
        }

        private DoubleClickMode doubleClickFileOpenMode = DoubleClickMode.IgnoreMouseMove;
        private DoubleClickMode DoubleClickFileOpenMode
        {
            get
            {
                return doubleClickFileOpenMode;
            }
            set
            {
                if (value != doubleClickFileOpenMode)
                {
                    doubleClickFileOpenMode = value;
                    standardToolStripMenuItem.Checked = value == DoubleClickMode.Standard;
                    ignoreMouseMovementToolStripMenuItem.Checked = value == DoubleClickMode.IgnoreMouseMove;
                    selectAndClickItemToolStripMenuItem.Checked = value == DoubleClickMode.SelectAndClick;
                }
            }
        }

        private bool sendFilterStringToBuiltInViewer = true;
        private bool SendFilterStringToBuiltInViewer
        {
            get
            {
                return sendFilterStringToBuiltInViewer;
            }
        }

        private bool tinyOnScreenKeyboardVisible = false;
        private bool TinyOnScreenKeyboardVisible
        {
            get
            {
                return tinyOnScreenKeyboardVisible;
            }
            set
            {
                if (tinyOnScreenKeyboardVisible != value)
                {
                    setTinyOnScreenKeyboardVisible(value);
                }
            }
        }

        private void setTinyOnScreenKeyboardVisible(bool visible)
        {
            tinyOnScreenKeyboardVisible = visible;
            tinyOnscreenKeyboardToolStripMenuItem.Checked = visible;
            simplifiedKeyBoard.SetVisible(visible);
        }

        int undoBufferIndex = -1;
        readonly List<UndoBufferClass> undoBuffer = new List<UndoBufferClass>();
        class UndoBufferClass
        {
            public string Location = null;
            public double ThumbnailPosition = -1;
            public int FileListPosition = -1;
            public string SelectedFileName = null;
            public Color ProfileColor;
            public CatalogProfile Profile;
        }

        int maxCaptchaCountInAVideo = 0;
        int MaxCaptchaCountInAVideo
        {
            get { return maxCaptchaCountInAVideo; }
            set
            {
                if (value != maxCaptchaCountInAVideo)
                {
                    maxCaptchaCountInAVideo = value;
                    fitOnTheScreenToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 0;
                    thumb6ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 6;
                    thumb12ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 12;
                    thumb24ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 24;
                    thumb60ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 60;
                    thumb120ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 120;
                    thumb240ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 240;
                    thumb600ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 600;
                    thumb1200ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 1200;
                    thumb2400ToolStripMenuItem.Checked = maxCaptchaCountInAVideo == 2400;
                    everySecondsToolStripMenuItem.Checked = maxCaptchaCountInAVideo == int.MaxValue;
                }
            }
        }

        private Color currentProfileColor_BackColor;
        private Color currentProfileColor_ForeColor;
        private Brush currentProfileColor_BackBrush = null;
        private Brush currentProfileColor_ForeBrush = null;
        private Color currentProfileColor
        {
            get
            {
                return currentProfileColor_BackColor;
            }

            set
            {
                currentProfileColor_BackColor = value;
                currentProfileColor_ForeColor = ZipTag.GetForeColor(currentProfileColor_BackColor);
                if (currentProfileColor_BackBrush != null) currentProfileColor_BackBrush.Dispose();
                if (currentProfileColor_ForeBrush != null) currentProfileColor_ForeBrush.Dispose();
                currentProfileColor_BackBrush = new SolidBrush(currentProfileColor_BackColor);
                currentProfileColor_ForeBrush = new SolidBrush(currentProfileColor_ForeColor);

                //setMenuItemColor();
                menuStrip.BackColor = currentProfileColor_BackColor;
                menuStripForTagFilter.BackColor = currentProfileColor_BackColor;
                //menuStripLeft.BackColor = currentProfileColor_BackColor;
            }
        }

        private double currentMinimumFrameThickness
        {
            get
            {
                if (zeroToolStripMenuItem.Checked) return 0;
                if (veryThinToolStripMenuItem.Checked) return 1;
                if (thinToolStripMenuItem.Checked) return 2;
                if (thickToolStripMenuItem.Checked) return 8;
                if (veryThickToolStripMenuItem.Checked) return 16;
                return 4;
            }
            set
            {
                ToolStripMenuItem tsmi;
                double selectedValue;
                if (value < 0.5)
                {
                    tsmi = zeroToolStripMenuItem;
                    selectedValue = 0;
                }
                else if (value < 1.5)
                {
                    tsmi = veryThinToolStripMenuItem;
                    selectedValue = 1;
                }
                else if (value < 3)
                {
                    tsmi = thinToolStripMenuItem;
                    selectedValue = 2;
                }
                else if (value < 6)
                {
                    tsmi = normalThicknessToolStripMenuItem;
                    selectedValue = 4;
                }
                else if (value < 12)
                {
                    tsmi = thickToolStripMenuItem;
                    selectedValue = 8;
                }
                else
                {
                    tsmi = veryThickToolStripMenuItem;
                    selectedValue = 16;
                }

                zeroToolStripMenuItem.Checked = zeroToolStripMenuItem == tsmi;
                veryThinToolStripMenuItem.Checked = veryThinToolStripMenuItem == tsmi;
                thinToolStripMenuItem.Checked = thinToolStripMenuItem == tsmi;
                normalThicknessToolStripMenuItem.Checked = normalThicknessToolStripMenuItem == tsmi;
                thickToolStripMenuItem.Checked = thickToolStripMenuItem == tsmi;
                veryThickToolStripMenuItem.Checked = veryThickToolStripMenuItem == tsmi;
                tvCatalog.ThumbnailPadding = Program.DpiScaling(ChangeThumbnailSize_Padding * selectedValue);
            }
        }

        // Color の == は同じ RGB でも名前が違うと別のものになってしまうため
        private static bool ColorEquals(Color a, Color b)
        {
            return a.R == b.R && a.G == b.G && a.B == b.B;
        }

        private Color backColorOfBuiltInViewer = Color.Black; // Name の変更
        private Color BackColorOfBuiltInViewer
        {
            get
            {
                return backColorOfBuiltInViewer;
            }
            set
            {
                if (!ColorEquals(value, backColorOfBuiltInViewer))
                {
                    if (ColorEquals(value, Color.Black))
                    {
                        backColorOfBuiltInViewer = Color.Black;
                        blackToolStripMenuItem.Checked = true;
                        grayToolStripMenuItem.Checked = false;
                        whiteToolStripMenuItem.Checked = false;
                        selectColorToolStripMenuItem.Checked = false;
                    }
                    else if (ColorEquals(value, Color.Gray))
                    {
                        backColorOfBuiltInViewer = Color.Gray;
                        blackToolStripMenuItem.Checked = false;
                        grayToolStripMenuItem.Checked = true;
                        whiteToolStripMenuItem.Checked = false;
                        selectColorToolStripMenuItem.Checked = false;
                    }
                    else if (ColorEquals(value, Color.White))
                    {
                        backColorOfBuiltInViewer = Color.White;
                        blackToolStripMenuItem.Checked = false;
                        grayToolStripMenuItem.Checked = false;
                        whiteToolStripMenuItem.Checked = true;
                        selectColorToolStripMenuItem.Checked = false;
                    }
                    else
                    {
                        backColorOfBuiltInViewer = value;
                        SelectedColorForBackColorOfBuiltInViewer = value;
                        blackToolStripMenuItem.Checked = false;
                        grayToolStripMenuItem.Checked = false;
                        whiteToolStripMenuItem.Checked = false;
                        selectColorToolStripMenuItem.Checked = true;
                    }
                }
            }
        }
        private Color selectedColorForBackColorOfBuiltInViewer = Color.LightSalmon;
        private Color SelectedColorForBackColorOfBuiltInViewer
        {
            get
            {
                return selectedColorForBackColorOfBuiltInViewer;
            }
            set
            {
                if (!ColorEquals(value, selectedColorForBackColorOfBuiltInViewer))
                {
                    selectedColorForBackColorOfBuiltInViewer = value;
                    selectColorToolStripMenuItem.BackColor = value;
                }
            }
        }


        private void setCurrentMinimumFrameThickness(ToolStripMenuItem tsmi)
        {
            zeroToolStripMenuItem.Checked = zeroToolStripMenuItem == tsmi;
            veryThinToolStripMenuItem.Checked = veryThinToolStripMenuItem == tsmi;
            thinToolStripMenuItem.Checked = thinToolStripMenuItem == tsmi;
            normalThicknessToolStripMenuItem.Checked = normalThicknessToolStripMenuItem == tsmi;
            thickToolStripMenuItem.Checked = thickToolStripMenuItem == tsmi;
            veryThickToolStripMenuItem.Checked = veryThickToolStripMenuItem == tsmi;

            tvCatalog.ThumbnailPadding = Program.DpiScaling(ChangeThumbnailSize_Padding * currentMinimumFrameThickness);
        }


        private ThumbViewerAligningMode currentAligning
        {
            get
            {
                return tvCatalog.LayoutMode;
                /*
                if (totallyUniformedToolStripMenuItem.Checked) return ThumbViewerAligningMode.TotallyUniformedGrid;
                if (horizontallyUniformedToolStripMenuItem.Checked) return ThumbViewerAligningMode.HorizontallyUniformedGrid;
                if (alignedLeftToolStripMenuItem.Checked) return ThumbViewerAligningMode.LeftAlignedGrid;
                return ThumbViewerAligningMode.CenteredGrid;
                */
            }
            set
            {
                totallyUniformedToolStripMenuItem.Checked = value == ThumbViewerAligningMode.TotallyUniformedGrid;
                horizontallyUniformedToolStripMenuItem.Checked = value == ThumbViewerAligningMode.HorizontallyUniformedGrid;
                alignedLeftToolStripMenuItem.Checked = value == ThumbViewerAligningMode.LeftAlignedGrid;
                alignedOnCenterToolStripMenuItem.Checked = value == ThumbViewerAligningMode.CenteredGrid;
                tvCatalog.LayoutMode = value;
            }
        }

        private readonly Dictionary<object, HashSet<string>> OpendByExternalApplication_Dictionary = new Dictionary<object, HashSet<string>>();
        private bool IsOpendByExternalApplication(string fullPath)
        {
            if (fullPath == null) return false;
            fullPath = fullPath.ToLower();
            return OpendByExternalApplication_Dictionary.Any(pair => pair.Value.Contains(fullPath));
        }

        public async void SetOpendByExternalApplication(Process p, IEnumerable<string> fullPathSet, bool selectionMirror)
        {
            if (p == null || p.HasExited || fullPathSet == null)
            {
                p?.Dispose();
                return;
            }
            var set = new HashSet<string>(from path in fullPathSet where !string.IsNullOrEmpty(path) select path.ToLower());
            if (!set.Any())
            {
                p.Dispose();
                return;
            }
            OpendByExternalApplication_Dictionary[p] = set;

            if (selectionMirror) selectionMirror = set.Count == 1;
            string fullPath = null;
            string name = null;
            string parent = null;
            if (selectionMirror)
            {
                fullPath = fullPathSet.First(path => !string.IsNullOrEmpty(path));
                if (!fullPath.Contains(Path.AltDirectorySeparatorChar))
                {
                    var i = fullPath.LastIndexOf(Path.DirectorySeparatorChar);
                    if (0 < i && i < fullPath.Length - 1)
                    {
                        parent = fullPath.Substring(0, i + 1);
                        name = fullPath.Substring(i + 1);
                    }
                    else selectionMirror = false;
                }
                else selectionMirror = false;
            }
            if (selectionMirror)
            {
                string prevTitle = null;
                string prevSelect = null;
                string prePath = null, postPath = null, preName = null, postName = null;
                while (!await Task.Run(() => p.WaitForExit(100)))
                {
                    string title = null;
                    bool active = false;
                    try
                    {
                        var p2 = Process.GetProcessById(p.Id);
                        if (p2 != null)
                        {
                            using (p2)
                            {
                                active = p2.MainWindowHandle == GetForegroundWindow();
                                title = p2.MainWindowTitle;
                            }
                        }
                    }
                    catch
                    {
                    }
                    var changed = title != null && title != prevTitle;
                    prevTitle = title;
                    if (changed)
                    {
                        string current = null;
                        var doneSomething = false;
                        if (prePath == null)
                        {
                            var pos = title.IndexOf(fullPath);
                            if (pos >= 0)
                            {
                                prePath = title.Substring(0, pos);
                                postPath = title.Substring(pos + fullPath.Length);
                                doneSomething = true;
                            }
                        }
                        else if (title.Length > prePath.Length + postPath.Length && title.StartsWith(prePath) && title.EndsWith(postPath))
                        {
                            current = title.Substring(prePath.Length, title.Length - prePath.Length - postPath.Length);
                            doneSomething = true;
                        }

                        if (!doneSomething)
                        {
                            if (preName == null)
                            {
                                var pos = title.IndexOf(name);
                                if (pos >= 0)
                                {
                                    preName = title.Substring(0, pos);
                                    postName = title.Substring(pos + name.Length);
                                }
                            }
                            else if (title.Length > preName.Length + postName.Length && title.StartsWith(preName) && title.EndsWith(postName))
                            {
                                current = parent + title.Substring(preName.Length, title.Length - preName.Length - postName.Length);
                            }
                        }

                        var selectChange = active && current != null && current != prevSelect;
                        prevSelect = current;
                        if (selectChange && (ItemSelectionFeedback == ItemSelectionFeedback.Always ||
                            ItemSelectionFeedback == ItemSelectionFeedback.IfSortMayBeSame && sortMode == SortMode.NameInAsc && IsNonvolatileSort()))
                        {
                            var zpa = ZipPathArray;
                            var s2d = tvCatalog.ShowIndexToDataIndex;
                            if (zpa != null && s2d != null)
                            {
                                // できるだけ丁寧に無駄な走査をしないようチェック
                                if (InMovie || InArchive)
                                {
                                    continue;
                                }
                                if (!(InSmartDirectory || InVirtualDirectory))
                                {
                                    var cd = currentLocation?.ToLower();
                                    if (string.IsNullOrEmpty(cd))
                                    {
                                        continue;
                                    }
                                    var last = cd.Last();
                                    if (last == Path.DirectorySeparatorChar || last == Path.AltDirectorySeparatorChar)
                                    {
                                        cd = cd.Substring(0, cd.Length - 1);
                                    }
                                    string currentParent;
                                    try
                                    {
                                        currentParent = Path.GetDirectoryName(current).ToLower();

                                        // ルートの場合に必要な処理
                                        if (currentParent.Last() == Path.DirectorySeparatorChar)
                                        {
                                            currentParent = currentParent.Substring(0, currentParent.Length - 1);
                                        }
                                    }
                                    catch
                                    {
                                        continue;
                                    }
                                    if (currentParent != cd)
                                    {
                                        continue;
                                    }
                                }

                                var count = zpa.Length;
                                var index = -1;
                                var showIndex = -1;
                                foreach (var i in s2d)
                                {
                                    showIndex++;
                                    if (i < 0 || i >= count) break;
                                    else if (current == zpa[i])
                                    {
                                        index = i;
                                        break;
                                    }
                                }
                                if (index >= 0)
                                {
                                    tvCatalog.SelectedIndex = index;
                                    tvCatalog.FocusedIndex = index;
                                    tvCatalog.ScrollBarToIndexWithMinimalMove(showIndex);
                                    // 詳細表示は自動的に連動する
                                }
                            }
                        }
                    }
                }
                //MessageBox.Show("exit");
                OpendByExternalApplication_Dictionary.Remove(p);
                p.Dispose();

                /*
                */
            }
            else
            {
                await Task.Run(() => p.WaitForExit()); // エクスプローラーを読んだ場合ここには到達するがすぐに終了する
                OpendByExternalApplication_Dictionary.Remove(p);
                p.Dispose();
            }
        }
        /*
        public async void SetOpendByExternalApplication(Process p, IEnumerable<string> fullPathSet)
        {
            if (p == null || p.HasExited || fullPathSet == null) return;
            var set = new HashSet<string>(from path in fullPathSet where !string.IsNullOrEmpty(path) select path.ToLower());
            if (!set.Any()) return;
            OpendByExternalApplication_Dictionary[p] = set;
            //#if DEBUG
            //            MessageBox.Show("Opend \"" + set.First() + "\"" + (set.Count == 1 ? "." : $" + {set.Count} files."));
            //#endif
            await Task.Run(() => p.WaitForExit()); // エクスプローラーを読んだ場合ここには到達するがすぐに終了する
            OpendByExternalApplication_Dictionary.Remove(p);
            //#if DEBUG
            //            MessageBox.Show("Closed \"" + set.First() + "\"" + (set.Count == 1 ? "." : $" + {set.Count} files."));
            //#endif
        }
        */
        public void AddToOpendByExternalApplicationDictionary(object key, IEnumerable<string> path)
        {
            if (path == null) return;
            var set = new HashSet<string>(from p in path where !string.IsNullOrEmpty(p) select p.ToLower());
            if (!set.Any()) return;
            OpendByExternalApplication_Dictionary[key] = set;
        }
        public void RemoveFromOpendByExternalApplicationDictionary(object key)
        {
            OpendByExternalApplication_Dictionary.Remove(key);
        }

        private SortMode sortMode = 0;
        private SortMode prevSortMode = 0;

        // 外部プログラムの起動で使う
        public string GetSortModeString() { return IsNonvolatileSort() ? sortMode.ToString() : "Indeterminate"; }

        private bool IsNonvolatileSort()
        {
            var result = false;
            try
            {
                Invoke(((MethodInvoker)(() =>
                {
                    result = cbSortBy.SelectedIndex >= 0;
                })));
            }
            catch (ObjectDisposedException) { }
            return result;
        }

        private ZipTag[] Tags;

        private ApplicationProvider[] ApplicationArray;

        private double aspectRatio = 1 / Math.Sqrt(2);

        private MyClipboardViewer clipboardViewer;

        public CatalogForm()
        {
#if RUNTIME
            Program.RunTimeMeasure.Block("StartConstructor");
#endif
            Constructor();
#if RUNTIME
            Program.RunTimeMeasure.Block("StartLoadSettings");
#endif

            LoadSettings(null);
        }

        public CatalogForm(string path, SortMode? sortMode = null, SortMode? preSortMode = null, string randomSeed = null)
        {
            Constructor();
            try
            {
                path = Program.GetFullPath(path);

                if (IsSupportedByCatalogFormAndExists(path))
                {
                    LoadSettings(path, sortModeOption: sortMode);
                    return;
                }
                //MessageBox.Show("1");
                var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);

                if (altPos < 0 || altPos >= path.Length - 1)
                {
                    //LoadSettings(path, sortModeOption: sortMode);
                    LoadSettings(Path.GetDirectoryName(path), getFileName(path), sortModeOption: sortMode);
                    return;
                }
                //MessageBox.Show("2");

                var parent = path.Substring(0, altPos);
                if (IsSupportedByCatalogFormAndExists(parent))
                {
                    LoadSettings(parent, path.Substring(altPos + 1), sortMode);
                    return;
                }
                //MessageBox.Show("3");

                LoadSettings(path, sortModeOption: sortMode);
                /*
            if (!path.EndsWith(Path.DirectorySeparatorChar.ToString()) && File.Exists(path) &&
                !(MovieThumbnailLoader.Supports(path) && MovieThumbnailLoader.ffmpegExists()))
            {
                LoadSettings(Path.GetDirectoryName(path), Path.GetFileName(path));
            }
            else
            {
                LoadSettings(path);
            }*/
            }
            catch
            {
                LoadSettings(sortModeOption: sortMode, preSortModeOption: preSortMode, randomSeedOption: randomSeed);
            }

        }

        private bool showStartHelpMessage = false;
        private bool showStartHelpMessageOfDirectoryList = false;
        private bool IsShown = false;
        private void CatalogForm_Shown(object sender, EventArgs e)
        {
#if RUNTIME
            Program.RunTimeMeasure?.Block("SetTagFilteringMenuItems");
#endif

            IsShown = true;
            thumbnailListToolStripMenuItem_CheckedChanged(null, null);
            //tbcIcon.Width = tbcIcon.HeaderCell.Size.Height; // tbcIcon.HeaderCell.Size.Height を使う場合ここで必要
            foreach (DataGridViewRow row in dgvDirectoryList.Rows) row.Selected = false;
            setTagFilteringMenuItems(needToRepairTagsFromBookmark: true, needToSaveCurrentTag: true, loadFromIni: true);

#if RUNTIME
            Program.RunTimeMeasure?.Block("SetEraserAndSearchIcon");
#endif

            // 高解像度環境でコンテクストメニューの高さを正しく得るためにはここで実行する必要がある
            setEraserAndSearchIcon();

            HintManager.ShowDialog(this, () =>
            {
                // ヒントを表示する場合のみ実行
                zabLocation.MakeButtons();

            }); // preAction は見栄えの問題

            if (firstCatalogFormRun)
            {
                using (var thumbnailCacheSettingForm = new ThumbnailCacheSettingForm(thumbnailCache, currentProfileColor, firstSetting: true))
                {
                    thumbnailCacheSettingForm.ShowDialog(this);
                    thumbnailCache = thumbnailCacheSettingForm.CacheRoot;
                }
            }

#if RUNTIME
            Program.RunTimeMeasure?.Block("SetCheckMarks");
#endif
            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(howToDoubleClickToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(layoutToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(archivesInArchiveToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(defaultPageSequenceToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(arrangeFoldersToolStripMenuItem.DropDown, noneFolderArrangeToolStripMenuItem, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(arrangeFoldersToolStripMenuItem.DropDown, displayFirstToolStripMenuItem, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(arrangeFoldersToolStripMenuItem.DropDown, displayLastToolStripMenuItem, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(arrangeFoldersToolStripMenuItem.DropDown, fitToDirectionOfSortToolStripMenuItem, DisplayCheckMark.Select);
            //CheckMarkProvider.SetCheckMark(arrangeFoldersToolStripMenuItem.DropDown, getFolderSizeToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(itemSelectionFeedbackToolStripMenuItem.DropDown, DisplayCheckMark.Select);

            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, archivesFilesPDFFielsToolStripMenuItem, DisplayCheckMark.CheckThreeState);
            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, imageFilesToolStripMenuItem, DisplayCheckMark.CheckThreeState);
            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, videoFilesToolStripMenuItem, DisplayCheckMark.CheckThreeState);
            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, otherFilesToolStripMenuItem, DisplayCheckMark.CheckThreeState);
            CheckMarkProvider.SetCheckMark(viewToolStripMenuItem.DropDown, foldersToolStripMenuItem, DisplayCheckMark.CheckThreeState);

            CheckMarkProvider.SetCheckMark(folderTreeSettingsToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(folderTreeSettingsToolStripMenuItem.DropDown, collapseOthersWhenSynchronizingToolStripMenuItem, DisplayCheckMark.Check);

            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, forceFirstPageToBeSingleToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, startInPreviousImageFilterSettingToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, alwaysAutomaticallyHideUIToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, sortFilesWithTheSameOrderAsThumbnailWindowToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, allowReadaheadProcessToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, loadWholeArchiveIntoMemoryToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, exceptReadAheadProcessToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(contextMenuSelectToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            //CheckMarkProvider.SetCheckMark(backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown, alwaysStartInWindowModeToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(maxCaptchaCountInAVideoToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, DisplayCheckMark.Select);
            CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, showRatingToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, showIconToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, showFilenameToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, showTagsToolStripMenuItem, DisplayCheckMark.Check);
            //CheckMarkProvider.SetCheckMark(thumbnailSizeToolStripMenuItem.DropDown, createCacheInADSInNTFSToolStripMenuItem, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(cmsFileListHeader, DisplayCheckMark.Check);
            CheckMarkProvider.SetCheckMark(ratingToolStripMenuItem.DropDown, DisplayCheckMark.SelectThreeState);
            CheckMarkProvider.SetCheckMark(pageSequenceToolStripMenuItem.DropDown, DisplayCheckMark.SelectThreeState);


            if (emptyStartLocation)
            {
                showStartHelpMessage = true;
                tvCatalog.Invalidate();
            }

            if (dgvDirectoryList.RowCount == 0)
            {
                showStartHelpMessageOfDirectoryList = true;
                dgvDirectoryList.Invalidate();
            }

#if RUNTIME
            Program.RunTimeMeasure?.Block("StartCheckUpdate");
#endif

            Configuration.ClosePrepareMode();
            
            betterFormRestoreBounds = new BetterFormRestoreBounds(this);

            Program.StartCheckUpdateAndNgen(this, checkNgen);
            //PackedImageLoader.CheckSevenZipExistence(this); フォルダ読み込み時にチェックされるので不要


#if RUNTIME
            Program.RunTimeMeasure.Dispose();
            Program.RunTimeMeasure = null;
#endif
        }

        private ToolStripDropDown ratingFilterToolStripMenuItemDropDown;
        private ToolStripDropDown addToolStripMenuItemDropDown;

#if DEBUG
        // リリース版で有効にする場合リロードへの対処やエラー処理を記述すること
        private void backupFilepath_Click(object sender, EventArgs e)
        {
            if (ZipPathArray == null) return;
            var sizeToPath = new Dictionary<long, string>();
            for (var i = 0; i < ZipPathArray.Length; i++)
            {
                var path = ZipPathArray[i];
                var size = ZipSizeArray[i];
                if (!sizeToPath.ContainsKey(size))
                {
                    sizeToPath[size] = path;
                }
                else
                {
                    MessageBox.Show(this, $"File size duplicates.\n\n{ Program.GetFormatSizeString(size, "Bytes")}\n{sizeToPath[size]}\n{path}");
                    return;
                }
            }

            if (sizeToPath.Count == 0) return;

            string savePath = null;
            using (var dialog = new SaveFileDialog())
            {
                dialog.Filter = "*.txt|*.txt";
                if (dialog.ShowDialog(this) == DialogResult.OK)
                {
                    savePath = dialog.FileName;
                }
            }

            if (savePath != null)
            {
                using (var writer = new StreamWriter(savePath, append: false))
                {
                    foreach (var pair in sizeToPath)
                    {
                        writer.WriteLine(pair.Key + "\t" + pair.Value);
                    }
                }
            }
        }

        // （予定はないが）リリース版で有効にする場合リロードへの対処やエラー処理を記述すること
        private void saveIntensiveLines_Click(object sender, EventArgs e)
        {
            try
            {
                var path = ZipPathArray[tvCatalog.SelectedIndex];
                using (var target = new Bitmap(path))
                using (var intensiveLines = BitmapAnalyzer.GetIntensiveLines(target, pixelRatio: 1))
                using (var dialog = new SaveFileDialog())
                {
                    dialog.Filter = "PNG files|*.png";
                    if (dialog.ShowDialog(this) == DialogResult.OK)
                    {
                        intensiveLines.Save(dialog.FileName);
                    }
                }
            }
            catch { }
        }

        private void filterPerformanceTest_Click(object sender, EventArgs e)
        {
            var s = cbFilter.Text;

            var re = new Regex(Regex.Escape(s), RegexOptions.IgnoreCase);

            var rec = new Regex(Regex.Escape(s), RegexOptions.IgnoreCase | RegexOptions.Compiled);

            var names = ZipNameArray.Where(name => name != null).ToArray();

            var sw = new Stopwatch();
            var ss = "";
            var count = 0;
            sw.Start();

            count = 0;
            foreach (var name in names)
            {
                if (name.Contains(s)) count++;
            }
            sw.Stop(); ss += $"plain:\t{sw.Elapsed}\n"; sw.Restart();


            count = 0;
            foreach (var name in names)
            {
                if (re.IsMatch(name)) count++;
            }
            sw.Stop(); ss += $"notcmp:\t{sw.Elapsed}\n"; sw.Restart();

            count = 0;
            foreach (var name in names)
            {
                if (rec.IsMatch(name)) count++;
            }
            sw.Stop(); ss += $"cmp:\t{sw.Elapsed}\n"; MessageBox.Show(ss);
        }
#endif
        /*
        private int? GetCurrentShowIndex()
        {
            try
            {
                var f = tvCatalog.FocusedIndex;
                if (f >= 0) return tvCatalog.DataIndexToShowIndex[f];
                else return null;
            }
            catch
            {
                return null;
            }
        }
        */
        int tbcIconWidth, tbcMargin;

        Font MenuTextFont = null;


        public static bool MenuTextFontShouldBeReplaced()
        {
            // Windows 10 CreatorsUpdate で「テキストサイズのみを変更する」が廃止されたので仕様変更
            // OS のバージョンにかかわらず、一部の外部ツールにせていされたフォントを拾うことができる
            return false;

            // Windows 10 の「テキストサイズのみを変更する」の設定を拾うためのコード
            /*
            if (Program.DisplayMagnification < 1.001) return false;

            try
            {
                return SystemInfoManager.IsWindowsVersionOrGreater(6, 2, 0);
            }
            catch
            {
                return false;
            }

            // Windows 8.1以上、もしくはWindows Server 2012 R2以上では正しいバージョンを返さずに、「6.2」と返す可能性（Windows 10 でこの動作を確認済み）
            // http://dobon.net/vb/dotnet/system/osversion.html#windows8point1
            // 6.2 以上かどうかを調べるなら現状問題ないが、将来的に 6.2 とすら返さなくなる可能性を考慮して使用しない
            //var version = Environment.OSVersion.Version;
            //var major = version.Major;
            //return major > 6 || major == 6 && version.Minor >= 2;
            */
        }

        private GestureListener gestureListener;
        private GestureListener gestureListenergCmsRightRoot;
        private GestureListener gestureListenergCmsRightTag;
        private MiniControlTouchGesture mctgCatalogForm;
        private MiniControlTouchGesture mctgCmsRightRoot;
        private MiniControlTouchGesture mctgCmsRightTag;

        private BetterFormRestoreBounds betterFormRestoreBounds;
        private new Rectangle RestoreBounds { get => betterFormRestoreBounds?.BetterRestoreBounds ?? base.RestoreBounds; }

        private void Constructor()
        {
            Configuration.PrepareXmlSerializer(
                typeof(CatalogFormConfig),
                typeof(ColoredBookmarkConfig),
                typeof(GeneralConfig),
                typeof(ZipTagConfig));


            if (Program.CheckConfigException())
            {
                CatalogForm_FormClosing_FormClosed = true;
                Close();
            }

#if RUNTIME
            Program.RunTimeMeasure.Block("InitializeComponent");
#endif
            InitializeComponent();


#if RUNTIME
            Program.RunTimeMeasure.Block("WaitPrepareTask");
#endif

            Configuration.WaitPrepareTask();

#if DEBUG
            // ファイル名のバックアップ
            var backupFilepath = new ToolStripMenuItem("Backup filepath");
            backupFilepath.Click += backupFilepath_Click;
            cmsRightClick.Items.Insert(cmsRightClick.Items.IndexOf(pasteToolStripMenuItem) + 1, backupFilepath);

            // 集中線の出力
            var saveIntensiveLines = new ToolStripMenuItem("Save intensive lines");
            saveIntensiveLines.Click += saveIntensiveLines_Click;
            cmsRightClick.Items.Insert(cmsRightClick.Items.IndexOf(backupFilepath) + 1, saveIntensiveLines);

            // フィルタ実験
            var filterPerformanceTest = new ToolStripMenuItem("Filter performance test");
            filterPerformanceTest.Click += filterPerformanceTest_Click;
            cmsRightClick.Items.Insert(cmsRightClick.Items.IndexOf(saveIntensiveLines) + 1, filterPerformanceTest);
#endif

#if RUNTIME
            Program.RunTimeMeasure.Block("PrepareTouch");
#endif
            try
            {
                gestureListener = new GestureListener(this, new GestureConfig[] {
                    new GestureConfig(3, 1, 0), // ズーム
                    new GestureConfig(4, 2 | 4 | 16 , 8 ), // パン、向き拘束なし
                    
                    new GestureConfig(5, 1, 0), // 回転
                    new GestureConfig(6, 1, 0), // ツーフィンガータップ
                    new GestureConfig(7, 1, 0), // プレスアンドタップ

                });

                new DataGridViewScrollBarTouchFixer(dgvFileList, gestureListener);
                new DataGridViewScrollBarTouchFixer(dgvDirectoryList, gestureListener);

                mctgCatalogForm = new MiniControlTouchGesture(this, gestureListener, onlyHorizontalStart: false);
                var target = mctgCatalogForm.Targets;
                target.Add(menuStripLeft);
                target.Add(menuStripForTagFilter);
                target.Add(cbFilter);
                target.Add(btnGoToBack);
                target.Add(btnGoToForward);
                target.Add(tvCatalog);
                target.Add(dgvFileList);
                mctgCatalogForm.TouchGestureStarting += mctgCatalogForm_TouchGestureStarting;
                mctgCatalogForm.TouchGestureCompleted += mctgCatalogForm_TouchGestureCompleted;

                gestureListener.Zoom += gestureListener_Zoom;
                gestureListener.Pan += gestureListener_Pan;
                gestureListener.Rotate += gestureListener_Rotate;
                gestureListener.TwoFingerTap += gestureListener_TwoFingerTap;
                gestureListener.PressAndTap += gestureListener_PressAndTap;

                gestureListenergCmsRightRoot = MiniControlTouchGesture.GetGestureListener(cmsRightClick);
                mctgCmsRightRoot = new MiniControlTouchGesture(cmsRightClick, gestureListenergCmsRightRoot, onlyHorizontalStart: true);
                mctgCmsRightRoot.Targets.Add(cmsRightClick);
                mctgCmsRightRoot.TouchGestureStarting += TouchGestureStartingForTagMenu;
                mctgCmsRightRoot.TouchGestureCompleted += TouchGestureCompletedForTagMenu;
                gestureListenergCmsRightTag = MiniControlTouchGesture.GetGestureListener(tagToolStripMenuItem.DropDown);
                mctgCmsRightTag = new MiniControlTouchGesture(tagToolStripMenuItem.DropDown, gestureListenergCmsRightTag, onlyHorizontalStart: true);
                mctgCmsRightTag.Targets.Add(tagToolStripMenuItem.DropDown);
                mctgCmsRightTag.TouchGestureStarting += TouchGestureStartingForTagMenu;
                mctgCmsRightTag.TouchGestureCompleted += TouchGestureCompletedForTagMenu;
            }
            catch { }

#if RUNTIME
            Program.RunTimeMeasure.Block("PrepareKeyMouseBinder");
#endif

            //ratingToolStripMenuItem.DropDown.KeyDown += ratingToolStripMenuItem_DropDown_KeyDown;
            new KeyMouseBinder(cmsRightClick, requiredKeyMouseBindingCmsRightRootOrTag);
            new KeyMouseBinder(tagToolStripMenuItem.DropDown, requiredKeyMouseBindingCmsRightRootOrTag);
            new KeyMouseBinder(ratingToolStripMenuItem.DropDown, requiredKeyMouseBindingCmsTrue);
            new KeyMouseBinder(pageSequenceToolStripMenuItem.DropDown, requiredKeyMouseBindingCmsTrue);


            tvCatalog.GotFocus += tvCatalog_GotFocus;
            dgvDirectoryList.GotFocus += dgvDirectoryList_GotFocus;
            dgvFileList.GotFocus += dgvFileList_GotFocus;
            explorerTreeView.TreeViewWnd.GotFocus += explorerTreeView_TreeViewWnd_GotFocus;

#if RUNTIME
            Program.RunTimeMeasure.Block("Replace font etc");
#endif

            if (MenuTextFontShouldBeReplaced())
            {
                MenuTextFont = new Font(menuStrip.Font.FontFamily, DefaultFont.SizeInPoints);
            }

            if (MenuTextFont != null)
            {
                menuStrip.Font = MenuTextFont;
                menuStripForTagFilter.Font = MenuTextFont;
                statusStrip.Font = MenuTextFont;
                menuStripLeft.Font = MenuTextFont;
            }

            ZipPlaAddressBar.AddDrawToolStripMenuItemTriangleEventHandler(menuStrip);
            ZipPlaAddressBar.AddDrawToolStripMenuItemTriangleEventHandler(cmsRightClick);
            tagToolStripMenuItem.Paint += ZipPlaAddressBar.DrawToolStripMenuItemTriangle; // この時点では子を持たないので自動的には追加されない
            allRatiosToolStripMenuItem.Paint += ZipPlaAddressBar.DrawToolStripMenuItemTriangle; // この時点では子を持たないので自動的には追加されない

            tvCatalog.DragOutSelection = true;
            tvCatalog.DragOutSingle = true;
            dgvFileList.DragOutSelection = true;
            dgvFileList.DragOutSingle = true;
            //dgvFileList.GetCurrentIndex = GetCurrentShowIndex;

            cmsRightClick.Opening += OpenInFileInClipboardProvider.Owner_Opening;
            cmsRightClick.Closed += OpenInFileInClipboardProvider.Owner_Closed;


            /*
#if DEBUG
            Load += (sender, e) => setNewDynamicStringSelectionToolStripMenuItems(new SelectionToFilterToolStripMenuItem[] { new SelectionToFilterToolStripMenuItem(this) });
            //Load += (sender, e) => setNewDynamicStringSelectionToolStripMenuItems(new SelectionToFilterToolStripMenuItem[] { });
#else
            x = y;
#endif
            */

            tvCatalog.bottomPadding = Program.DpiScaling(2);


            clipboardViewer = new MyClipboardViewer(this);
            clipboardViewer.ClipboardHandler += ClipboardViewer_ClipboardHandler;

            openbuiltinBookReaderToolStripMenuItem.Image = BuiltInViewerProvider.Icon;

#if RUNTIME
            Program.RunTimeMeasure.Block("Set explorer icon");
#endif

            openInExplorerInDirectoryListToolStripMenuItem.Image = ExplorerIcon;// ExplorerProvider.Icon;

#if RUNTIME
            Program.RunTimeMeasure.Block("Set UndoButton etc");
#endif

            setUndoButton(btnGoToBack, goBack: true);
            setUndoButton(btnGoToForward, goBack: false);

            //Program.SetDoubleBuffered(tvCatalog); // 初めから有効

            Program.SetDoubleBuffered(dgvFileList);
            Program.SetDoubleBuffered(dgvDirectoryList);


            setMenuItemEventHandler();

            //ApplicationArray = new ApplicationProvider[] { new BuiltInViewerProvider(this), new AssociationProvider(), new MoveLocationProvider(this) };

            tbcIcon.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcIconWidth = (int)Math.Round(Program.DisplayMagnificationX * 22); // 21 が限界値
            //tbcIconWidth = tbcIcon.HeaderCell.Size.Height - 1; // 100 % のときこれで 22 になる。23 が限界値
            tbcMargin = tbcIconWidth / 11;
            tbcIcon.Width = tbcIconWidth;
            tbcFileName.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcPage.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcRating.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcCreateTime.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcAccessTime.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcWriteTime.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcSize.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcResolution.HeaderCell.Style.WrapMode = DataGridViewTriState.False; ;
            tbcRatio.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcWidth.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcHeight.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcLength.HeaderCell.Style.WrapMode = DataGridViewTriState.False;
            tbcFPS.HeaderCell.Style.WrapMode = DataGridViewTriState.False;

            dgvFileList.MouseWheel += DgvFileList_MouseWheel;

            ratingFilterToolStripMenuItemDropDown = ratingFilterToolStripMenuItem.DropDown;
            ratingFilterToolStripMenuItem.DropDown = null;
            //menuStripForTagFilter.MouseWheel += MenuStripForTagFilter_MouseWheel;

            addToolStripMenuItemDropDown = addToolStripMenuItem.DropDown;
            addToolStripMenuItem.DropDown = null;

            ToolStripDropDownScroller.Enscrollable(tagToolStripMenuItem.DropDown, gestureListenergCmsRightTag);

            // 列の追加を DataGridViewRow を使って行えば必要ない
            //dgvDirectoryList.RowTemplate.Height = dgvFileList.RowTemplate.Height = Program.DpiScalingY(21);

            dgvSorter = new DataGridViewSorter(dgvDirectoryList);
            dgvSorter.CellClick += DgvSorter_CellClick;
            dgvSorter.RowsReleased += DgvSorter_RowsReleased;
            dgvSorter.UserSorted += DgvSorter_UserSorted;

            mgCatalog = new MouseGesture(tvCatalog);
            mgCatalog.MouseGestureStarting += MgCatalog_MouseGestureStarting;
            mgCatalog.MouseGestureCompleted += MgCatalog_MouseGestureCompleted;
            mgCatalog.Enabled = false; // 最初の Enabled = true で次のイベントが発動するように
            mgCatalog.EnabledChanged += mgCatalog_EnabledChanged;
            mgFileList = new MouseGesture(dgvFileList);
            mgFileList.MouseGestureStarting += mgFileList_MouseGestureStarting;
            mgFileList.MouseGestureCompleted += mgFileList_MouseGestureCompleted;
            mgFileList.Enabled = false; // mgCatalog との整合性のため
                                        /*
                            #if !DEBUG
                                        mgCatalog.Enabled = false;
                                        mgFileList.Enabled = false;
                                        mouseGestureSettingToolStripMenuItem.Visible = false;
                            #endif
                                        */

#if !DEBUG
            loadCountToolStripMenuItem.Visible = false;
#endif

            var nonvol = new string[(int)SortMode.Random + 1];
            for (var i = 0; i < (int)SortMode.Random + 1; i++) nonvol[i] = ((SortMode)i).ToString();
            cbSortBy.Items.AddRange(nonvol);
            cbSortBy.SelectedIndex = 0;


            // DPI 変更時用の処理
            var lineWidth = Program.DpiScaling(1);
            var boxWidth = cbLocation.Height + 2 * lineWidth;
            var boxWidth2 = (boxWidth * (2 * 12) + 11) / (2 * 11);
            MinimumSize = Size;
            //WindowMinWidth = Width;
            btnGoToBack.Location = new Point(btnGoToBack.Location.X + (btnGoToBack.Width - boxWidth2) / 2,
                cbLocation.Location.Y - lineWidth);
            btnGoToBack.Size = new Size(boxWidth2, boxWidth);
            btnGoToForward.Location = new Point(btnGoToForward.Location.X + (btnGoToForward.Width - boxWidth2) / 2,
                cbLocation.Location.Y - lineWidth);
            btnGoToForward.Size = new Size(boxWidth2, boxWidth);
            btnLocationCommands.Location = new Point(cbLocation.Right, cbLocation.Location.Y - lineWidth);
            //btnLocationCommands.Height = cbLocation.Height + 2;
            btnLocationCommands.Size = new Size(boxWidth, boxWidth);

            boxWidth = cbFilter.Height + 2 * lineWidth;
            btnFilterCommands.Location = new Point(cbFilter.Right, cbFilter.Location.Y - lineWidth);
            btnFilterCommands.Size = new Size(boxWidth, boxWidth);

#if RUNTIME
            Program.RunTimeMeasure.Block("SetMessagesWithoutTagFilter");
#endif

            //Text = Program.Name;
            SetMessagesWithoutTagFilter();

            // 静的な Shown に移動
            //Shown += (sender, e) => setTagFilteringMenuItems();

#if RUNTIME
            Program.RunTimeMeasure.Block("SetProcessEtc");
#endif

            bmwMakePreview.ThreadCount = Math.Max(1, Environment.ProcessorCount / 2);
            Program.SetPriority(ProcessPriorityClass.Normal);
            PrepareLookAheadProcess(/*Configuration.GetLastWriteTime()*/);
            //menuStripForTagFilter.Location = new Point(menuStrip.Right - menuStripForTagFilter.Width, menuStrip.Top);
            menuStripForTagFilter.Top = menuStrip.Top;
            menuStripForTagFilter.Height = menuStrip.Size.Height;

#if RUNTIME
            Program.RunTimeMeasure.Block("CorrectPanelLayout");
#endif

            CenterPanellMinWidth = splRight.MinExtra = Program.DpiScalingX(105) + 2 * Program.DpiScaling(2);
            Shown += (sender, e) => pnlRight_SizeChanged(null, null);
            //tbcFileName.MinimumWidth = Program.DpiScalingX(70);
            var seventy = Program.DpiScalingX(70);
            splLeft.MinSize = seventy;
            splRight.MinSize = seventy;
            SidePanellMinWidth = seventy;

            splBookmark.MinSize = Program.DpiScalingY(50);
            splBookmark.MinExtra = Program.DpiScalingY(35);

            //zabLocation = new ZipPlaAddressBar(this, cbLocation, tvCatalog); // otherControl は非表示になるものは好ましくない
            zabLocation = new ZipPlaAddressBar(this, cbLocation, focusRobber: focusVisibleMainList);

            // 安全のため（v1.5.3.3 の不具合修正とともに）
            zabLocation.Text = "";

            zabLocation.MouseEnter += zabLocation_MouseEnter;
            zabLocation.MouseLeave += zabLocation_MouseLeave;
            zabLocation.DirectoryExistsOverrider = s => Directory.Exists(s) || IsSupportedByCatalogFormExceptFolder(s); // VirtualFolder.DirectoryOrBookmarkExists;
            //zabLocation.GetDirectoriesOverrider = VirtualFolder.GetDirectoriesAndBookmarks;

            zabLocation.DragDropStarting += zabLocation_DragDropStarting;
            zabLocation.DragDropFinished += zabLocation_DragDropFinished;

            zabLocation.ZipPlaAddressBarMakeButtonStarting += zabLocation_ZipPlaAddressBarMakeButtonStarting;

#if SCREENCAPTCHA
            zabLocation.GetDisplayNameOverrider = path =>
            {
                var result = SimpleBookmark.GetDisplayName(path);
                if (Message.CurrentLanguage.ToString() == "en-US")
                {
                    var m = Regex.Match(result, @"^ローカル ディスク \(([A-Z]):\)$");
                    if (m.Success)
                    {
                        return $"Local Disk ({m.Groups[1].Value}:)";
                    }
                }
                return result;
            };
#else
            zabLocation.GetDisplayNameOverrider = SimpleBookmark.GetDisplayName;
#endif
            zabLocation.TextChangedByButton += zabLocation_TextChangedByButton;
            zabLocation.TextChangedByBaseControl += zabLocation_TextChangedByBaseControl;
            zabLocation.CurrentLocationButtonClick += zabLocation_CurrentLocationButtonClick;
            zabLocation.DirectoryButtonContextMenuStripOpening += zabLocation_DirectoryButtonContextMenuStripOpening;

            zabLocation.AllowDrop = true;
            zabLocation.SubControlDragEnter += zabLocation_SubControlDragEnter;
            zabLocation.SubControlDragDrop += zabLocation_SubControlDragDrop;

            cbLocationMinimumWidth = cbLocation.Width;


#if RUNTIME
            Program.RunTimeMeasure.Block("SetAspectRatioOption1");
#endif

            //var screenSize = Screen.FromControl(this).Bounds;
            var screenSize = Screen.PrimaryScreen.Bounds;

#if RUNTIME
            Program.RunTimeMeasure.Block("SetAspectRatioOption2");
#endif
            int w = screenSize.Width;
            int h = screenSize.Height;
            while (w > 0)
            {
                var c = h % w;
                h = w;
                w = c;
            }
            w = screenSize.Width / h;
            h = screenSize.Height / h;

            if (w == 8 && h == 5 || w == 5 && h == 8)
            {
                w *= 2;
                h *= 2;
            }
            setAspectRatioOption((new Tuple<string, double>[]
            {
                Tuple.Create("1 : √2", 1.0 / Math.Sqrt(2.0)),
                Tuple.Create("1 : 1", 1.0 / 1.0),
                Tuple.Create("√2 : 1", Math.Sqrt(2.0) / 1),
                Tuple.Create($"{w} : {h}", (double)w / h),
            }).OrderBy(x => x.Item2).ToArray(),
            new Tuple<string, double>[]
            {
                Tuple.Create("1 : 5", 1.0 / 5.0),
                Tuple.Create("1 : 4", 1.0 / 4.0),
                Tuple.Create("1 : 3", 1.0 / 3.0),
                Tuple.Create("1 : 2", 1.0 / 2.0),
                Tuple.Create("9 : 16", 9.0 / 16.0),
                Tuple.Create("10 : 16", 10.0 / 16.0),
                Tuple.Create("2 : 3", 2.0 / 3.0),
                Tuple.Create("1 : √2", 1.0 / Math.Sqrt(2.0)),
                Tuple.Create("3 : 4", 3.0 / 4.0),
                Tuple.Create("4 : 5", 4.0 / 5.0),
                Tuple.Create("1 : 1", 1.0 / 1.0),
                Tuple.Create("5 : 4", 5.0 / 4.0),
                Tuple.Create("4 : 3", 4.0 / 3.0),
                Tuple.Create("√2 : 1", Math.Sqrt(2.0) / 1.0),
                Tuple.Create("3 : 2", 3.0 / 2.0),
                Tuple.Create("16 : 10", 16.0 / 10.0),
                Tuple.Create("16 : 9", 16.0 / 9.0),
                Tuple.Create("2 : 1", 2.0 / 1.0),
                Tuple.Create("3 : 1", 3.0 / 1.0),
                Tuple.Create("4 : 1", 4.0 / 1.0),
                Tuple.Create("5 : 1", 5.0 / 1.0),

            }.OrderBy(x => x.Item2).ToArray());

#if RUNTIME
            Program.RunTimeMeasure.Block("SetKeepOpen");
#endif

            SetKeepOpen(viewToolStripMenuItem);
            //SetKeepOpen(thumbnailSizeToolStripMenuItem, thumbnailCacheToolStripMenuItem, createViewerShortcutFromCurrentSettingsToolStripMenuItem);
            SetKeepOpen(thumbnailSizeToolStripMenuItem);

            Shown += (sender, e) =>
            {
                ratingFilterToolStripMenuItem.AutoSize = false;
                ratingFilterToolStripMenuItem.Text = "";
            };
        }

        private static bool requiredKeyMouseBindingCmsRightRootOrTag(ToolStripItem toolStripItem)
        {
            if (toolStripItem is PrefixEscapedToolStripMenuItem) return true;
            var items = toolStripItem.Owner.Items;
            return items.Count >= 3 && items[0] == toolStripItem && items[2] is PrefixEscapedToolStripMenuItem;
        }
        private static bool requiredKeyMouseBindingCmsTrue(ToolStripItem toolStripItem)
        {
            return true;
        }

        private void gestureListener_TwoFingerTap(object sender, TwoFingerTapEventArgs e)
        {
            CloseVisibleContextMenuStrips();
            e.Handled = true;
            if (!e.Begin) return;
            if (TryPerformMiddleMouseClickOnTvCatalog(e.Location)) return;
            if (TryPerformMiddleMouseClickOnDgvFileList(e.Location)) return;

            simplifiedKeyBoard.UpHeldKey();
        }

        private void gestureListener_PressAndTap(object sender, PressAndTapEventArgs e)
        {
            CloseVisibleContextMenuStrips();
            e.Handled = true;
            if (!e.Begin) return;
            if (TryPerformRightMouseClickOnTvCatalog(e.Location)) return;
            if (TryPerformRightMouseClickOnDgvFileList(e.Location)) return;
            if (TryPerformMouseClick(dgvDirectoryList, MouseButtons.Right, e.Location)) return;
            if (TryPerformRightMouseClickOnTreeView(e.Location)) return;

            simplifiedKeyBoard.UpHeldKey();
        }

        private bool TryPerformRightMouseClickOnTreeView(Point screenPoint)
        {
            var treeWnd = explorerTreeView.TreeViewWnd;
            if (!treeWnd.Visible) return false;
            var clientLocation = treeWnd.PointToClient(screenPoint);
            if (!treeWnd.ClientRectangle.Contains(clientLocation)) return false;
            var hit = treeWnd.HitTest(clientLocation);

            if (hit.Node != null)
            {
                simplifiedKeyBoard.UpHeldKey();
                explorerTreeView_NodeMouseClick(null, new TreeNodeMouseClickEventArgs(hit.Node, MouseButtons.Right, 1, clientLocation.X, clientLocation.Y));
            }

            return true; // ヒットしなくとも終わる

        }

        private void middleClickContextMenuPrepareAndShow(Point screenPoint, Keys dummy)
        {
            middleClickContextMenuPrepareAndShow(screenPoint);
        }

        private bool TryPerformMiddleMouseClickOnTvCatalog(Point screenPoint)
        {
            return TryPerformMouseClickOnTvCatalog(middleClickContextMenuPrepareAndShow, screenPoint);
        }

        private bool TryPerformRightMouseClickOnTvCatalog(Point screenPoint)
        {
            return TryPerformMouseClickOnTvCatalog(rightClickContextMenuPrepareAndShow, screenPoint);
        }

        private bool TryPerformMouseClickOnTvCatalog(Action<Point, Keys> prepareAndShow, Point screenPoint)
        {
            if (!tvCatalog.Visible) return false;
            var clientLocation = tvCatalog.PointToClient(screenPoint);
            if (!tvCatalog.ClientRectangle.Contains(clientLocation)) return false;

            var index = tvCatalog.PointToIndex(clientLocation);
            if (index >= 0)
            {
                if (!tvCatalog.SelectedIndices.Contains(index)) tvCatalog.SelectedIndex = index;
                prepareAndShow(screenPoint, ModifierKeys);
                return true;
            }
            else
            {
                tvCatalog.SelectedIndex = -1;
                prepareAndShow(screenPoint, ModifierKeys);
                return true;
            }
        }
        private bool TryPerformMiddleMouseClickOnDgvFileList(Point screenPoint)
        {
            return TryPerformMouseClickOnDgvFileList(middleClickContextMenuPrepareAndShow, screenPoint);
        }


        private bool TryPerformRightMouseClickOnDgvFileList(Point screenPoint)
        {
            return TryPerformMouseClickOnDgvFileList(rightClickContextMenuPrepareAndShow, screenPoint);
        }

        private bool TryPerformMouseClickOnDgvFileList(Action<Point, Keys> prepareAndShow, Point screenPoint)
        {
            if (!dgvFileList.Visible) return false;
            var clientLocation = dgvFileList.PointToClient(screenPoint);
            if (!dgvFileList.ClientRectangle.Contains(clientLocation)) return false;

            var hit = dgvFileList.HitTest(clientLocation.X, clientLocation.Y);
            if (hit.RowIndex >= 0)
            {
                var clickedRow = dgvFileList.Rows[hit.RowIndex];
                if (!clickedRow.Selected)
                {
                    var temp = selectionSynchronizing;
                    selectionSynchronizing = true;
                    foreach (DataGridViewRow row in (from DataGridViewRow r in dgvFileList.SelectedRows select r).ToArray())
                    {
                        row.Selected = false;
                    }
                    selectionSynchronizing = temp;
                    clickedRow.Selected = true;
                }
                prepareAndShow(screenPoint, ModifierKeys);
                return true;
            }
            else
            {
                tvCatalog.SelectedIndex = -1;
                prepareAndShow(screenPoint, ModifierKeys);
                return true;
            }
        }

        private bool TryPerformMouseClick(Control control, MouseButtons button, Point screenPoint)
        {
            if (!control.Visible) return false;
            var clientLocation = control.PointToClient(screenPoint);
            if (control.ClientRectangle.Contains(clientLocation))
            {
                control.Focus();
                Application.DoEvents();
                PerformMouseDown(control, new MouseEventArgs(button, 1, clientLocation.X, clientLocation.Y, 0));
                //PerformMouseMove(control, new MouseEventArgs(button, 1, clientLocation.X, clientLocation.Y, 0));
                Application.DoEvents();
                PerformMouseUp(control, new MouseEventArgs(button, 1, clientLocation.X, clientLocation.Y, 0));
                return true;
            }
            else
            {
                return false;
            }
        }

        private void gestureListener_Rotate(object sender, RotateEventArgs e)
        {
            CloseVisibleContextMenuStrips();
            if (showThumbnailMenuForTouch(e))
            {
                var items = thumbnailSizeToolStripMenuItem.DropDownItems;
                var index = items.IndexOf(thumbnailSizeBottomSeparator) + 1;
                ToolStripMenuItem item;
                while ((item = (ToolStripMenuItem)items[index++]) != allRatiosToolStripMenuItem)
                {
                    if (item.Checked)
                    {
                        item.Select();
                        return;
                    }
                }
                allRatiosToolStripMenuItem.Select();
            }

            e.Handled = true;
        }

        private void gestureListener_Zoom(object sender, ZoomEventArgs e)
        {
            CloseVisibleContextMenuStrips();
            if (showThumbnailMenuForTouch(e))
            {
                var items = thumbnailSizeToolStripMenuItem.DropDownItems;
                var index = items.IndexOf(thumbnailSizeTopSeparator) + 1;
                ToolStripItem item;
                while ((item = items[index++]) != thumbnailSizeBottomSeparator)
                {
                    var item1 = (ToolStripMenuItem)item;
                    if (item1.Checked)
                    {
                        item1.Select();
                        return;
                    }
                }
            }

            e.Handled = true;
        }

        private bool showThumbnailMenuForTouch(GestureEventArgs e)
        {
            var ok = false;
            if (!thumbnailSizeToolStripMenuItem.DropDown.Visible)
            {
                var loc = e.Location;
                ok = tvCatalog.Visible && tvCatalog.ClientRectangle.Contains(tvCatalog.PointToClient(loc));
                if (!ok && dgvFileList.Visible)
                {
                    var cloc = dgvFileList.PointToClient(loc);
                    if (dgvFileList.ClientRectangle.Contains(cloc))
                    {
                        ok = dgvFileList.HitTest(cloc.X, cloc.Y).Type != DataGridViewHitTestType.ColumnHeader;
                    }
                }
                if (ok)
                {
                    thumbnailSizeToolStripMenuItem.ShowDropDown();
                }
            }
            return ok;
        }

        Control TouchListener_Pan_HoldedControl = null;
        private static MethodInfo OnMouseDownMethodInfo = typeof(Control).GetMethod("OnMouseDown", BindingFlags.NonPublic | BindingFlags.Instance);
        private static MethodInfo OnMouseMoveMethodInfo = typeof(Control).GetMethod("OnMouseMove", BindingFlags.NonPublic | BindingFlags.Instance);
        private static MethodInfo OnMouseUpMethodInfo = typeof(Control).GetMethod("OnMouseUp", BindingFlags.NonPublic | BindingFlags.Instance);
        public static void PerformMouseDown(Control control, MouseEventArgs e) { OnMouseDownMethodInfo.Invoke(control, new object[1] { e }); }
        public static void PerformMouseMove(Control control, MouseEventArgs e) { OnMouseMoveMethodInfo.Invoke(control, new object[1] { e }); }
        private static void PerformMouseUp(Control control, MouseEventArgs e) { OnMouseUpMethodInfo.Invoke(control, new object[1] { e }); }
        private static HashSet<Control> PerformMouseAction_HoldedControls = new HashSet<Control>();
        private static void PerformMouseAction(Control control, PanEventArgs pe, Point clientPoint)
        {
            var me = new MouseEventArgs(MouseButtons.Left, 1, clientPoint.X, clientPoint.Y, 0);
            if (pe.Begin)
            {
                if (PerformMouseAction_HoldedControls.Add(control))
                {
                    PerformMouseDown(control, me);
                }
            }
            else if (!(pe.End || pe.Inertia))
            {
                PerformMouseAction_HoldedControls.Add(control);
                PerformMouseMove(control, me);
            }
            else
            {
                if (PerformMouseAction_HoldedControls.Remove(control))
                {
                    PerformMouseUp(control, me);
                }
            }
        }
        //private bool TouchListener_Pan_Gesturing = false;
        private void gestureListener_Pan(object sender, PanEventArgs e)
        {
            // DataGridViewScrollBarTouchFixer が先行することが前提
            if (e.Handled) return;

            CloseVisibleContextMenuStrips();

            Control control;
            Point clientPoint;

            // 順番が重要：水平セパレータ→垂直セパレータ→その他
            if (TouchListener_Pan_Test(control = splBookmark, e, out clientPoint))
            {
                PerformMouseAction(control, e, clientPoint);
                if (e.Inertia) control = null;
                e.Handled = true;
            }
            else if (TouchListener_Pan_Test(control = splRight, e, out clientPoint))
            {
                PerformMouseAction(control, e, clientPoint);
                if (e.Inertia) control = null;
                e.Handled = true;
            }
            else if (TouchListener_Pan_Test(control = splLeft, e, out clientPoint))
            {
                PerformMouseAction(control, e, clientPoint);
                if (e.Inertia) control = null;
                e.Handled = true;
            }
            else if (TouchListener_Pan_Test(control = tvCatalog, e, out clientPoint))
            {
                TouchListener_Pan_MouseGesture(e, mgCatalog, clientPoint);
            }
            else if (TouchListener_Pan_Test(control = dgvFileList, e, out clientPoint))
            {
                TouchListener_Pan_MouseGesture(e, mgFileList, clientPoint);
            }
            else if (TouchListener_Pan_Test(control = dgvDirectoryList, e, out clientPoint))
            {
                e.Handled = false;
            }
            else if (TouchListener_Pan_Test(control = explorerTreeView.TreeViewWnd, e, out clientPoint))
            {
                e.Handled = false;
            }
            else
            {
                control = null;
                e.Handled = false;
            }

            TouchListener_Pan_HoldedControl = e.End ? null : control;
            //MessageBox.Show($"{control}\n{OnMouseDownMethodInfo}\n{OnMouseMoveMethodInfo}\n{OnMouseUpMethodInfo}");
        }
        private bool TouchListener_Pan_Test(Control control, PanEventArgs e, out Point clientPoint)
        {
            clientPoint = control.PointToClient(e.Location);
            if (!control.Visible) return false;
            if (TouchListener_Pan_HoldedControl == null)
            {
                var rect = control.ClientRectangle;
                var sp = control as Splitter;
                if (sp != null)
                {
                    var dock = sp.Dock;
                    if (dock == DockStyle.Left || dock == DockStyle.Right)
                    {
                        rect.X -= rect.Width;
                        rect.Width *= 3;
                    }
                    else if (dock == DockStyle.Top || dock == DockStyle.Bottom)
                    {
                        rect.Y -= rect.Height;
                        rect.Height *= 3;
                    }
                }
                else
                {
                    var dgv = control as DataGridView;

                    if (dgv != null)
                    {
                        var totalWidth = 0;
                        foreach (DataGridViewColumn c in dgv.Columns)
                        {
                            if (c.Visible) totalWidth += c.Width;
                        }

                        if (totalWidth < rect.Width) rect.Width = totalWidth;
                    }
                }

                return e.Begin && rect.Contains(clientPoint);
            }
            else
            {
                return !e.Begin && TouchListener_Pan_HoldedControl == control;
            }
        }
        private int TouchListener_Pan_MouseGesture_StartClientPointY;
        private int TouchListener_Pan_MouseGesture_DataGridViewStartIndex = -1;
        private bool TouchListener_Pan_MouseGesture_GestureOrAfterGesture = false;
        private void TouchListener_Pan_MouseGesture(PanEventArgs e, MouseGesture mg, Point clientPoint)
        {
            e.Handled = true;
            if (e.Begin)
            {
                if (mg.Enabled)
                {
                    TouchListener_Pan_MouseGesture_StartClientPointY = e.Location.Y;
                    TouchListener_Pan_MouseGesture_DataGridViewStartIndex = -1;
                    TouchListener_Pan_MouseGesture_GestureOrAfterGesture = true;
                    mg.GestureBegin(clientPoint);
                }
            }
            else
            {
                if (!mg.Enabled)
                {
                    TouchListener_Pan_MouseGesture_GestureOrAfterGesture = false;
                }
                else if (!(e.End || e.Inertia))
                {
                    if (mg.GesturingOrbitCount > 1 || mg.InGesturing && Math.Abs(e.PanOffset.X) > Math.Abs(e.PanOffset.Y))
                    {
                        mg.GestureContinue(clientPoint);
                    }
                    else
                    {
                        mg.Clear();
                        TouchListener_Pan_MouseGesture_GestureOrAfterGesture = false;
                    }
                }
                else
                {
                    if (mg.GesturingOrbitCount > 1)
                    {
                        mg.GestureEnd(clientPoint, inNativeThread: true);
                    }
                    else if (mg.InGesturing)
                    {
                        mg.Clear();
                    }
                }
                if (!TouchListener_Pan_MouseGesture_GestureOrAfterGesture)
                {
                    if (mg.Owner is ScrollableControl scrollableControl)
                    {
                        var autoScrollPosition = scrollableControl.AutoScrollPosition;
                        var offset = e.PanOffset;
                        scrollableControl.AutoScrollPosition = new Point(-offset.X - autoScrollPosition.X, -offset.Y - autoScrollPosition.Y);
                    }
                    else
                    {
                        int count;
                        if (mg.Owner is DataGridView dataGridView && (count = dataGridView.RowCount) > 0)
                        {
                            var firstCell = dataGridView.FirstDisplayedCell;
                            if (firstCell != null)
                            {
                                int startIndex;
                                if (TouchListener_Pan_MouseGesture_DataGridViewStartIndex < 0)
                                {
                                    startIndex = firstCell.RowIndex;
                                    TouchListener_Pan_MouseGesture_DataGridViewStartIndex = startIndex;
                                }
                                else
                                {
                                    startIndex = TouchListener_Pan_MouseGesture_DataGridViewStartIndex;
                                }
                                var delta = e.Location.Y - TouchListener_Pan_MouseGesture_StartClientPointY;
                                var abs = Math.Abs(delta);
                                var den = Math.Max(1, firstCell.Size.Height);
                                var absDeltaIndex = (abs - den / 2) / den;
                                var newIndex = TouchListener_Pan_MouseGesture_DataGridViewStartIndex + (delta > 0 ? -absDeltaIndex : absDeltaIndex);
                                newIndex = Math.Max(0, Math.Min(count, newIndex));
                                if (firstCell.RowIndex != newIndex)
                                {
                                    dataGridView.FirstDisplayedCell = dataGridView.Rows[newIndex].Cells[firstCell.ColumnIndex];
                                }
                            }
                        }
                    }
                }
            }
        }

        // SetKeepOpen 実装２
        private static void SetKeepOpen(ToolStripMenuItem tsmi)
        {
            if (tsmi.HasDropDown)
            {
                tsmi.DropDown.Closing += SetKeepOpen_Closing;
                foreach (var item in tsmi.DropDownItems)
                {
                    var childTsmi = item as ToolStripMenuItem;
                    if (childTsmi != null)
                    {
                        SetKeepOpen(childTsmi);
                    }
                }
            }
        }

        private static void SetKeepOpen_Closing(object sender, ToolStripDropDownClosingEventArgs e)
        {
            if (e.CloseReason == ToolStripDropDownCloseReason.ItemClicked) e.Cancel = true;
        }

        // SetKeepOpen 実装１
        /*
        private static void SetKeepOpen(ToolStripMenuItem tsmi, params ToolStripMenuItem[] exceptions)
        {
            foreach (var item in tsmi.DropDownItems)
            {
                var childTsmi = item as ToolStripMenuItem;
                if (childTsmi != null && !exceptions.Contains(childTsmi))
                {
                    childTsmi.MouseEnter += SetKeepOpen_MouseEnter;
                    childTsmi.MouseLeave += SetKeepOpen_MouseLeave;
                    SetKeepOpen(childTsmi, exceptions);
                }
            }
        }

        private static void SetKeepOpen_MouseLeave(object sender, EventArgs e)
        {
            ((ToolStripDropDown)((ToolStripMenuItem)sender).Owner).AutoClose = true;
        }

        private static void SetKeepOpen_MouseEnter(object sender, EventArgs e)
        {
            ((ToolStripDropDown)((ToolStripMenuItem)sender).Owner).AutoClose = false;
        }
        */

        private static readonly Bitmap ExplorerIcon = getExplorerIcon();
        private static Bitmap getExplorerIcon()
        {
            return ExplorerProvider.Icon;
            /*
            try
            {
                return FileTypeManager.GetSmallIconBitmap(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Windows), "explorer.exe"), useFileAttrinutes: false);
            }
            catch
            {
                return null;
            }
            */
        }

        private void focusVisibleMainList()
        {
            if (tvCatalog.Visible) tvCatalog.Focus();
            else dgvFileList.Focus();
        }

        private void zabLocation_SubControlDragEnter(ZipPlaAddressBar sender, ZipPlaAddressBarDragEventArgs e)
        {
            var e2 = new DragEventArgs(e.Data, e.KeyState, e.X, e.Y, e.AllowedEffect, e.AllowedEffect);
            dropToMoveCopyControl_DragEnter(sender, e2);
            if (e2.Effect != DragDropEffects.None)
            {
                if (string.IsNullOrEmpty(e.Path))
                {
                    e.Effect = DragDropEffects.All;
                }
                else
                {
                    e.Effect = getDragEffect(e.Path, e.AllowedEffect, SameDirEffectMode.Link);
                }
            }
            else
            {
                e.Effect = DragDropEffects.None;
            }
        }

        private void zabLocation_SubControlDragDrop(ZipPlaAddressBar sender, ZipPlaAddressBarDragEventArgs e)
        {
            dropToMoveCopyControl_DragDrop(e, zabLocation_PathGetter, e.FinallyAction);
        }

        private static string zabLocation_PathGetter(DragEventArgs e)
        {
            return ((ZipPlaAddressBarDragEventArgs)e).Path;

        }


        private void zabLocation_TextChangedByBaseControl(object sender, EventArgs e)
        {
            if (!cbLocation.Focused) cbLocation.Focus();
        }

        private void zabLocation_ZipPlaAddressBarMakeButtonStarting(ZipPlaAddressBar sender, ZipPlaAddressBarMakeButtonStartingEventArgs e)
        {
            if (e.CommandSender == ZipPlaAddressBarCommandSender.Leave && !CreatingZipPathArray && currentLocation == preCurrentLocation && IsSupportedByCatalogFormAndExists(currentLocation)) e.Text = currentLocation;
        }

        private void zabLocation_DragDropFinished(object sender, MouseEventArgs e)
        {
            dragOuting = false;
        }

        private void zabLocation_DragDropStarting(object sender, MouseEventArgs e)
        {
            dragOuting = true;
        }

        private void zabLocation_CurrentLocationButtonClick(object sender, EventArgs e)
        {
            var newLocation = zabLocation.Text;
            if (newLocation != null && currentLocation?.ToLower() != newLocation.ToLower())
            {
                MakePreview();
            }
            else
            {
                UpdatePreview(stopResetFilter: false);
            }
        }

        private void setUndoButton(Button button, bool goBack)
        {
            if (goBack) button.Paint += ControlPainter.FillLeftArrowControlHandler;
            else button.Paint += ControlPainter.FillRightArrowControlHandler;
            button.Text = null;
            button.FlatStyle = FlatStyle.Flat;
            button.FlatAppearance.BorderColor = BackColor;
        }

        private bool zabLocation_DirectoryButtonContextMenuStripOpening_first = true;
        private string zabLocation_DirectoryButtonContextMenuStripOpening_Path = null;
        private ToolStripMenuItem zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode = null;
        private ToolStripSeparator zabLocation_DirectoryButtonContextMenuStripOpening_Separator = null;
        private ToolStripMenuItem zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder = null;
        private void zabLocation_DirectoryButtonContextMenuStripOpening(ZipPlaAddressBar sender, ZipPlaAddressBarDirectoryButtonContextMenuStripOpeningEventArgs e)
        {
            if (zabLocation_DirectoryButtonContextMenuStripOpening_first)
            {
                zabLocation_DirectoryButtonContextMenuStripOpening_first = false;

                e.ContextMenuStrip.Closed += ZipPlaAddressBarDirectoryButtonContextMenuStrip_Closed;
                var items = e.ContextMenuStrip.Items;
                items[0].Image = ExplorerIcon;// ExplorerProvider.Icon;
                items[1].Image = SelectionToClipBoardToolStripMenuItem.Icon;

                zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode = new ToolStripMenuItem(Message.SelectInFolderTree);
                zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode.Click += zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode_Click;
                try
                {
                    zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode.Image = FileTypeManager.GetSmallIconBitmap(
                        Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory),
                        useFileAttrinutes: false);
                }
                catch { }
                items.Add(zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode);

                items.Add(zabLocation_DirectoryButtonContextMenuStripOpening_Separator = new ToolStripSeparator());

                zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder = new ToolStripMenuItem(Message.EditSmartFolder + "...");
                zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder.Click += zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder_Click;
                items.Add(zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder);
            }
            else
            {
                zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder.Text = Message.EditSmartFolder + "...";
                zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode.Text = Message.SelectInFolderTree;
            }

            zabLocation_DirectoryButtonContextMenuStripOpening_Path = e.Path;

            zabLocation_DirectoryButtonContextMenuStripOpening_Separator.Visible =
            zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder.Visible = e.IsFile && SmartFolder.IsSmartFolderPath(e.Path);

            //zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode.Visible = e.IsDir || isNetworkRoot(e.Path);

            // ApplicationProvider の内容を追加する場合
            // ただしこのままでは ExplorerProvider が重複し、
            // また明らかに不適切な MoveItemsProvider やあまり使われないであろう BuiltInViewerProveder まで表示されるので
            // 有効にする場合 ExternalEpplicationProvider だけを表示するような変更を加えるのが望ましいと思われる
            /*
            var start = items.Count;
            if (start > 0)
            {
                items.Add(new ToolStripSeparator());
                start++;
            }
            if (InsertAppToCToolStrip(items, start, path) == 0)
            {
                var tsmi = new ToolStripMenuItem(Message.ApplicationIsNotSpecified);
                tsmi.Enabled = false;
                items.Insert(start++, tsmi);
            }
            */
            if (this != ActiveForm) Activate();
            AllowFullpower = false; // これは cms 自体のものなので必要
        }

        private static bool isNetworkRoot(string path)
        {
            return path != null && path.Length > 2 && path.StartsWith(@"\\") && path.IndexOf(Path.DirectorySeparatorChar, 2) < 0;
        }


        private void zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder_Click(object sender, EventArgs e)
        {
            if (zabLocation_DirectoryButtonContextMenuStripOpening_Path != null)
            {
                openSmartFolderSettingForm(zabLocation_DirectoryButtonContextMenuStripOpening_Path); // AllowFullpower = true; 込み
            }
            else
            {
                AllowFullpower = true;
            }
        }

        private void zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode_Click(object sender, EventArgs e)
        {
            if (zabLocation_DirectoryButtonContextMenuStripOpening_Path != null)
            {
                setToTree(zabLocation_DirectoryButtonContextMenuStripOpening_Path, CollapseOthersWhenSynchronizing);
                /*
                if(!folderTreeToolStripMenuItem.Checked)
                {
                    folderTreeToolStripMenuItem.Checked = true;
                    setFolderTreeVisible(silent: false);
                }

                explorerTreeView.TrySelect(zabLocation_DirectoryButtonContextMenuStripOpening_Path);
                */
            }
        }

        private void ZipPlaAddressBarDirectoryButtonContextMenuStrip_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            AllowFullpower = true;
        }

        private void mgFileList_MouseGestureStarting(MouseGesture sender, MouseGestureStartingEventArgs e)
        {
            var hit = dgvFileList.HitTest(e.X, e.Y);
            if (hit.Type == DataGridViewHitTestType.ColumnHeader)
            {
                e.Cancel = true;
            }
            else
            {
                if (e.Sender == MouseGestureSender.Mouse)
                {
                    if (AllowRightDragFromDetail)
                    {
                        if (hit.RowIndex >= 0)
                        {
                            var row = dgvFileList.Rows[hit.RowIndex];
                            if (row.Selected) e.Cancel = true;
                        }
                    }
                }
            }
        }

        private void MgCatalog_MouseGestureStarting(MouseGesture sender, MouseGestureStartingEventArgs e)
        {
            if (e.Sender == MouseGestureSender.Mouse)
            {
                if (AllowRightDragFromThumbnail)
                {
                    var index = tvCatalog.PointToIndex(e.Location);
                    if (index >= 0 && tvCatalog[index].Selected)
                    {
                        e.Cancel = true;
                    }
                }
            }
        }

        private void mgCatalog_EnabledChanged(object sender, EventArgs e)
        {
            if (mgCatalog.Enabled)
            {
                tvCatalog.SubMouseButtons &= ~MouseButtons.Right;
            }
            else
            {
                tvCatalog.SubMouseButtons |= MouseButtons.Right;
            }
        }

        /*
        private bool mouseGestureHandler(MouseGestureCompletedEventArgs e)
        {
            if(e.UserDirections.SequenceEqual(new MouseGestureDirection[] { MouseGestureDirection.Left }))
            {
                btnGoToBack.PerformClick();
                return true;
            }
            if (e.UserDirections.SequenceEqual(new MouseGestureDirection[] { MouseGestureDirection.Right }))
            {
                btnGoToForward.PerformClick();
                return true;
            }
            if (e.UserDirections.SequenceEqual(new MouseGestureDirection[] { MouseGestureDirection.Up }))
            {
                gotToParent();
                return true;
            }
            return false;
        }
        */

        private void mgFileList_MouseGestureCompleted(MouseGesture sender, MouseGestureCompletedEventArgs e)
        {
            if (e.Sender != MouseGestureSender.Mouse) return; // 仮想キーも離さない
            var mk = ModifierKeys;
            if (e.PerformedActionIndex < 0)
            {
                var hit = dgvFileList.HitTest(e.X, e.Y);
                if (hit.RowIndex >= 0)
                {
                    var rect = dgvFileList.GetRowDisplayRectangle(hit.RowIndex, cutOverflow: true);
                    if (!rect.IsEmpty && e.MouseOrbit.All(p => rect.Contains(p)))
                    {
                        if (hit.RowIndex >= 0)
                        {
                            var clickedRow = dgvFileList.Rows[hit.RowIndex];
                            if (!clickedRow.Selected)
                            {
                                var temp = selectionSynchronizing;
                                selectionSynchronizing = true;
                                foreach (DataGridViewRow row in dgvFileList.SelectedRows.Cast<DataGridViewRow>().ToArray())
                                {
                                    row.Selected = false;
                                }
                                selectionSynchronizing = temp;
                                clickedRow.Selected = true;
                                dgvFileList.CurrentCell = clickedRow.Cells[tbcFileName.Index];
                            }
                            //cmsRightClickPrepareAndShow(Cursor.Position);
                            rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                        }
                        if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                        {
                            tvCatalog.SelectedIndices = null;
                        }
                    }
                }
                else
                {
                    var cl = dgvFileList.ClientRectangle;
                    if (e.MouseOrbit.All(p =>
                    {
                        if (!cl.Contains(p)) return false;
                        var h = dgvFileList.HitTest(p.X, p.Y);
                        return h.ColumnIndex < 0 && h.Type == DataGridViewHitTestType.None;
                    }))
                    {
                        //cmsRightClickPrepareAndShow(Cursor.Position);
                        tvCatalog.SelectedIndex = -1;
                        rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                    }
                }
            }
        }

        private void MgCatalog_MouseGestureCompleted(MouseGesture sender, MouseGestureCompletedEventArgs e)
        {
            if (e.Sender != MouseGestureSender.Mouse) return; // 仮想キーも離さない
            var mk = ModifierKeys;
            if (e.PerformedActionIndex < 0)
            {
                var rect = tvCatalog.PointToIndex(e.MouseOrbit[0]) < 0 ? Rectangle.Empty :
                    tvCatalog.PointToContainerGridRectangle(e.MouseOrbit[0], cutOverflow: true);
                if (!rect.IsEmpty && e.MouseOrbit.All(p => rect.Contains(p)))
                {
                    var index = tvCatalog.PointToIndex(e.MouseOrbit[0]);
                    if (index >= 0)
                    {
                        if (!tvCatalog.SelectedIndices.Contains(index)) tvCatalog.SelectedIndex = index;
                        //cmsRightClickPrepareAndShow(Cursor.Position);
                        rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                    }
                }
                else
                {
                    //var showCount = tvCatalog.DataIndexToShowIndex.Length;
                    var cl = tvCatalog.ClientRectangle;
                    if (e.MouseOrbit.All(p => cl.Contains(p) && tvCatalog.PointToIndex(p) < 0))
                    {
                        //cmsRightClickPrepareAndShow(Cursor.Position);
                        tvCatalog.SelectedIndex = -1;
                        rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                    }
                }
            }
        }


        private void DgvSorter_UserSorted(object sender, EventArgs e)
        {
            saveBookmarkToIni_bookmarkChanged = true;
            saveBookmarkToConfig();
        }

        private void zabLocation_TextChangedByButton(object sender, ZipPlaAddressBarTextChangedByButtonEventArgs e)
        {
            var text = zabLocation.Text;
            if (text == null) return;
            if (e.DropDown)
            {
                MakePreview();
            }
            else
            {
                goUpFromCurrentLocation(text);
            }
        }

        private void DgvFileList_MouseWheel(object sender, MouseEventArgs e)
        {
            if (MouseButtons == MouseButtons.Left)
            {
                var oldIndex = dgvFileList.FirstDisplayedScrollingRowIndex;
                var newIndex = Math.Max(0, Math.Min(dgvFileList.Rows.Count - 1, oldIndex - e.Delta / 120 * SystemInformation.MouseWheelScrollLines));
                if (oldIndex != newIndex)
                {
                    dgvFileList.FirstDisplayedScrollingRowIndex = newIndex;
                    var temp = Cursor.Position;
                    Cursor.Position = new Point(temp.X + 1, temp.Y);
                    Cursor.Position = temp;
                }
            }
        }

        class CharSelectRefiner : NativeWindow
        {
            private TextBoxBase TextBoxBase;

            private int lastDoubleClickTime;
            private Point? lastDoubleClickPoint = null;

            public Func<int, string, Tuple<int, int>> DoubleClickSelectionTextRangeProvider = null;

            public CharSelectRefiner(TextBoxBase textBox)
            {
                if (textBox == null) throw new ArgumentNullException(nameof(textBox));
                TextBoxBase = textBox;
                textBox.HandleCreated += TextBox_HandleCreated;
                textBox.HandleDestroyed += TextBox_HandleDestroyed;
                if (textBox.IsHandleCreated) AssignHandle();
            }

            private void AssignHandle()
            {
                AssignHandle(TextBoxBase.Handle);
            }

            private void TextBox_HandleCreated(object sender, EventArgs e)
            {
                AssignHandle();
            }

            private void TextBox_HandleDestroyed(object sender, EventArgs e)
            {
                ReleaseHandle();
            }

            protected override void WndProc(ref System.Windows.Forms.Message m)
            {
                const int WM_LBUTTONDBLCLK = 0x0203;
                const int WM_LBUTTONDOWN = 0x0201;

                if (m.Msg == WM_LBUTTONDBLCLK)
                {
                    var lParam = (int)m.LParam;
                    var xPos = lParam & 0xFFFF;         // カーソルx座標
                    var yPos = (lParam >> 16) & 0xFFFF;  // カーソルy座標

                    lastDoubleClickTime = Environment.TickCount;
                    lastDoubleClickPoint = new Point(xPos, yPos);

                    var clickedIndex = TextBoxBase.GetCharIndexFromPosition(new Point(xPos, yPos));

                    var range = DoubleClickSelectionTextRangeProvider == null ?
                        GetDoubleClickSelectionTextRange(clickedIndex, TextBoxBase.Text) :
                        DoubleClickSelectionTextRangeProvider(clickedIndex, TextBoxBase.Text);

                    if (range != null)
                    {
                        if (range.Item1 != TextBoxBase.SelectionStart || range.Item2 != TextBoxBase.SelectionLength)
                        {
                            TextBoxBase.Select(range.Item1, range.Item2);
                        }
                        return;
                    }
                }
                else if (m.Msg == WM_LBUTTONDOWN)
                {
                    if (lastDoubleClickPoint is Point p)
                    {
                        lastDoubleClickPoint = null;

                        var lParam = (int)m.LParam;
                        var xPos = lParam & 0xFFFF;         // カーソルx座標
                        var yPos = (lParam >> 16) & 0xFFFF;  // カーソルy座標

                        var size = SystemInformation.DoubleClickSize;
                        var w = size.Width;
                        var h = size.Height;
                        var rect = new Rectangle(p.X - w / 2, p.Y - h / 2, w | 1, h | 1);
                        var tes = new Rectangle(0, 0, 4, 4).Contains(4, 4);
                        if (rect.Contains(xPos, yPos))
                        {
                            var delta = Environment.TickCount - lastDoubleClickTime; // オーバーフローで剰余算を実現
                            if (0 <= delta && delta <= SystemInformation.DoubleClickTime)
                            {
                                TextBoxBase.SelectAll();
                                return;
                            }
                        }
                    }
                }

                base.WndProc(ref m);
            }

            private static Tuple<int, int> GetDoubleClickSelectionTextRange(int clickedIndex, string text)
            {
                if (text == null) return null;

                if (clickedIndex < 0) return null;

                var len = text.Length;

                if (clickedIndex > len) return null;

                if (clickedIndex == len) return Tuple.Create(clickedIndex, 0);

                var c = text[clickedIndex];

                var bracketedLength = GetBracketedLength(text, clickedIndex, reverse: false);
                if (bracketedLength > 0)
                {
                    return Tuple.Create(clickedIndex + 1, Math.Min(len - clickedIndex, bracketedLength - 2));
                }
                bracketedLength = GetBracketedLength(text, clickedIndex, reverse: true);
                if (bracketedLength > 0)
                {
                    var start = Math.Max(0, clickedIndex - (bracketedLength - 2));
                    return Tuple.Create(start, clickedIndex - start);
                }


                Tuple<int, int> result = null; ;

                bool test(Func<char, bool> tester)
                {
                    if (tester(c))
                    {
                        int start = clickedIndex, stop = clickedIndex + 1;
                        while (start > 0 && tester(text[start - 1])) start--;
                        while (stop < len && tester(text[stop])) stop++;
                        result = Tuple.Create(start, stop - start);
                        return true;
                    }
                    return false;
                }

                if (test(cc => char.IsLetterOrDigit(cc) || char.IsSymbol(cc))) return result;

                //bool isAsciiLetterOrDigit(char cc) => 'a' <= cc && cc <= 'z' || 'a' <= cc && cc <= 'z' || 'A' <= cc && cc <= 'Z';
                //if (test(isAsciiLetterOrDigit)) return result;
                //bool isNoneAsciiLetterOrDigit(char cc) => char.IsLetterOrDigit(cc) && !('a' <= cc && cc <= 'z' || 'A' <= cc && cc <= 'Z');
                //if (test(isNoneAsciiLetterOrDigit)) return result;

                return Tuple.Create(clickedIndex, 0);
            }

            private static int GetBracketedLength(string text, int start, bool reverse)
            {
                if (start < 0 || text == null) return 0;
                var len = text.Length;
                if (start >= len) return 0;
                var delta = reverse ? -1 : 1;
                var stop = reverse ? -1 : len;
                char partner;
                if (reverse ? TryGetOpenBracket(text[start], out partner) : TryGetCloseBracket(text[start], out partner))
                {
                    for (var i = start + delta; i != stop; i += delta)
                    {
                        var c = text[i];
                        if (c == partner)
                        {
                            return (reverse ? start - i : i - start) + 1;
                        }
                        else
                        {
                            var subResult = GetBracketedLength(text, i, reverse);
                            if (subResult == int.MaxValue) return int.MaxValue;
                            if (subResult > 0) i += reverse ? 1 - subResult : subResult - 1;
                        }
                    }
                    return int.MaxValue;
                }
                else return 0;
            }

            private static readonly char[] brackets =
                (
                // http://xahlee.info/comp/unicode_matching_brackets.html
                "()[]{}“”‘’‹›«»（）［］｛｝｟｠⦅⦆〚〛⦃⦄「」〈〉《》【】〔〕⦗⦘『』〖〗〘〙｢｣⟦⟧⟨⟩⟪⟫⟮⟯⟬⟭⌈⌉⌊⌋⦇⦈⦉⦊❛❜❝❞❨❩❪❫❴❵❬❭❮❯❰❱❲❳﴾﴿〈〉⦑⦒⧼⧽﹙﹚﹛﹜﹝﹞⁽⁾₍₎⦋⦌⦍⦎⦏⦐⁅⁆⸢⸣⸤⸥⟅⟆⦓⦔⦕⦖⸦⸧⸨⸩⧘⧙⧚⧛⸜⸝⸌⸍⸂⸃⸄⸅⸉⸊᚛᚜༺༻༼༽" +
                // その他
                "" //"≪≫＜＞" これらは不等号
                ).ToCharArray();
            private static bool TryGetCloseBracket(char open, out char close)
            {
#if DEBUG
                if (brackets.Length % 2 != 0) throw new Exception($"{nameof(brackets)} has odd length.");
#endif
                for (var i = 0; i < brackets.Length; i += 2)
                {
                    if (open == brackets[i])
                    {
                        close = brackets[i + 1];
                        return true;
                    }
                }
                close = default(char);
                return false;
            }
            private static bool TryGetOpenBracket(char close, out char open)
            {
#if DEBUG
                if (brackets.Length % 2 != 0) throw new Exception($"{nameof(brackets)} has odd length.");
#endif
                for (var i = 1; i < brackets.Length; i += 2)
                {
                    if (close == brackets[i])
                    {
                        open = brackets[i - 1];
                        return true;
                    }
                }
                open = default(char);
                return false;
            }
        }


        MessageForwarder msDirectoryList, msCatalog, msFileList, msSortBy, msFilter;

        ActivateManager activateManager;
        ToolStripSpringTextBox selectedFileNameToolStripTextBox = new ToolStripSpringTextBox();
        ToolStripTextBox rightClickFileNameToolStripTextBox = new ToolStripTextBox();
        SimplifiedKeyBoard simplifiedKeyBoard;
        private bool IsLoaded = false;
        private void CatalogForm_Load(object sender, EventArgs e)
        {
#if RUNTIME
            Program.RunTimeMeasure?.Block("LoadEventHandlerStarted");
#endif
            //itemsCountToolStripStatusLabel.Width = Program.DpiScalingX(90);
            //fileSizeToolStripStatusLabel.Width = Program.DpiScalingX(70);
            //selectedFileContainsCountToolStripStatusLabel.Width = Program.DpiScalingX(90);

            selectedFileNameToolStripTextBox.ReadOnly = true;
            if (MenuTextFont != null)
            {
                selectedFileNameToolStripTextBox.Font = MenuTextFont;
            }
            statusStrip.Items.Insert(1, selectedFileNameToolStripTextBox);
            selectedFileNameToolStripTextBox.MouseEnter += SelectedFileNameToolStripTextBox_MouseEnter;
            selectedFileNameToolStripTextBox.MouseLeave += SelectedFileNameToolStripTextBox_MouseLeave;
            selectedFileNameToolStripTextBox.TextChanged += SelectedFileNameToolStripTextBox_TextChanged;
            //selectedFileNameToolStripTextBox.KeyDown += SelectedFileNameToolStripTextBox_KeyDown;
            //selectedFileNameToolStripTextBox.GotFocus += SelectedFileNameToolStripTextBox_GotFocus;
            //selectedFileNameToolStripTextBox.LostFocus += SelectedFileNameToolStripTextBox_LostFocus;

#if RUNTIME
            Program.RunTimeMeasure?.Block("PrepareMessageForwarder");
#endif

            msDirectoryList = new MessageForwarder(dgvDirectoryList, ForwardedMessage.MouseWheel);
            new MessageForwarder(explorerTreeView.TreeViewWnd, ForwardedMessage.MouseWheel);
            msCatalog = new MessageForwarder(tvCatalog, ForwardedMessage.MouseWheel);
            msFileList = new MessageForwarder(dgvFileList, ForwardedMessage.MouseWheel);
            new MessageForwarder(cbLocation, ForwardedMessage.MouseWheel);
            msSortBy = new MessageForwarder(cbSortBy, ForwardedMessage.MouseWheel);
            msFilter = new MessageForwarder(cbFilter, ForwardedMessage.MouseWheel);

#if RUNTIME
            Program.RunTimeMeasure?.Block("PrepareSimplifiedKeyBoard");
#endif

            simplifiedKeyBoard = new SimplifiedKeyBoard(statusStrip, -1);
            simplifiedKeyBoard.Add("Ctrl", Keys.ControlKey);
            simplifiedKeyBoard.Add("Shift", Keys.ShiftKey);
            simplifiedKeyBoard.Add("Apps", cmsRightClickPrepareAndShowForKey);
            simplifiedKeyBoard.Add(Message.Tag, cmsRightClickOnlyTagPrepareAndShowForKey);
            simplifiedKeyBoard.Add("Del", Keys.Delete);
            tvCatalog.GetModifierKeys = simplifiedKeyBoard.GetModifierKeysWithoutUpHeldKeys;
#if RUNTIME
            Program.RunTimeMeasure?.Block("PrepareSimplifiedKeyBoard1");
#endif
            setTinyOnScreenKeyboardVisible(tinyOnScreenKeyboardVisible);
#if RUNTIME
            Program.RunTimeMeasure?.Block("PrepareSimplifiedKeyBoard");
#endif

            dgvFileList.SimplifiedKeyBoard = simplifiedKeyBoard;
            dgvDirectoryList.SimplifiedKeyBoard = simplifiedKeyBoard;

#if RUNTIME
            Program.RunTimeMeasure?.Block("SetRightClickFileNameEvents");
#endif

            rightClickFileNameToolStripTextBox.ReadOnly = true;
            cmsRightClick.Items.Insert(0, rightClickFileNameToolStripTextBox);
            //rightClickFileNameToolStripTextBox.SelectedTextChanged += rightClickFileNameToolStripTextBox_SelectedTextChanged;
            rightClickFileNameToolStripTextBox.MouseMove += RightClickFileNameToolStripTextBox_MouseMove;
            rightClickFileNameToolStripTextBox.MouseEnter += RightClickFileNameToolStripTextBox_MouseEnter;
            rightClickFileNameToolStripTextBox.MouseLeave += RightClickFileNameToolStripTextBox_MouseLeave;
            //rightClickFileNameToolStripTextBox.MouseDown += RightClickFileNameToolStripTextBox_MouseDown;
            new CharSelectRefiner(rightClickFileNameToolStripTextBox.TextBox);
            rightClickFileNameToolStripTextBox.KeyDown += RightClickFileNameToolStripTextBox_KeyDown;
            rightClickFileNameToolStripTextBox.KeyUp += RightClickFileNameToolStripTextBox_KeyUp;
            rightClickFileNameToolStripTextBox.TextChanged += RightClickFileNameToolStripTextBox_TextChanged;
            rightClickFileNameToolStripTextBox.GotFocus += rightClickFileNameToolStripTextBox_GotFocus;
            rightClickFileNameToolStripTextBox.LostFocus += rightClickFileNameToolStripTextBox_LostFocus;

#if RUNTIME
            Program.RunTimeMeasure?.Block("SquarizeToolStripInClass");
#endif

            ToolStripOverwriter.SquarizeToolStripInClass(this);

            CursorIsOnControllField = mouseOnWindow = Bounds.Contains(Cursor.Position);

#if RUNTIME
            Program.RunTimeMeasure?.Block("PrepareActivateManager");
#endif
            activateManager = new ActivateManager(this, tvCatalog, dgvFileList);

#if DEBUG
            //setColors();
#endif
            //setControlEvent(this);
#if RUNTIME
            Program.RunTimeMeasure?.Block("AfterLoad");
#endif
            IsLoaded = true;
        }

        private void rightClickFileNameToolStripTextBox_GotFocus(object sender, EventArgs e)
        {
            setRightClickMenuShortcutKeys(false);
        }
        private void rightClickFileNameToolStripTextBox_LostFocus(object sender, EventArgs e)
        {
            setRightClickMenuShortcutKeys(true);
        }

        private void setRightClickMenuShortcutKeys(bool enabled)
        {
            switch (enabled)
            {
                case true:
                    deleteonlyForListFileToolStripMenuItem.ShortcutKeys = Keys.Delete;
                    cutToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.X;
                    copyToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.C;
                    pasteToolStripMenuItem.ShortcutKeys = Keys.Control | Keys.V;
                    break;
                case false:
                    /*
                    if (rightClickFileNameToolStripTextBox.ReadOnly)
                    {
                        setRightClickMenuShortcutKeys(true);
                    }
                    else
                    */
                    {
                        deleteonlyForListFileToolStripMenuItem.ShortcutKeys = Keys.None;
                        cutToolStripMenuItem.ShortcutKeys = Keys.None;
                        copyToolStripMenuItem.ShortcutKeys = Keys.None;
                        pasteToolStripMenuItem.ShortcutKeys = Keys.None;
                    }
                    break;
            }
        }

        private void cmsRightClickPrepareAndShowForKey()
        {
            cmsRightClickPrepareAndShowForKey(ModifierKeys);
        }

        private void cmsRightClickPrepareAndShowForKey(Keys modifierKeys)
        {
            cmsRightClickPrepareAndShowForKey(onlyTag: false, modifierKeys: modifierKeys);
        }

        private void cmsRightClickOnlyTagPrepareAndShowForKey()
        {
            cmsRightClickOnlyTagPrepareAndShowForKey(ModifierKeys);
        }

        private void cmsRightClickOnlyTagPrepareAndShowForKey(Keys modifierKeys)
        {
            cmsRightClickPrepareAndShowForKey(onlyTag: true, modifierKeys: modifierKeys);
        }

        private void cmsRightClickPrepareAndShowForKey(bool onlyTag, Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == tvCatalog)
            {
                cmsRightClickPrepareAndShowForKeyOnTvCatalog(onlyTag, modifierKeys);
            }
            else if (lcc == dgvFileList)
            {
                cmsRightClickPrepareAndShowForKeyOnFileList(onlyTag, modifierKeys);
            }
            else if (!onlyTag)
            {
                if (lcc == dgvDirectoryList)
                {
                    dgvDirectoryList_KeyDown(dgvDirectoryList, new KeyEventArgs(Keys.Apps));
                }
                else if (lcc == explorerTreeView.TreeViewWnd)
                {
                    cmsRightClickPrepareAndShowForKeyOnTreeView();
                }
            }

            /*
            var ac = ActiveControl;
            if (ac == tvCatalog)
            {
                cmsRightClickPrepareAndShowForKeyOnTvCatalog(onlyTag);
            }
            else if (ac == dgvFileList)
            {
                cmsRightClickPrepareAndShowForKeyOnFileList(onlyTag);
            }
            */
        }

        private void cmsRightClickPrepareAndShowForKeyOnTreeView()
        {
            var targetNode = explorerTreeView.SelectedNode;
            if (targetNode != null)
            {

                if (cmsRightClick.Visible)
                {
                    cmsRightClick.Close();
                }

                AllowFullpower = false;
                try
                {
                    var item = (ShellItem)targetNode.Tag;
                    var path = item.Path;
                    var bound = targetNode.Bounds;
                    var halfHeight = bound.Height / 2;
                    var point = new Point(bound.X + halfHeight, bound.Y + halfHeight);
                    explorerContextMenu.ShowContextMenu(new FileInfo[] { new FileInfo(path) }, explorerTreeView.PointToScreen(point));
                }
                catch { }
                finally
                {
                    AllowFullpower = true;
                }
            }
        }

        bool RightClickFileNameToolStripTextBox_TextChanged_SetDefaultValues;
        bool RightClickFileNameToolStripTextBox_TextChanged_DefaultRatingEnabled;
        bool RightClickFileNameToolStripTextBox_TextChanged_DefaultTagEnabled;
        bool RightClickFileNameToolStripTextBox_TextChanged_DefaultPageEnabled;
        bool RightClickFileNameToolStripTextBox_TextChanged_DefaultThumbEnabled;
        private bool RightClickFileNameToolStripTextBox_TextChanged_CheckFileNameChar = true;
        private void RightClickFileNameToolStripTextBox_TextChanged(object sender, EventArgs e)
        {
            var text = rightClickFileNameToolStripTextBox.Text;
            if (RightClickFileNameToolStripTextBox_TextChanged_CheckFileNameChar)
            {
                var start = rightClickFileNameToolStripTextBox.SelectionStart;
                var length = rightClickFileNameToolStripTextBox.SelectionLength;
                var sb = new StringBuilder(text.Length);
                var ifnc = Path.GetInvalidFileNameChars();
                var index = 0;
                foreach (var c in text)
                {
                    if (ifnc.Contains(c))
                    {
                        if (index < start)
                        {
                            start--;
                        }
                        else if (index < start + length)
                        {
                            length--;
                        }
                    }
                    else
                    {
                        sb.Append(c);
                        index++;
                    }
                }
                var text2 = sb.ToString();
                if (text != text2)
                {
                    text = text2;
                    rightClickFileNameToolStripTextBox.Text = text2;
                    rightClickFileNameToolStripTextBox.Select(start, length);
                }
            }

            if (!RightClickFileNameToolStripTextBox_TextChanged_SetDefaultValues)
            {
                RightClickFileNameToolStripTextBox_TextChanged_DefaultRatingEnabled = ratingToolStripMenuItem.Enabled;
                RightClickFileNameToolStripTextBox_TextChanged_DefaultTagEnabled = tagToolStripMenuItem.Enabled;
                RightClickFileNameToolStripTextBox_TextChanged_DefaultPageEnabled = pageSequenceToolStripMenuItem.Enabled;
                RightClickFileNameToolStripTextBox_TextChanged_DefaultThumbEnabled = thumbnailToolStripMenuItem.Enabled;
                RightClickFileNameToolStripTextBox_TextChanged_SetDefaultValues = true;
            }

            var changed = cmsRightClickPrepareAndShow_InitialTextBoxText != text;
            if (changed)
            {
                ratingToolStripMenuItem.DropDown.Close();
                tagToolStripMenuItem.DropDown.Close();
                pageSequenceToolStripMenuItem.DropDown.Close();
                thumbnailToolStripMenuItem.DropDown.Close();

                ratingToolStripMenuItem.Enabled = false;
                tagToolStripMenuItem.Enabled = false;
                pageSequenceToolStripMenuItem.Enabled = false;
                thumbnailToolStripMenuItem.Enabled = false;
                SetAppInContextMenuEnabled(false);
            }
            else
            {
                ratingToolStripMenuItem.Enabled = RightClickFileNameToolStripTextBox_TextChanged_DefaultRatingEnabled;
                tagToolStripMenuItem.Enabled = RightClickFileNameToolStripTextBox_TextChanged_DefaultTagEnabled;
                pageSequenceToolStripMenuItem.Enabled = RightClickFileNameToolStripTextBox_TextChanged_DefaultPageEnabled;
                thumbnailToolStripMenuItem.Enabled = RightClickFileNameToolStripTextBox_TextChanged_DefaultThumbEnabled;
                SetAppInContextMenuEnabled(true);
            }

        }

        /*
        private void setControlEvent(Control control)
        {
            control.MouseEnter += Control_MouseEnter;
            control.MouseLeave += Control_MouseLeave;
            foreach (Control child in control.Controls)
            {
                setControlEvent(child);
            }
        }

        private bool mouseIsOnWindow;
        private void Control_MouseEnter(object sender, EventArgs e)
        {
            if (!mouseIsOnWindow)
            {
                mouseIsOnWindow = true;
                globalMouseEnter(Cursor.Position);
            }
        }
        private void Control_MouseLeave(object sender, EventArgs e)
        {
            if (mouseIsOnWindow)
            {
                var p = Cursor.Position;
                var bounds = ClientRectangle;
                if(!bounds.Contains(PointToClient(p)))
                {
                    mouseIsOnWindow = false;
                    globalMouseLeave(p);
                }
            }
        }
        */

        private void SelectedFileNameToolStripTextBox_TextChanged(object sender, EventArgs e)
        {
            Program.TextBoxShowRight(selectedFileNameToolStripTextBox);
        }

        public void SetMessages()
        {
            SetMessagesWithoutTagFilter();

            // メニュの幅に依存して動作が決まるので必ず SetMessagesWithoutTagFilter よりも後で
            setTagFilteringMenuItems(needToRepairTagsFromBookmark: false, needToSaveCurrentTag: false);

            // コンストラクタからは呼ばれないようにここに書く
            if (showStartHelpMessage)
            {
                tvCatalog.Invalidate();
            }
        }

        private Control[] SetMessages_LayoutControls;
        public void SetMessagesWithoutTagFilter()
        {

#if RUNTIME
            Program.RunTimeMeasure?.Block("SetMessagesWithoutTagFilter_Start");
#endif
            startToolStripMenuItem.Text = Message._Start;
#if RUNTIME
            Program.RunTimeMeasure?.Block("AfterMessageClassCreated");
#endif
            if (SetMessages_LayoutControls == null)
            {
                SetMessages_LayoutControls = new Control[]
                {
                    menuStrip,
                    startToolStripMenuItem.DropDown,
                    viewToolStripMenuItem.DropDown,
                    layoutToolStripMenuItem.DropDown,
                    howToDoubleClickToolStripMenuItem.DropDown,
                    contextMenuSelectToolStripMenuItem.DropDown,
                    arrangeFoldersToolStripMenuItem.DropDown,
                    itemSelectionFeedbackToolStripMenuItem.DropDown,
                    folderTreeSettingsToolStripMenuItem.DropDown,
                    archivesInArchiveToolStripMenuItem.DropDown,
                    defaultPageSequenceToolStripMenuItem.DropDown,
                    backgroundColorOfBuiltinViewerToolStripMenuItem.DropDown,
                    maxCaptchaCountInAVideoToolStripMenuItem.DropDown,
                    thumbnailSizeToolStripMenuItem.DropDown,
                    theNumberOfLinesOfNameToolStripMenuItem.DropDown,
                    minimumFrameThicknessToolStripMenuItem.DropDown,
                    aligningToolStripMenuItem.DropDown,
                    mouseWheelScrollAmountToolStripMenuItem.DropDown,
                    optionToolStripMenuItem.DropDown,
                    addToolStripMenuItem.DropDown,
                    cmsFileListHeader,
                    cmsRightClick,
                    cmsLocationCommands,
                    cmsFilterCommands,
                    cmsRightClickOnBackground,
                    cmsDirectoryList,
                    cmsRightClickDrop,
                    cmsDirectoryListRightClickDrop,
                };
            }

            foreach (var control in SetMessages_LayoutControls) control.SuspendLayout();

            openHistoryToolStripMenuItem.Text = Message.OpenHistory;
            //openListFileToolStripMenuItem.Text = Message.OpenVirtualFolder + "...";
            openDirectoryToolStripMenuItem.Text = Message.OpenFolder + "...";
            openFileToolStripMenuItem.Text = Message.OpenFile + "...";
            openbuiltinBookReaderToolStripMenuItem.Text = Message.OpenBuiltInViewer;
            newVirtualFolderToolStripMenuItem.Text = Message.NewVirtualFolder + "...";
            newSmartFolderToolStripMenuItem.Text = Message.NewSmartFolder + "...";
            reloadAllItemsToolStripMenuItem.Text = Message.Reload;
            newFolderToolStripMenuItem.Text = Message.NewFolder;
            editLocationToolStripMenuItem.Text = Message.EditAddressBar;
            editFilterToolStripMenuItem.Text = Message.EditFilter;
            exitToolStripMenuItem.Text = Message.Exit;
            viewToolStripMenuItem.Text = Message._Behavior;// Message._View;
            bookmarkToolStripMenuItem.Text = Message.Bookmark;
            folderTreeToolStripMenuItem.Text = Message.FolderTree;
            thumbnailListToolStripMenuItem.Text = Message.Thumbnails;
            fileListToolStripMenuItem.Text = Message.Details;
            layoutToolStripMenuItem.Text = Message.Layout;
            verticalToolStripMenuItem.Text = Message.VerticalLayout;
            alternativeVerticalToolStripMenuItem.Text = Message.AlternativeVerticalLayout;
            horizontalToolStripMenuItem.Text = Message.HorizontalLayout;
            alternativeHorizontalToolStripMenuItem.Text = Message.AlternativeHorizontalLayout;
            tinyOnscreenKeyboardToolStripMenuItem.Text = Message.TinyOnScreenKeyboard;
            hilightSelectedItemsWhenMouseLeavaesToolStripMenuItem.Text = Message.HighlightSelectionWhenMouseLeaves;
            loadLastViewedPageFromHistoryToolStripMenuItem.Text = Message.LoadLastPageViewed;
            clearFilterWhenMovingLocationToolStripMenuItem.Text = Message.ClearFilterWhenMovingLocation;
            howToDoubleClickToolStripMenuItem.Text = Message.HowToOpenFile;
            standardToolStripMenuItem.Text = Message.ClickSamePointTwiceQuickly;
            ignoreMouseMovementToolStripMenuItem.Text = Message.ClickSameItemTwiceQuickly;
            selectAndClickItemToolStripMenuItem.Text = Message.ClickSelectedItem;

            contextMenuSelectToolStripMenuItem.Text = Message.ContextMenu;
            contextMenuStandardToolStripMenuItem.Text = Message.Standard;
            contextMenuOnlyTagsToolStripMenuItem.Text = Message.OnlyTags;
            contextMenuExplorerToolStripMenuItem.Text = Message.Explorer;

            standardRightclickToolStripMenuItem.Text = Message.RightClickPressAndTap;// Message.RightClick;
            standardMiddleclickToolStripMenuItem.Text = Message.MiddleClickTwoFingerTap;
            standardCtrlRightclickToolStripMenuItem.Text = "Ctrl+" + Message.RightClick;
            OnlyTagRightclickToolStripMenuItem.Text = Message.RightClickPressAndTap;// Message.RightClick;
            OnlyTagMiddleclickToolStripMenuItem.Text = Message.MiddleClickTwoFingerTap;
            onlyTagCtrlRightclickToolStripMenuItem.Text = "Ctrl+" + Message.RightClick;
            explorerRightclickToolStripMenuItem.Text = Message.RightClickPressAndTap;// Message.RightClick;
            explorerMiddleclickToolStripMenuItem.Text = Message.MiddleClickTwoFingerTap;
            explorerCtrlRightclickToolStripMenuItem.Text = "Ctrl+" + Message.RightClick;

            arrangeFoldersToolStripMenuItem.Text = Message.FolderViewSettings;
            noneFolderArrangeToolStripMenuItem.Text = Message.DisplayMixingWithFiles;
            displayFirstToolStripMenuItem.Text = Message.DisplayFirst;
            displayLastToolStripMenuItem.Text = Message.DisplayLast;
            fitToDirectionOfSortToolStripMenuItem.Text = Message.DisplayRespectingToSortOfDirection;
            //getFolderSizeToolStripMenuItem.Text = Message.ShowFolderSizeOnStatusBar;


            itemSelectionFeedbackToolStripMenuItem.Text = Message.AutomaticSelectionSwitching;// Message.ItemSelectionFeedback;
            noneItemSelectionFeedbackToolStripMenuItem.Text = Message.None;
            inAppropriateCasesToolStripMenuItem.Text = Message.InAppropriateCases;
            alwaysItemSelectionFeedbackToolStripMenuItem.Text = Message.Always;

            folderTreeSettingsToolStripMenuItem.Text = Message.FolderTreeSynchronizing;
            noneFolderTreeSynchronizingToolStripMenuItem.Text = Message.None;
            folderTreeToAddressbarToolStripMenuItem.Text = Message.FolderTreeToAddresBar;
            addressBarToFolderTreeToolStripMenuItem.Text = Message.AddresBarToFolderTree;
            twowayToolStripMenuItem.Text = Message.TwoWay;
            collapseOthersWhenSynchronizingToolStripMenuItem.Text = Message.CollapseOthersWhenSynchronizing;

            backgroundColorOfBuiltinViewerToolStripMenuItem.Text = Message.BuiltInViewerSettings;
            forceFirstPageToBeSingleToolStripMenuItem.Text = Message.ForceFirstPageToBeSingle;
            startInPreviousImageFilterSettingToolStripMenuItem.Text = Message.OpenInPreviousRotationToneCurveSetting;
            alwaysAutomaticallyHideUIToolStripMenuItem.Text = Message.AlwaysAutomaticallyHideUI;
            sortFilesWithTheSameOrderAsThumbnailWindowToolStripMenuItem.Text = Message.SortFilesWithSameOrderAsThumbnailWindow;
            allowReadaheadProcessToolStripMenuItem.Text = Message.AllowReadAheadProcess;
            loadWholeArchiveIntoMemoryToolStripMenuItem.Text = Message.LoadWholeArchiveIntoMemory;
            exceptReadAheadProcessToolStripMenuItem.Text = "    " + Message.ExceptReadAheadProcess;
            blackToolStripMenuItem.Text = Message.BlackBackground;
            grayToolStripMenuItem.Text = Message.GrayBackground;
            whiteToolStripMenuItem.Text = Message.WhiteBackground;
            selectColorToolStripMenuItem.Text = Message.SelectBackgroundColor + "...";
            createViewerShortcutFromCurrentSettingsToolStripMenuItem.Text = Message.CreateShortcutFromCurrentSettings + "...";
            maxCaptchaCountInAVideoToolStripMenuItem.Text = Message.MaxCountCaptchaInAVideo;
            fitOnTheScreenToolStripMenuItem.Text = Message.FitOnScreen;
            everySecondsToolStripMenuItem.Text = Message.EverySecond;
            //thumbnailListToolStripMenuItem.Text = Message.ThumbnailList;
            //fileListToolStripMenuItem.Text = Message.FileList;
            //pageInFileListToolStripMenuItem.Text = Message.PageInFileList;
            //ratingInFileListToolStripMenuItem.Text = Message.RatingInFileList;
            //accessTimeInFileListToolStripMenuItem.Text = Message.DateAccessedInFileList;
            //writeTimeInFileListToolStripMenuItem.Text = Message.DateModifiedInFileList;
            thumbnailSizeToolStripMenuItem.Text = Message._Thumbnail;
            archivesInArchiveToolStripMenuItem.Text = Message.LoadArchivesInArchive;
            ignoreArchivesInArchiveToolStripMenuItem.Text = Message.NoneRecommended;
            //onlyIfThereIsNoOtherImageToolStripMenuItem.Text = Message.OnlyIfThereIsNoOtherImage;
            untilFoundToolStripMenuItem.Text = Message.TwoLevelUntilFound;
            alwaysLoadArchivesInArchiveToolStripMenuItem.Text = Message.OneLevelCompletelyNotRecommended;// Message.Always;
            defaultPageSequenceToolStripMenuItem.Text = Message.DefaultPageSequence;
            defaultLeftToRightToolStripMenuItem.Text = Message.LeftToRight;
            defaultRightToLeftToolStripMenuItem1.Text = Message.RightToLeft;
            defaultSinglePageToolStripMenuItem.Text = Message.SinglePage;
            singlePageWithoutScalingUpToolStripMenuItem.Text = Message.SinglePageWithoutScalingUp;
            startInPreviousFullscreenModeToolStripMenuItem.Text = Message.OpenInPreviousFullscreenMode;
            alwaysStartInWindowModeToolStripMenuItem.Text = Message.OpenInWindow;
            openInFullscreenToolStripMenuItem.Text = Message.OpenInFullscreen;
            archivesFilesPDFFielsToolStripMenuItem.Text = Message.ArchiveFilesPdfFiles;
            imageFilesToolStripMenuItem.Text = Message.ImageFiles;
            videoFilesToolStripMenuItem.Text = Message.VideoFiles;
            otherFilesToolStripMenuItem.Text = Message.OtherFiles;
            foldersToolStripMenuItem.Text = Message.Folders;
            //ignoreFoldersToolStripMenuItem.Text = Message.IgnoreFolders;
            searchSubfoldersAsWellToolStripMenuItem.Text = Message.SearchSubfoldersAsWell;
            //reloadAllThumbnailsToolStripMenuItem.Text = Message.ReloadAllThumbnails;
            tinyToolStripMenuItem.Text = Message.Tiny;
            smallToolStripMenuItem.Text = Message.Small;
            normalToolStripMenuItem.Text = Message.Normal;
            largeToolStripMenuItem.Text = Message.Large;
            hugeToolStripMenuItem.Text = Message.Huge;
            allRatiosToolStripMenuItem.Text = Message.AllRatios;
            showIconToolStripMenuItem.Text = Message.ShowIcon;
            showRatingToolStripMenuItem.Text = Message.ShowRating;
            showTagsToolStripMenuItem.Text = Message.ShowTags;
            showFilenameToolStripMenuItem.Text = Message.ShowName;
            theNumberOfLinesOfNameToolStripMenuItem.Text = Message.NumberOfLinesOfName;
            fromTheLongestNameToolStripMenuItem.Text = Message.Full;
            automaticlessToolStripMenuItem.Text = Message.AutomaticLess;
            automaticgreaterToolStripMenuItem.Text = Message.AutomaticGreater;
            NumOfLineOfName1toolStripMenuItem.Text = Message.OneLine;
            NumOfLineOfName2toolStripMenuItem.Text = Message._1Lines.Replace("$1", "2");
            NumOfLineOfName3toolStripMenuItem.Text = Message._1Lines.Replace("$1", "3");
            minimumFrameThicknessToolStripMenuItem.Text = Message.MinimumFrameThickness;
            veryThinToolStripMenuItem.Text = Message.VeryThin;
            thinToolStripMenuItem.Text = Message.Thin;
            normalThicknessToolStripMenuItem.Text = Message.NormalThickness;
            thickToolStripMenuItem.Text = Message.Thick;
            veryThickToolStripMenuItem.Text = Message.VeryThick;
            aligningToolStripMenuItem.Text = Message.Aligning;
            totallyUniformedToolStripMenuItem.Text = Message.TotallyUniformed;
            horizontallyUniformedToolStripMenuItem.Text = Message.HorizontallyUniformed;
            alignedLeftToolStripMenuItem.Text = Message.AlignedLeft;
            alignedOnCenterToolStripMenuItem.Text = Message.AlignedOnCenter;
            mouseWheelScrollAmountToolStripMenuItem.Text = Message.MouseWheelScrollAmount;
            tinyScrollToolStripMenuItem.Text = Message.Tiny;
            smallScrollToolStripMenuItem.Text = Message.Small;
            normalScrollToolStripMenuItem.Text = Message.Normal;
            largeScrollToolStripMenuItem.Text = Message.Large;
            hugeScrollToolStripMenuItem.Text = Message.Huge;
            _1lineScrollToolStripMenuItem.Text = Message.OneLine;
            _2lineScrollToolStripMenuItem.Text = Message._1Lines.Replace("$1", "2");
            _3lineScrollToolStripMenuItem.Text = Message._1Lines.Replace("$1", "3");
            thumbnailCacheToolStripMenuItem.Text = Message.ThumbnailCache + "...";
            //createCacheInADSInNTFSToolStripMenuItem.Text = Message.CreateThumbnailCache;
            //aboutThumbnailCacheToolStripMenuItem.Text = Message.AboutThumbnailCache + "...";
            letterboxToolStripMenuItem.Text = Message.Letterbox;
            panAndScanToolStripMenuItem.Text = Message.PanAndScan;
            plaClipToolStripMenuItem.Text = Message.SmartClip;
            cutToolStripMenuItem.Text = Message.Cut;
            //copyToolStripMenuItem.Text = Message.Copy;
            pasteToolStripMenuItem.Text = Message.Paste;
            renameToolStripMenuItem.Text = Message.Rename;
            //deleteonlyForListFileToolStripMenuItem.Text = Message.DeleteOnlyForVirtualFolder;
            //deleteonlyForListFileToolStripMenuItem.Text = Message.Delete;
            optionToolStripMenuItem.Text = Message._Others;
            tagEditorToolStripMenuItem.Text = Message.Edit_Tags + "...";
            mouseGestureSettingToolStripMenuItem.Text = Message._MouseTouchGestures + "...";
            changeCurrentProfileColorToolStripMenuItem.Text = Message._ChangeCurrentProfileColor + "...";
            preferenceToolStripMenuItem.Text = Message.Common_Settings + "...";

            moveHereToolStripMenuItem.Text = Message.MoveHere;
            copyHereToolStripMenuItem.Text = Message.CopyHere;

            pasteOnBackGroundToolStripMenuItem.Text = Message.Paste;

            toolTip.SetToolTip(btnLocationCommands, $"{Message.ClearMenuForAddressBarHistory}");
            toolTip.SetToolTip(btnFilterCommands, $"{Message.EditMenuForFilter}");

            // MessageFoworder と競合、またツールチップが表示領域を隠すので自前で実装する
            //toolTip.SetToolTip(cbFilter, $"{Message.MiddleClickToClearPaste}");

            toolTip.SetToolTip(btnGoToBack, $"{Message.GoBack} (Alt+←, {Message.X1Button})\n{Message.RightClickDownFlickToShowHistory}");
            toolTip.SetToolTip(btnGoToForward, $"{Message.GoForward} (Alt+→, {Message.X2Button})\n{Message.RightClickDownFlickToShowHistory}");


            deleteCurrentPathFromHistoryToolStripMenuItem.Text = Message.DeleteCurrentPathFromHistory;
            clearAllHistoryOfLocationsToolStripMenuItem.Text = Message.ClearAllHistoryOfLocations;

            iconToolStripMenuItem.Text = Message.Icon;
            fileNameToolStripMenuItem.Text = Message.Name;
            ratingHeaderRightClickToolStripMenuItem.Text = Message.Rating;
            pageToolStripMenuItem.Text = Message.Page;
            dateCreatedToolStripMenuItem.Text = Message.DateCreated;
            accessTimeToolStripMenuItem.Text = Message.DateAccessed;
            writeTimeToolStripMenuItem.Text = Message.DateModified;
            sizeToolStripMenuItem.Text = Message.Size;
            resolutionToolStripMenuItem.Text = Message.Resolution;
            ratioToolStripMenuItem.Text = Message.AspectRatio;
            widthToolStripMenuItem.Text = Message.Width;
            heightToolStripMenuItem.Text = Message.Height;
            lengthToolStripMenuItem.Text = Message.Length;
            fPSToolStripMenuItem.Text = Message.FPS;

            deleteCurrentFilterFromHistoryToolStripMenuItem.Text = Message.DeleteCurrentFilterFromDropdown;
            deleteCurrentFilterFromHistoryToolStripMenuItem.ShortcutKeyDisplayString = Message.MiddleClick;
            clearAllHistoryOfFiltersToolStripMenuItem.Text = Message.ClearAllDropdownItems;
            editDropdownOfFiltersToolStripMenuItem.Text = Message.EditDropdownOfFilters + "...";

            addToolStripMenuItem.Text = Message._Add;
            addToolStripMenuItem.ToolTipText = Message.RightClickDownFlickToOpenContextMenu;
            currentLocationToolStripMenuItem.Text = Message.BookmarkWithCurrentProfileColor;
            currentLocationToolStripMenuItem.ShortcutKeyDisplayString = Message.LeftClick;
            currentLocationAndFilterToolStripMenuItem.Text = Message.BookmarkWithNewProfileColor;
            AddOnlyTheCurrentProfileColorToolStripMenuItem.Text = Message.OnlyCurrentProfileColor;
            addOnlyANewProfileColorToolStripMenuItem.Text = Message.OnlyNewProfileColor;
            separatorToolStripMenuItem.Text = Message.Separator;
            aboutAccessKeyToolStripMenuItem.Text = Message.AboutAccessKey + "...";

            addToBookmarkWithCurrentProfileColorRightClickDropToolStripMenuItem.Text = Message.AddWithCurrentProfileColor;
            addToBookmarkWithNewProfileColorRightClickDropToolStripMenuItem.Text = Message.AddWithNewProfileColor;

            deleteToolStripMenuItem.Text = Message.Delete;
            //aliasToolStripMenuItem.Text = Message.EditAlias;
            realNameToolStripMenuItem.Text = Message.RealName;
            addSeparatorToolStripMenuItem.Text = Message.AddSeparator;
            //setCurrentLocationToolStripMenuItem.Text = Message.SetToCurrentLocation;
            //setCurrentLocationAndStateToolStripMenuItem.Text = Message.SetToCurrentLocationAndState;
            openInExplorerInDirectoryListToolStripMenuItem.Text = Message.OpenInExplorer;
            editSmartFolderToolStripMenuItem.Text = Message.EditSmartFolder;
            //loadOnlyProfileColorToolStripMenuItem.Text = Message.LoadOnlyProfileColor;

            tbcFileName.HeaderText = Message.Name;
            tbcFileName.MinimumWidth = 2;
            tbcFileName.Width = 0;
            //var temp = tbcFileName.HeaderCell.SortGlyphDirection;
            //if (temp == SortOrder.None) tbcFileName.HeaderCell.SortGlyphDirection = SortOrder.Ascending;
            tbcFileName.AutoSizeMode = DataGridViewAutoSizeColumnMode.ColumnHeader;
            tbcFileName.MinimumWidth = tbcFileName.Width;
            //if (temp == SortOrder.None) tbcFileName.HeaderCell.SortGlyphDirection = temp;
            tbcFileName.AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;


            tbcPage.HeaderText = Message.Page;
            tbcRating.HeaderText = Message.Rating;
            tbcCreateTime.HeaderText = Message.DateCreated;
            tbcAccessTime.HeaderText = Message.DateAccessed;
            tbcWriteTime.HeaderText = Message.DateModified;
            tbcSize.HeaderText = Message.Size;
            tbcResolution.HeaderText = Message.Resolution;
            tbcRatio.HeaderText = Message.AspectRatio;
            tbcWidth.HeaderText = Message.Width;
            tbcHeight.HeaderText = Message.Height;
            tbcLength.HeaderText = Message.Length;
            tbcFPS.HeaderText = Message.FPS;

            //openInBuiltinViewerToolStripMenuItem.Text = Message.OpenInBuiltInViewer;
            //openInAssociationToolStripMenuItem.Text = Message.Open;
            //moveToThisFolderToolStripMenuItem.Text = Message.MoveToThisFolder;
            //openInExplorerToolStripMenuItem.Text = Message.OpenInExplorer;
            tagToolStripMenuItem.Text = Message.Tag;
            listFileToolStripMenuItem.Text = Message.VirtualFolder;
            addToNewListToolStripMenuItem.Text = Message.AddToNewVirtualFolder + "...";
            removeFromHistoryToolStripMenuItem.Text = Message.RemoveFromHistory;
            ratingToolStripMenuItem.Text = Message.Rating;
            noneToolStripMenuItem.Text = Message.None;
            //noneToolStripMenuItem.ShortcutKeyDisplayString = Message.MiddleClickOnStars;
            thumbnailToolStripMenuItem.Text = Message.Cover;
            setThumbnailManuallyToolStripMenuItem.Text = Message.SetCoverManually + "...";
            setCoverToThisToolStripMenuItem.Text = Message.SetCoverToThis;
            //setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
            clearThumbnailSettingToolStripMenuItem.Text = Message.ClearCoverSetting;
            pageSequenceToolStripMenuItem.Text = Message.PageSequence;
            defaultToolStripMenuItem.Text = Message.Default;
            leftToRightToolStripMenuItem.Text = Message.LeftToRight;
            rightToLeftToolStripMenuItem.Text = Message.RightToLeft;
            singlePageToolStripMenuItem.Text = Message.SinglePage;
            propertiesToolStripMenuItem.Text = Message.Properties + "...";

            addToNewListSaveFileDialog.Title = Message.AddToNewVirtualFolder;
            addToNewListSaveFileDialog.Filter = $"{Message.VirtualFolder}|*.sor";
            //openListFileDialog.Title = Message.OpenVirtualFolder;
            //openListFileDialog.Filter = $"{Message.VirtualFolder}|*.sor";


            ratingFilterToolStripMenuItem.ToolTipText = Message.RightClickDownFlickToOpenContextMenu;
            increaseReferenceValueToolStripMenuItem.Text = Message.IncreaseReferenceValue;
            decreaseReferenceValueToolStripMenuItem.Text = Message.DecreaseReferenceValue;
            //increaseReferenceValueToolStripMenuItem.ShortcutKeyDisplayString = Message.WheelUp;
            //decreaseReferenceValueToolStripMenuItem.ShortcutKeyDisplayString = Message.WheelDown;


            if (simplifiedKeyBoard != null)
            {
                foreach (var key in simplifiedKeyBoard.Keys)
                {
                    switch (key.KeyCode)
                    {
                        case Keys.None: key.Text = Message.Tag; break;
                    }
                }
            }

            Text = string.IsNullOrEmpty(currentLocation) ? Program.Name : $"{SimpleBookmark.GetDisplayName(currentLocation)} - {Program.Name}";

#if RUNTIME
            Program.RunTimeMeasure?.Block("ShowStatusBar");
#endif
            ShowStatusBar();

#if RUNTIME
            Program.RunTimeMeasure?.Block("DgvDirectoryListRefresh");
#endif
            dgvDirectoryList.Refresh();

            var culture = Message.CurrentLanguage;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null)
                {
                    var rows = dgvFileList.Rows;
                    var rowsCount = rows.Count;
                    var s2d = tvCatalog.ShowIndexToDataIndex;
                    //var tbcAccessTimeIndex = tbcAccessTime.Index;
                    var tbcRatingIndex = tbcRating.Index;
                    //if (s2d.Length == rowsCount)
                    if (!CreatingZipPathArray && s2d != null && s2d.Length == rowsCount)
                    {
                        for (var i = 0; i < rowsCount; i++)
                        {
                            setFileListRowInLock(s2d[i], dynamicOnly: false, localOnly: true, cultureForOnlyStatic: culture, volatilitySortCancelIfChanged: false);
                            //var cells = rows[i].Cells;
                            //cells[tbcRatingIndex].ToolTipText = Message.MiddleClickToResetRating;

                        }
                    }
                }
            }

            if ((InMovie || InArchive) && LocationZipPlaInfo != null && LocationZipPlaInfo.ThumbnailInfo != null)
            {
                tvCatalog.Refresh();
            }

#if RUNTIME
            //Program.RunTimeMeasure?.Block("SetFileListHeaderWidth");
#endif
            // ファイルリストのヘッダの設定よりも後で
            SetFileListHeaderWidth(culture, Message.Bytes);

#if RUNTIME
            //Program.RunTimeMeasure?.Block("SetStatusBarWidth");
#endif
            SetStatusBarWidth();
#if RUNTIME
            //Program.RunTimeMeasure?.Block("SetSortNames");
#endif

            // 先にすると変更がその時点で描画されて見栄えが良くない
            cbSortBy_SelectedValueChanged_Stop = true;
            cbSortBy.Items[(int)SortMode.TypeInAsc] = Message.TypeInAsc;
            cbSortBy.Items[(int)SortMode.TypeInDesc] = Message.TypeInDesc;
            cbSortBy.Items[(int)SortMode.NameInAsc] = Message.NameInAsc;
            cbSortBy.Items[(int)SortMode.NameInDesc] = Message.NameInDesc;
            cbSortBy.Items[(int)SortMode.RatingInAsc] = Message.RatingInAsc;
            cbSortBy.Items[(int)SortMode.RatingInDesc] = Message.RatingInDesc;
            cbSortBy.Items[(int)SortMode.CreatedInAsc] = Message.CreatedInAsc;
            cbSortBy.Items[(int)SortMode.CreatedInDesc] = Message.CreatedInDesc;
            cbSortBy.Items[(int)SortMode.AccessedInAsc] = Message.AccessedInAsc;
            cbSortBy.Items[(int)SortMode.AccessedInDesc] = Message.AccessedInDesc;
            cbSortBy.Items[(int)SortMode.ModifiedInAsc] = Message.ModifiedInAsc;
            cbSortBy.Items[(int)SortMode.ModifiedInDesc] = Message.ModifiedInDesc;
            cbSortBy.Items[(int)SortMode.SizeInAsc] = Message.SizeInAsc;
            cbSortBy.Items[(int)SortMode.SizeInDesc] = Message.SizeInDesc;
            cbSortBy.Items[(int)SortMode.Random] = Message.Random;
            cbSortBy_SelectedValueChanged_Stop = false;

#if RUNTIME
            Program.RunTimeMeasure?.Block("PerformLayout");
#endif

            for (var i = SetMessages_LayoutControls.Length - 1; i >= 0; i--)
            {
                var control = SetMessages_LayoutControls[i];
                control.ResumeLayout(performLayout: false);
                control.PerformLayout();
            }
#if RUNTIME
            //Program.RunTimeMeasure?.Block("AfterSetMessages");
#endif

        }

        private void SetStatusBarWidth()
        {
            var font = fileSizeToolStripStatusLabel.Font; // Dispose してはならない
            Func<string, int> measure = text => TextRenderer.MeasureText(text, font).Width; // font が null でも動作するが戻り値が決まった値に成らないので注意
            var digitWithMaximumSize = GetDigitWithMaximumSize(measure);

            itemsCountToolStripStatusLabel.Width = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, Message._1Items.Replace("$1", "000000"));

            //var fileSizeMaxWidth = Enumerable.Range(0, 5) // 999 Bytes, 999.0 KB, 999.0 MB, 999.0 GB, 999.0 TB まで
            //    .Select(i => GetMaxWidthWithTemplates(measure, digitWithMaximumSize, Program.GetFormatSizeString(999L << (10*i), Message.Bytes, simpleForm: true) + "+")).Max();
            var fileSizeMaxWidth = fileSizeToolStripStatusLabel.Width = GetMaxWidthWithTemplates(measure, digitWithMaximumSize,
                Program.GetFormatSizeStringTemplates(Message.Bytes).Select(s => s + "+"));

            var movieTemplate = MovieInfo.ToShortStringTemplate;
            var pageTemplage = Program.GetNPageString(99999);
            var sizeTemplate = "00000x00000";

            selectedFileContainsCountToolStripStatusLabel.Width = Math.Max(Math.Max(
                GetMaxWidthWithTemplates(measure, digitWithMaximumSize, movieTemplate),
                GetMaxWidthWithTemplates(measure, digitWithMaximumSize, pageTemplage)),
                GetMaxWidthWithTemplates(measure, digitWithMaximumSize, sizeTemplate));
        }

        private void SetFileListHeaderWidth(CultureInfo culture, string bytesInString)
        {
            // ページ・FPSはヘッダのみから設定されるように AutoSize が設定されている

            var font = dgvFileList.DefaultCellStyle.Font; // Dispose してはならない
            Func<string, int> measure = text => TextRenderer.MeasureText(text, font).Width; // font が null でも動作するが戻り値が決まった値に成らないので注意
            var digitWithMaximumSize = GetDigitWithMaximumSize(measure);

            var dateTimeWidth = GetMaxWidthOfDateTime(measure, digitWithMaximumSize, culture);
            setColumnWidth(tbcCreateTime, dateTimeWidth, measure);
            setColumnWidth(tbcAccessTime, dateTimeWidth, measure);
            setColumnWidth(tbcWriteTime, dateTimeWidth, measure);

            var sizeWidth = GetMaxWidthWithTemplates(measure, digitWithMaximumSize,
                Program.GetFormatSizeStringTemplates(bytesInString));
            setColumnWidth(tbcSize, sizeWidth, measure);

            var rosolusionSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, "11111x11111");
            setColumnWidth(tbcResolution, rosolusionSize, measure);

            var ratioSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, getRatioString_MaxWidthTemplate);
            setColumnWidth(tbcRatio, ratioSize, measure);

            var fiveDigitSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, "11111");
            setColumnWidth(tbcWidth, fiveDigitSize, measure);
            setColumnWidth(tbcHeight, fiveDigitSize, measure);

            // 10 時間超えを考慮しない選択肢も考えられるが、ヘッダが短い日本語でも 10 時間超えを想定してもなおヘッダによって幅が決まるので重要でない
            var lengthSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, new TimeSpan(11, 11, 11).ToString(setFileListRoDynamicPart_LengthFormat));
            setColumnWidth(tbcLength, lengthSize, measure);

            SetFileListPageHeaderWidth_Fraction = getPageIsFraction();
            SetFileListPageHeaderWidth(measure, digitWithMaximumSize);

            var fpsSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize, "29.97");
            setColumnWidth(tbcFPS, fpsSize, measure);
        }


        private void SetFileListPageHeaderWidth()
        {
            var pageFraction = getPageIsFraction();
            if (pageFraction != SetFileListPageHeaderWidth_Fraction)
            {
                var font = dgvFileList.DefaultCellStyle.Font; // Dispose してはならない
                Func<string, int> measure = text => TextRenderer.MeasureText(text, font).Width; // font が null でも動作するが戻り値が決まった値に成らないので注意
                var digitWithMaximumSize = GetDigitWithMaximumSize(measure);

                SetFileListPageHeaderWidth_Fraction = getPageIsFraction();
                SetFileListPageHeaderWidth(measure, digitWithMaximumSize);
            }
        }

        bool SetFileListPageHeaderWidth_Fraction = false;
        private void SetFileListPageHeaderWidth(Func<string, int> measure, string digitWithMaximumSize)
        {
            var pageSize = GetMaxWidthWithTemplates(measure, digitWithMaximumSize,
                SetFileListPageHeaderWidth_Fraction ? getPageString(11110, 11111) : getPageString(-1, 11111));
            setColumnWidth(tbcPage, pageSize, measure);
        }

        private bool getPageIsFraction()
        {
            return LoadLastViewedPageFromHistory || (InVirtualDirectory && currentLocation == Program.HistorySorPath);
            // InVirtualDirectory が無いと、Program.HistorySorPath が無くて同名のフォルダが存在してそれを開いている時に期待通りの結果にならない
        }

        private void setColumnWidth(DataGridViewColumn column, int cellMaximumWidth, Func<string, int> measure)
        {
            //var gap = 200;
            //var headerWidth = tbcMargin + measure(column.HeaderText) + gap;
            //var x = column.HeaderCell.InheritedStyle.;

            //column.Width = Math.Max(cellMaximumWidth, headerWidth);

            var dgv = column.DataGridView;
            dgv.AutoResizeColumn(column.Index, DataGridViewAutoSizeColumnMode.ColumnHeader);
            var plus = tbcIconWidth - 22;
            cellMaximumWidth = Math.Max(column.Width + plus, cellMaximumWidth);
            //cellMaximumWidth = 200;
            if (column.Width < cellMaximumWidth) column.Width = cellMaximumWidth;
        }

        public static T GetMaxWidthWithTemplates<T>(Func<string, T> measure,
             string digitWithMaximumSize, params string[] templates) where T : IComparable<T>
        {
            return GetMaxWidthWithTemplates(measure, digitWithMaximumSize, templates as IEnumerable<string>);
        }

        private static T GetMaxWidthWithTemplates<T>(Func<string, T> measure,
             string digitWithMaximumSize, IEnumerable<string> templates) where T : IComparable<T>
        {
            return templates.Max(template => measure(Regex.Replace(template, @"\d", digitWithMaximumSize)));
        }

        private T GetMaxWidthOfDateTime<T>(Func<string, T> measure, string digitWithMaximumSize, CultureInfo culture) where T : IComparable<T>
        {
            // 午前／午後、月、曜日それぞれの最大幅を取得してそれらを繋げた日付の幅を返す
            T maxSize, size;

            const int testYear = 1999;

            var month = new DateTime(testYear, 1, 11, 11, 11, 11);
            var monthWithMaximumSize = month;
            maxSize = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize));
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(29); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; } // うるう年以外はずれるが問題ない
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(30); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(30); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(30); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(31); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; monthWithMaximumSize = month; }
            month = month.AddDays(30); size = measure(Regex.Replace(getShortTimeString(month, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { /*maxSize = size;*/ monthWithMaximumSize = month; }

            var ampm = new DateTime(testYear, 1, 11, 11, 11, 11);
            var ampmWithMaximumSize = ampm;
            maxSize = measure(Regex.Replace(getShortTimeString(ampm, culture), @"\d", digitWithMaximumSize));
            ampm = ampm.AddHours(12); size = measure(Regex.Replace(getShortTimeString(ampm, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { /*maxSize = size;*/ ampmWithMaximumSize = ampm; }

            var day = new DateTime(testYear, 1, 11, 11, 11, 11);
            var dayWithMaximumSize = day;
            maxSize = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize));
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }
            day = day.AddDays(1); size = measure(Regex.Replace(getShortTimeString(day, culture), @"\d", digitWithMaximumSize)); if (size.CompareTo(maxSize) > 0) { maxSize = size; dayWithMaximumSize = day; }

            var dateWithMaximumSize = new DateTime(testYear, monthWithMaximumSize.Month, 11, ampmWithMaximumSize.Hour, 11, 11);
            dateWithMaximumSize.AddDays((dayWithMaximumSize.DayOfWeek - dateWithMaximumSize.DayOfWeek + 7) % 7);

            return measure(Regex.Replace(getShortTimeString(dateWithMaximumSize, culture), @"\d", digitWithMaximumSize));
        }

        public static string GetDigitWithMaximumSize<T>(Func<string, T> measure) where T : IComparable<T>
        {
            var max = measure("0");
            var maxDigit = "0";
            T size;
            size = measure("1"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "1"; }
            size = measure("2"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "2"; }
            size = measure("3"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "3"; }
            size = measure("4"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "4"; }
            size = measure("5"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "5"; }
            size = measure("6"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "6"; }
            size = measure("7"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "7"; }
            size = measure("8"); if (size.CompareTo(max) > 0) { max = size; maxDigit = "8"; }
            size = measure("9"); if (size.CompareTo(max) > 0) { /*max = size;*/ maxDigit = "9"; }
            return maxDigit;
        }

        private bool showIcon = true;
        private bool showRating = true;
        private bool showTags = true;

        private SubfolderMode subfolderMode = SubfolderMode.Display;
        private SubfolderMode SubfolderMode
        {
            get
            {
                return subfolderMode;
            }
            set
            {
                SetSubfolderMode(value, checkAllLoadLevel: false);
                /*
                if (value != subfolderMode)
                {
                    subfolderMode = value;
                    switch (value)
                    {
                        case SubfolderMode.Display:
                            foldersToolStripMenuItem.CheckState = CheckState.Checked;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                            break;
                        case SubfolderMode.DisplayHeader:
                            foldersToolStripMenuItem.CheckState = CheckState.Indeterminate;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                            break;
                        case SubfolderMode.Ignore:
                            foldersToolStripMenuItem.CheckState = CheckState.Unchecked;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                            break;
                        case SubfolderMode.Search:
                            foldersToolStripMenuItem.CheckState = CheckState.Unchecked;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                            break;
                        case SubfolderMode.DisplayAndSearch:
                            foldersToolStripMenuItem.CheckState = CheckState.Checked;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                            break;
                        case SubfolderMode.DisplayHeaderAndSearch:
                            foldersToolStripMenuItem.CheckState = CheckState.Indeterminate;
                            searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                            break;
                    }
                }
                */
            }
        }
        bool SetSubfolderMode(SubfolderMode value, bool checkAllLoadLevel)
        {
            if (subfolderMode != value)
            {
                if (checkAllLoadLevel && IsDisplay(subfolderMode) && !IsDisplay(value))
                {
                    if (archiveLoadLevel == ItemLoadLevel.Ignore && imageLoadLevel == ItemLoadLevel.Ignore && videoLoadLevel == ItemLoadLevel.Ignore && otherLoadLevel == ItemLoadLevel.Ignore)
                    {
                        // Search 如何が変化する場合そこだけ変更
                        // Search 如何が変化しない場合 Display と DisplayHeader をトグル
                        subfolderMode =
                            subfolderMode == SubfolderMode.Display ?
                                value == SubfolderMode.Ignore ?
                                    SubfolderMode.DisplayHeader :
                                    SubfolderMode.DisplayAndSearch :
                            subfolderMode == SubfolderMode.DisplayHeader ?
                                value == SubfolderMode.Ignore ?
                                    SubfolderMode.Display :
                                    SubfolderMode.DisplayHeaderAndSearch :
                            subfolderMode == SubfolderMode.DisplayAndSearch ?
                                value == SubfolderMode.Ignore ?
                                    SubfolderMode.Display :
                                    SubfolderMode.DisplayHeaderAndSearch :
                                value == SubfolderMode.Ignore ?
                                    SubfolderMode.DisplayHeader :
                                    SubfolderMode.DisplayAndSearch;
                        
                        /*
                        AllowFullpower = false;
                        MessageBox.Show(this, Message.AtLeastOneKindOfItemsMustBeSelected, Message.Information, MessageBoxButtons.OK, MessageBoxIcon.Information);
                        AllowFullpower = true;
                        */
                    }
                    else
                    {
                        subfolderMode = value;
                    }
                }
                else
                {
                    subfolderMode = value;
                }
                switch (subfolderMode)
                {
                    case SubfolderMode.Display:
                        foldersToolStripMenuItem.CheckState = CheckState.Checked;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                        break;
                    case SubfolderMode.DisplayHeader:
                        foldersToolStripMenuItem.CheckState = CheckState.Indeterminate;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                        break;
                    case SubfolderMode.Ignore:
                        foldersToolStripMenuItem.CheckState = CheckState.Unchecked;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = false;
                        break;
                    case SubfolderMode.Search:
                        foldersToolStripMenuItem.CheckState = CheckState.Unchecked;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                        break;
                    case SubfolderMode.DisplayAndSearch:
                        foldersToolStripMenuItem.CheckState = CheckState.Checked;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                        break;
                    case SubfolderMode.DisplayHeaderAndSearch:
                        foldersToolStripMenuItem.CheckState = CheckState.Indeterminate;
                        searchSubfoldersAsWellToolStripMenuItem.Checked = true;
                        break;
                }
                return true;
            }
            return false;
        }

        private ClipMode clipModeByControl
        {
            get
            {
                if (letterboxToolStripMenuItem.Checked) return ClipMode.Letterbox;
                else if (panAndScanToolStripMenuItem.Checked) return ClipMode.PanAndScan;
                else return ClipMode.PlaClip;
            }
            set
            {
                letterboxToolStripMenuItem.Checked = value == ClipMode.Letterbox;
                panAndScanToolStripMenuItem.Checked = value == ClipMode.PanAndScan;
                plaClipToolStripMenuItem.Checked = value == ClipMode.PlaClip;
            }
        }

        private BindingMode bindingModeByControl
        {
            get
            {
                if (defaultSinglePageToolStripMenuItem.Checked) return BindingMode.SinglePage;
                if (singlePageWithoutScalingUpToolStripMenuItem.Checked) return BindingMode.SinglePageWithoutScalingUp;
                if (defaultLeftToRightToolStripMenuItem.Checked) return BindingMode.LeftToRight;
                return BindingMode.RightToLeft;
            }
            set
            {
                defaultSinglePageToolStripMenuItem.Checked = value == BindingMode.SinglePage;
                singlePageWithoutScalingUpToolStripMenuItem.Checked = value == BindingMode.SinglePageWithoutScalingUp;
                defaultLeftToRightToolStripMenuItem.Checked = value == BindingMode.LeftToRight;
                defaultRightToLeftToolStripMenuItem1.Checked = value == BindingMode.RightToLeft;
            }
        }

        const int DragEventKeyState_LeftButton = 1;
        int graphicalListDrag_SelectedFolderShowIndex;
        private void graphicalListDragEnter(IGraphicalList sender, GraphicalListDragEventArgs e)
        {
            if (dragOuting && dragAndDropAction == DragAndDropAction.ShowThumbnails)
            {
                e.Effect = DragDropEffects.None;
                return;
            }
            try
            {
                if (/*e.GetKeyState() == Keys.LButton && */zabLocation.Enabled)
                {
                    if (dragAndDropAction == DragAndDropAction.ShowThumbnails)
                    {
                        if (e.GetKeyState() == Keys.LButton && e.Data.GetDataPresent(DataFormats.FileDrop))
                        {
                            string[] Files = ShortcutResolver.Exec((string[])e.Data.GetData(DataFormats.FileDrop, false)).ToArray();
                            if (Files.Length == 1)
                            {
                                e.Effect = DragDropEffects.Copy;
                            }
                            else
                            {
                                e.Effect = DragDropEffects.None;
                            }
                        }
                        else
                        {
                            e.Effect = DragDropEffects.None;
                        }
                    }
                    else if (dragAndDropAction == DragAndDropAction.MoveOrCopyFiles)
                    {
                        if (InRealDirectory)
                        {
                            graphicalListDrag_SelectedFolderShowIndex = -1;
                            dropToMoveCopyControl_DragEnter(null, e);
                        }
                        else if (InVirtualDirectory)
                        {
                            if (e.Data.GetDataPresent(DataFormats.FileDrop))
                            {
                                e.Effect = DragDropEffects.Copy;
                            }
                            else
                            {
                                e.Effect = DragDropEffects.None;
                            }
                        }
                        else
                        {
                            e.Effect = DragDropEffects.None;
                        }
                    }
                }
            }
            catch (Exception error)
            {
                e.Effect = DragDropEffects.None;
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void graphicalListDragOver(IGraphicalList sender, GraphicalListDragEventArgs e)
        {
            if (dragAndDropAction == DragAndDropAction.MoveOrCopyFiles)
            {
                if (!InRealDirectory) return;
                var si = e.Index;
                if (si < 0)
                {
                    e.Effect = getCurrentLocationDragEffect(e);
                    if (graphicalListDrag_SelectedFolderShowIndex != -1)
                    {
                        sender.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                        graphicalListDrag_SelectedFolderShowIndex = -1;
                    }
                    return;
                }
                var s2d = tvCatalog.ShowIndexToDataIndex;
                if (s2d == null || s2d.Length <= si) return; // 想定外
                var di = s2d[si]; if (di < 0) return; // 想定外
                int zpaLength;
                var zna = ZipNameArray; if (zna == null || (zpaLength = zna.Length) <= di) return; // 想定外 
                //var path = zpa[di]; if (string.IsNullOrEmpty(path)) return;
                var name = zna[di]; if (string.IsNullOrEmpty(name)) return;
                if (name.Last() == Path.DirectorySeparatorChar)
                {
                    var zpa = ZipPathArray; if (zpa == null || zpa.Length != zpaLength) return; // 想定外 
                    var path = zpa[di]; if (string.IsNullOrEmpty(path)) return;
                    e.Effect = getDragEffect(path, e.AllowedEffect, SameDirEffectMode.None);
                    if (e.Effect != DragDropEffects.None)
                    {
                        if (graphicalListDrag_SelectedFolderShowIndex != si)
                        {
                            sender.DrawHighlight(si);
                            if (graphicalListDrag_SelectedFolderShowIndex != -1)
                            {
                                sender.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                            }
                            graphicalListDrag_SelectedFolderShowIndex = si;

                        }
                    }
                    else
                    {
                        if (graphicalListDrag_SelectedFolderShowIndex != -1)
                        {
                            sender.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                            graphicalListDrag_SelectedFolderShowIndex = -1;
                        }
                    }
                    return;
                }
                else
                {
                    e.Effect = getCurrentLocationDragEffect(e);
                    if (graphicalListDrag_SelectedFolderShowIndex != -1)
                    {
                        sender.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                        graphicalListDrag_SelectedFolderShowIndex = -1;
                    }
                    return;
                }
            }
        }

        private void graphicalListDragLeave(object sender, EventArgs e)
        {
            if (graphicalListDrag_SelectedFolderShowIndex != -1)
            {
                (sender as IGraphicalList)?.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                graphicalListDrag_SelectedFolderShowIndex = -1;
            }
        }

        private string graphicalListPathGetter(DragEventArgs e)
        {
            var e2 = (GraphicalListDragEventArgs)e;

            var si = e2.Index;
            if (si < 0)
            {
                return currentLocation;
            }
            else
            {
                var s2d = tvCatalog.ShowIndexToDataIndex;
                if (s2d == null || s2d.Length <= si) return null; // 想定外
                var di = s2d[si]; if (di < 0) return null; // 想定外
                int zpaLength;
                var zna = ZipNameArray; if (zna == null || (zpaLength = zna.Length) <= di) return null;
                var name = zna[di]; if (string.IsNullOrEmpty(name)) return null;
                var isDir = name.Last() == Path.DirectorySeparatorChar;
                if (!isDir) return currentLocation;
                var zpa = ZipPathArray; if (zpa == null || zpa.Length != zpaLength) return null; // 想定外 
                return zpa[di];
            }
        }

        private void graphicalListDragDrop(IGraphicalList sender, GraphicalListDragEventArgs e)
        {
            try
            {
                if (dragAndDropAction == DragAndDropAction.ShowThumbnails)
                {
                    var path = ShortcutResolver.Exec(((string[])e.Data.GetData(DataFormats.FileDrop, false))[0]);
                    MoveLocation(ApplicationProviderUser.DragAndDrop, path);
                }
                else if (dragAndDropAction == DragAndDropAction.MoveOrCopyFiles)
                {
                    if (InRealDirectory)
                    {
                        dropToMoveCopyControl_DragDrop(e, graphicalListPathGetter, finallyAction: () =>
                        {
                            if (graphicalListDrag_SelectedFolderShowIndex != -1)
                            {
                                sender.Invalidate(graphicalListDrag_SelectedFolderShowIndex);
                                graphicalListDrag_SelectedFolderShowIndex = -1;
                            }
                        });
                    }
                    else if (InVirtualDirectory)
                    {
                        pasteToCurrentLocation(e.Data, DragDropEffects.Copy);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private DragDropEffects getCurrentLocationDragEffect(GraphicalListDragEventArgs e)
        {
            if (string.IsNullOrEmpty(currentLocation)) return DragDropEffects.None;
            if (InRealDirectory) return getDragEffect(currentLocation, e.AllowedEffect, SameDirEffectMode.None);
            if (InVirtualDirectory) return DragDropEffects.Copy;
            return DragDropEffects.None;
        }

        private void tvCatalog_GraphicalListDragEnter(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragEnter(sender, e); }
        private void tvCatalog_GraphicalListDragOver(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragOver(sender, e); }
        private void tvCatalog_GraphicalListDragLeave(object sender, EventArgs e) { graphicalListDragLeave(sender, e); }
        private void tvCatalog_GraphicalListDragDrop(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragDrop(sender, e); }

        private void dgvFileList_GraphicalListDragEnter(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragEnter(sender, e); }
        private void dgvFileList_GraphicalListDragOver(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragOver(sender, e); }
        private void dgvFileList_GraphicalListDragLeave(object sender, EventArgs e) { graphicalListDragLeave(sender, e); }
        private void dgvFileList_GraphicalListDragDrop(IGraphicalList sender, GraphicalListDragEventArgs e) { graphicalListDragDrop(sender, e); }

        /*
        private void CatalogForm_DragEnter(object sender, DragEventArgs e)
        {
            if (dragOuting)
            {
                e.Effect = DragDropEffects.None;
                return;
            }
            try
            {
                if (e.KeyState == DragEventKeyState_LeftButton && e.Data.GetDataPresent(DataFormats.FileDrop) && zabLocation.Enabled)
                {

                    var action = dragAndDropAction;// (new GeneralConfig()).DragAndDropAction;
                    if (action == DragAndDropAction.ShowThumbnails)
                    {
                        string[] Files = ShortcutResolver.Exec((string[])e.Data.GetData(DataFormats.FileDrop, false)).ToArray();
                        if (Files.Length == 1) // && IsSupportedByCatalogFormAndExists(Files[0]))
                        {
                            e.Effect = DragDropEffects.Copy;
                        }
                        else
                        {
                            e.Effect = DragDropEffects.None;
                        }
                    }
                    else if (action == DragAndDropAction.MoveOrCopyFiles)
                    {
                        string[] Files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
                        if (Files.Length > 0 && (InRealDirectory || InVirtualDirectory))
                        {
                            var cl = currentLocation;
                            if (cl != null)
                            {
                                if (InRealDirectory)
                                {
                                    string root = null;
                                    try
                                    {
                                        root = Path.GetPathRoot(cl).ToLower();
                                    }
                                    catch { }
                                    if (root != null)
                                    {
                                        if (Files.All(file => Path.GetPathRoot(file).ToLower() == root))
                                        {
                                            e.Effect = DragDropEffects.Move;
                                        }
                                        else
                                        {
                                            e.Effect = DragDropEffects.Copy;
                                        }
                                    }
                                    else
                                    {
                                        e.Effect = DragDropEffects.None;
                                    }
                                }
                                else
                                {
                                    e.Effect = DragDropEffects.Copy;
                                }
                            }
                            else
                            {
                                e.Effect = DragDropEffects.None;
                            }
                        }
                        else
                        {
                            e.Effect = DragDropEffects.None;
                        }
                    }
                    else
                    {
                        e.Effect = DragDropEffects.None;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            catch (Exception error)
            {
                e.Effect = DragDropEffects.None;
                Program.AlertError(error);
            }
        }

        private void CatalogForm_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                //var action = (new GeneralConfig()).DragAndDropAction;
                var action = dragAndDropAction;
                if (action == DragAndDropAction.ShowThumbnails)
                {
                    var path = ShortcutResolver.Exec(((string[])e.Data.GetData(DataFormats.FileDrop, false))[0]);

                    MoveLocation(ApplicationProviderUser.DragAndDrop, path);

                    //zabLocation.Text = path;
                    //MakePreview();
                }
                else if (action == DragAndDropAction.MoveOrCopyFiles)
                {
                    pasteToCurrentLocation(e.Data, e.Effect);
                }
            }
            catch (Exception error)
            {
                Program.AlertError(error);
            }
        }
        */

        /*
        private void OpenInDefaultViewer(ApplicationProviderUser user, string path, bool? isDir = null)
        {
            try
            {
                RecentFfmpegExists = MovieThumbnailLoader.ffmpegExists();
                foreach (var app in ApplicationArray)
                {
                    if (isDir == null) isDir = Directory.Exists(path);
                    if (app.IsDefaultFor(path, (bool)isDir))
                    {
                        app.Exec(user, path);
                        return;
                    }
                }
                throw new Exception(Message.ApplicationIsNotSpecified);
            }
            catch (Exception error)
            {
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
        */

        /*
        private string GetExtentionByStreamAndSeekFirst(Stream stream)
        {
            var fourByte = new byte[4];
            stream.Read(fourByte, 0, 4);
            stream.Seek(-4, SeekOrigin.Current);
            if (fourByte.SequenceEqual(new byte[4] { 0x50, 0x4B, 0x03, 0x04 }))
            {
                return ".zip";
            }
            else if (fourByte.SequenceEqual(new byte[4] { 0x52, 0x61, 0x72, 0x21 }))
            {
                return ".rar";
            }
            else if (fourByte.Take(2).SequenceEqual(new byte[2] { 0x1F, 0x8B }))
            {
                return ".gz";
            }
            else
            {
                var hundredByte = new byte[100];
                stream.Read(hundredByte, 0, 100);
                stream.Seek(-100, SeekOrigin.Current);
                var nullChar = hundredByte.ToList().IndexOf(0);

                if (nullChar >= 1)
                {
                    for (int i = nullChar + 1; i < 100; i++)
                    {
                        if (hundredByte[i] != 0)
                        {
                            return null;
                        }
                    }
                }
                return ".tar";
            }
        }
        */

        private int getArchiveIndexWithAIAInfo(string path)
        {
            var info = new ZipPlaInfo(path);
            var thumb = info.ThumbnailInfo;
            var index = thumb != null ? thumb.Item1 : -1;
            return getArchiveIndexWithAIAInfo(index);
        }

        private int getArchiveIndexWithAIAInfo(int index)
        {
            // 上位 2 ビット使用
            switch (ArchivesInArchiveMode)
            {
                case ArchivesInArchiveMode.IfNoOther1Level: return index ^ (1 << 31 | 0 << 30);

                case ArchivesInArchiveMode.Always1Level: return index ^ (1 << 31 | 1 << 30); // 新たに追加する場合これを潰す

                case ArchivesInArchiveMode.UntilFound2Level: return index ^ (0 << 31 | 1 << 30); // 新規追加

                default: return index;
            }
        }

        private void getFileCount(out int filecount, string zipPath)
        {
            filecount = -1;
            try
            {
                if (thumbnailCache != null)
                {

                    byte[] data;
                    //if (GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
                    if (GPSizeThumbnail.TryGet(thumbnailCache, zipPath, getArchiveIndexWithAIAInfo(zipPath), out data))
                    {
                        try
                        {
                            filecount = dataToFileCount(data);
                        }
                        catch { }
                    }
                }
                if (filecount == -1 && ArchivesInArchiveMode == ArchivesInArchiveMode.Ignore)
                {
                    using (var loader = new PackedImageLoader(zipPath, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode))
                    {
                        filecount = loader.GetPackedImageEntries().Count;
                    }
                }
            }
            catch
            {
                filecount = -1;
                throw;
            }
        }

        private void getImageHeader(out ImageInfo imageInfo, string zipPath)
        {
            imageInfo = null;
            if (ImageInfo.Supports(zipPath))
            {
                imageInfo = new ImageInfo(zipPath); // パフォーマンス的なロスが少ないので正確な方から取得
            }
            else
            {
                byte[] data;
                if (thumbnailCache != null && GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
                {
                    imageInfo = ImageInfo.FromData(data);
                }
            }
        }

        private void getMovieHeader(out MovieInfo movieInfo, string zipPath)
        {
            movieInfo = null;

            byte[] data;
            if (thumbnailCache != null && GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
            {
                try
                {
                    movieInfo = MovieInfo.FromData(data);
                }
                catch { }
            }

            if (movieInfo == null)
            {
                movieInfo = MovieInfo.FromFile(zipPath);
            }
        }

        private enum LoadResult { Success, FileNotFound, LoadError, NotYet }

        private bool GetHeader(string zipPath, bool isDir, out bool plainFile, out int filecount, out LoadResult loadResult, out long fileSize, out ImageInfo imageInfo, out MovieInfo movieInfo)
        {
            filecount = MetaPageCount_NotBook;
            loadResult = LoadResult.NotYet;
            fileSize = -1;
            imageInfo = null;
            movieInfo = null;
            plainFile = false;

            if (zipPath.Contains(Path.AltDirectorySeparatorChar)) return false;

            try
            {
                if (isDir)
                {
                    /*
                    if (CheckDirectorySize)
                    {
                        try
                        {
                            fileSize = Program.GetDirectoryFileSize(new DirectoryInfo(zipPath));
                        }
                        catch { } // 読み取りできないファイルがあるとサイズを取得できない
                    }
                    */
                }
                else
                {
                    fileSize = (new FileInfo(zipPath)).Length;
                }

                bool? ffmpegExists = null;
                if (isDir || PackedImageLoader.Supports(zipPath))
                {
                    /*
                    filecount = -1;
                    try
                    {
                        if (thumbnailCache != null)
                        {

                            byte[] data;
                            //if (GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
                            if (GPSizeThumbnail.TryGet(thumbnailCache, zipPath, getArchiveIndexWithAIAInfo(zipPath), out data))
                            {
                                try
                                {
                                    filecount = dataToFileCount(data);
                                }
                                catch { }
                            }
                        }
                        if (filecount == -1 && ArchivesInArchiveMode == ArchivesInArchiveMode.Ignore)
                        {
                            using (var loader = new PackedImageLoader(zipPath, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode))
                            {
                                filecount = loader.GetPackedImageEntries().Count;
                            }
                        }
                    }
                    catch
                    {
                        filecount = -1;
                        throw;
                    }
                    */
                    getFileCount(out filecount, zipPath);
                }
                else if (ImageLoader.SupportsAtLeastThumbnailReading(zipPath, ref ffmpegExists))
                {
                    /*
                    if (ImageInfo.Supports(zipPath))
                    {
                        imageInfo = new ImageInfo(zipPath); // パフォーマンス的なロスが少ないので正確な方から取得
                    }
                    else
                    {
                        byte[] data;
                        if (thumbnailCache != null && GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
                        {
                            imageInfo = ImageInfo.FromData(data);
                        }
                    }
                    */
                    getImageHeader(out imageInfo, zipPath);
                }
                else if (MovieThumbnailLoader.Supports(zipPath) && (ffmpegExists ?? MovieThumbnailLoader.ffmpegExists()))
                {
                    /*
                    movieInfo = null;

                    byte[] data;
                    if (thumbnailCache != null && GPSizeThumbnail.TryGetWithIgnoredIndex(thumbnailCache, zipPath, out data))
                    {
                        try
                        {
                            movieInfo = MovieInfo.FromData(data);
                        }
                        catch { }
                    }

                    if (movieInfo == null)
                    {
                        movieInfo = MovieInfo.FromFile(zipPath);
                    }
                    */
                    getMovieHeader(out movieInfo, zipPath);
                }
                else
                {
                    plainFile = true;
                }
            }
            catch
            {
                loadResult = LoadResult.LoadError;
            }

            return true;
        }

        private bool SubfolderIsFullDisplayed() => SubfolderMode == SubfolderMode.Display || SubfolderMode == SubfolderMode.DisplayAndSearch;
        private static bool SubfolderIsSearched(SubfolderMode subfolderMode) => subfolderMode == SubfolderMode.DisplayAndSearch || subfolderMode == SubfolderMode.DisplayHeaderAndSearch || subfolderMode == SubfolderMode.Search;
        private bool SubfolderIsSearched() => SubfolderIsSearched(SubfolderMode);

        // サイズ取得は基本的に最初に行うが、最新の情報を得るためここで再取得。またフォルダについてはここで初めて取得
        public const int MetaPageCount_NotLoaded = -1;
        public const int MetaPageCount_NotBook = -2;

        private Bitmap GetThumbnail(string zipPath, bool isDir, BackgroundWorker backgroundWorker, out bool plainFile, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo, ref MovieInfo movieInfo, bool existsHeader)
        {
            var altSepPos = zipPath.IndexOf(Path.AltDirectorySeparatorChar);

            movieInfo = null;
            plainFile = false;

            if (altSepPos >= 0)
            {
                filecount = MetaPageCount_NotBook;
                fileSize = -1;
                try
                {
                    var path = zipPath.Substring(0, altSepPos);
                    var innerName = zipPath.Substring(altSepPos + 1);

                    if (PackedImageLoader.Supports(path))
                    {
                        loadError = LoadResult.Success;
                        var commonLoader = loadingPackedImageLoader != null;
                        PackedImageLoaderWithEntries loader;

                        if (commonLoader)
                        {
                            loader = loadingPackedImageLoader;
                        }
                        else
                        {
                            var pureLoader = new PackedImageLoader(path, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode);
                            try
                            {
                                loader = new PackedImageLoaderWithEntries(pureLoader);
                            }
                            catch
                            {
                                pureLoader.Dispose();
                                throw;
                            }
                        }
                        try
                        {
                            var entry = loader.Entries.First(e => e.Path == innerName);
                            Bitmap img;
                            if (commonLoader)
                            {
                                lock (loadingPackedImageLoaderLocker)
                                {
                                    img = loader.PackedImageLoader.OpenImageStream(entry);
                                }
                            }
                            else
                            {
                                img = loader.PackedImageLoader.OpenImageStream(entry);
                            }
                            try
                            {
                                imageInfo = ImageLoader.GetImageInfo(img);
                                return DoJustClipping(img, needToResize: true);
                            }
                            finally
                            {
                                img.Dispose();
                            }
                        }
                        finally
                        {
                            if (!commonLoader && loader != null) loader.Dispose();
                        }
                    }
                    else if (MovieThumbnailLoader.Supports(path) && MovieThumbnailLoader.ffmpegExists())
                    {
                        var pos = TimeSpan.Parse(innerName);
                        return GetMovieThumbnail(path, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo, ref movieInfo, t => pos);
                    }
                    else
                    {
                        throw new Exception();
                    }
                }
                catch
                {
                    loadError = LoadResult.LoadError;
                    imageInfo = null;
                    movieInfo = null;
                    if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                    var result = Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                    return result;
                }
            }
            else
            {
                if (thumbnailCache != GPSizeThumbnail.AlternateDataStream)
                {
#if DEBUG
                    if (NTFSMultiStream.Exists(zipPath, GPSizeThumbnail.STREAM_NAME) && !GPSizeThumbnail.TryDeleteAlternateDataStream(zipPath))
                    {
                        MessageBox.Show("Delete cache error");
                    }
#else
                    GPSizeThumbnail.TryDeleteAlternateDataStream(zipPath);
#endif
                }

                loadError = LoadResult.NotYet;
                fileSize = -1;
                imageInfo = null;

                try
                {
                    bool? ffmpegExists = null;
                    if (isDir || PackedImageLoader.Supports(zipPath))
                    {
                        Bitmap result;
                        if (isDir && SubfolderIsFullDisplayed() || !isDir && ArchiveLoadLevel == ItemLoadLevel.Full)
                        {
                            result = GetArchiveThumbnail(zipPath, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo);
                        }
                        else
                        {
                            if (!existsHeader)
                            {
                                getFileCount(out filecount, zipPath);
                            }
                            else
                            {
                                filecount = -1;
                            }
                            result = null;
                        }
                        /*
                        if (isDir && InRealDirectory)
                        {
                            bool notRegistered;
                            lock (folderWatchers)
                            {
                                notRegistered = !folderWatchers.ContainsKey(zipPath);
                                if (notRegistered) folderWatchers.Add(zipPath, null);
                            }
                            if (notRegistered)
                            {
                                var watcher = new FileSystemWatcher(zipPath,)
                            }
                        }
                        */
                        return result;
                    }
                    else if (ImageLoader.SupportsAtLeastThumbnailReading(zipPath, ref ffmpegExists))
                    {
                        var imageLoad = ImageLoadLevel == ItemLoadLevel.Full || ImageLoadLevel == ItemLoadLevel.Ignore;
                        var otherLoad = OtherLoadLevel == ItemLoadLevel.Full || OtherLoadLevel == ItemLoadLevel.Ignore;
                        bool loadThumbnail;
                        var isImage = true;
                        if (imageLoad && otherLoad)
                        {
                            loadThumbnail = true;
                        }
                        else
                        {
                            isImage = ImageLoader.SupportsImageAtLeastThumbnailReading(zipPath, ref ffmpegExists);
                            loadThumbnail = isImage ? imageLoad : otherLoad;
                        }

                        //if (ImageLoadLevel == ItemLoadLevel.Full)
                        if (loadThumbnail)
                        {
                            return GetImageThumbnail(zipPath, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo);
                        }
                        else
                        {
                            if (isImage && !existsHeader)
                            {
                                getImageHeader(out imageInfo, zipPath);
                            }
                            filecount = MetaPageCount_NotBook;
                            return null;
                        }
                    }
                    else if (MovieThumbnailLoader.Supports(zipPath) && (ffmpegExists ?? MovieThumbnailLoader.ffmpegExists()))
                    {
                        if (VideoLoadLevel == ItemLoadLevel.Full)
                        {
                            return GetMovieThumbnail(zipPath, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo, ref movieInfo);
                        }
                        else
                        {
                            if (!existsHeader)
                            {
                                getMovieHeader(out movieInfo, zipPath);
                            }
                            filecount = MetaPageCount_NotBook;
                            return null;
                        }
                    }
                    else
                    {
                        plainFile = true;
                        if (OtherLoadLevel == ItemLoadLevel.Full)
                        {
                            return GetOtherFileThumbnail(zipPath, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo);
                        }
                        else
                        {
                            filecount = MetaPageCount_NotBook;
                            return null;
                        }
                    }
                }
                catch
                {
                    loadError = LoadResult.LoadError;
                    imageInfo = null;
                    movieInfo = null;
                    filecount = MetaPageCount_NotBook;
                    if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                    var result = Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                    return result;
                }
            }
        }
        
        private static Func<TimeSpan, TimeSpan> getpositionProvider(string path)
        {
            if (path == null) return positionProviderForMovie;
            var info = new ZipPlaInfo(path);
            var ti = info.ThumbnailInfo;
            if (ti == null)
            {
                return positionProviderForMovie; // null にすると thumbnail フィルタ
            }
            else
            {
                return t => TimeSpan.FromSeconds(ti.Item1 + ti.Item2);
            }
        }

        private static int dataToFileCount(byte[] data)
        {
            using (var m = new MemoryStream(data))
            using (var r = new BinaryReader(m, Encoding.ASCII))
            {
                if (!r.ReadChars(4).SequenceEqual("BOOK")) throw new Exception("Not book data");
                return r.ReadInt32();
            }
        }

        private static void dataToBookData(byte[] data, out int fileCount, out bool zipPlaImageData)
        {
            using (var m = new MemoryStream(data))
            using (var r = new BinaryReader(m, Encoding.ASCII))
            {
                if (!r.ReadChars(4).SequenceEqual("BOOK")) throw new Exception("Not book data");
                fileCount = r.ReadInt32();
                zipPlaImageData = r.ReadBoolean();
            }
        }

        private static byte[] fileCountToData(int fileCount, bool zipPlaImageData)
        {
            using (var m = new MemoryStream())
            using (var w = new BinaryWriter(m, Encoding.ASCII))
            {
                w.Write("BOOK".ToCharArray());
                w.Write(fileCount);
                w.Write(zipPlaImageData);
                return m.ToArray();
            }
        }

        private Bitmap GetMovieThumbnail(string zipPath, BackgroundWorker backgroundWorker, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo, ref MovieInfo movieInfo, Func<TimeSpan, TimeSpan> positionProvider = null)
        {
            filecount = MetaPageCount_NotBook;
            try
            {
                fileSize = (new FileInfo(zipPath)).Length;
            }
            catch
            {
                fileSize = -1;
            }

            try
            {

                loadError = LoadResult.Success;
                if (positionProvider != null)
                {
                    using (var img = MovieThumbnailLoader.GetThumbnail(zipPath, sizeProviderForVideo, positionProvider, backgroundWorker, TimeSpan.FromSeconds(10), ref movieInfo))
                    {
                        //imageInfo = new ImageInfo(img);
                        imageInfo = null;
                        return DoJustClipping(img, needToResize: false);
                    }
                }
                else
                {
                    var info = new ZipPlaInfo(zipPath);
                    var ti = info.ThumbnailInfo;
                    int index;
                    if (ti == null || ti.Item1 < 0)
                    {
                        index = -1;
                    }
                    else
                    {
                        index = ti.Item1;
                    }

                    Bitmap result;
                    byte[] data;
                    Fraction thumbnailCachePixelRatio;
                    if (thumbnailCache != null && GPSizeThumbnail.TryGet(thumbnailCache, zipPath, index, tvCatalog.ThumbnailSize, currentClipMode == ClipMode.Letterbox, out result, out thumbnailCachePixelRatio, out data))
                    {
                        using (result)
                        {
                            imageInfo = null;
                            try
                            {
                                movieInfo = MovieInfo.FromData(data); // ここのミスをエラーにすると一度誤ったデータができると一旦消さない限り回復しなくなる
                                return DoJustClipping(result, needToResize: true, pixelRatio: thumbnailCachePixelRatio);
                            }
                            catch
                            {
                                // usingt と重複
                                //if (result != null) result.Dispose();
                            }
                        }
                    }

                    //throw new Exception();
                    var pp = index < 0 ? positionProviderForMovie : new Func<TimeSpan, TimeSpan>(t => TimeSpan.FromSeconds(index));
                    using (var img = MovieThumbnailLoader.GetThumbnail(zipPath, /*sizeProvider*/ null, pp, backgroundWorker, TimeSpan.FromSeconds(10), ref movieInfo))
                    {
                        //imageInfo = new ImageInfo(img);
                        imageInfo = null;
                        Bitmap resized;
                        Fraction resizedRatio;
                        if (thumbnailCache != null && GPSizeThumbnail.TrySet(thumbnailCache, zipPath, index, tvCatalog.ThumbnailSize, currentClipMode == ClipMode.Letterbox, true, img, movieInfo.SAR, movieInfo.ToData(), out resized, out resizedRatio))
                        {
                            try
                            {
                                return DoJustClipping(resized, needToResize: true, pixelRatio: resizedRatio);
                            }
                            finally
                            {
                                resized.Dispose();
                            }
                        }
                        else
                        {
                            return DoJustClipping(img, needToResize: true, pixelRatio: movieInfo.SAR);
                        }
                    }
                }
            }
            catch// (Exception e)
            {
                loadError = LoadResult.LoadError;
                //using (var g = Graphics.FromImage(result))
                //{
                // drawFileImage(g, result.Width, result.Height, DefaultFont, Brushes.Blue, Path.GetFileName(zipPath), zipPath, Brushes.Yellow);
                //}
                imageInfo = null;
                movieInfo = null;
                if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                var result = Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                return result;
                //return GetOtherFileThumbnail(zipPath, backgroundWorker, out filecount, out loadError, out fileSize, out imageInfo);
            }
        }

        private Size sizeProviderForVideo(Fraction srcFraction, Size size)
        {
            // srcFraction を Size にキャストすると極めて小さい比のようになるため
            // sizeProvider(Size srcSize, ClipMode localClipMode) が常にサムネイルにフィットしたサイズを返してしまう
            // return sizeProvider(srcFraction, currentClipMode);

            var sizeFraction = (Fraction)size;

            if (srcFraction == sizeFraction)
            {
                return sizeProvider(size, currentClipMode);
            }
            else if (srcFraction > sizeFraction)
            {
                return sizeProvider(new Size(size.Width, (size.Height * sizeFraction / srcFraction).FloorOfPlusHalf()), currentClipMode);
            }
            else
            {
                return sizeProvider(new Size((size.Width * srcFraction / sizeFraction).FloorOfPlusHalf(), size.Height), currentClipMode);
            }
        }

        private Size sizeProvider(Size srcSize, ClipMode localClipMode)
        {
            var tw = tvCatalog.ThumbnailWidth;
            var th = tvCatalog.ThumbnailHeight;
            var sw = srcSize.Width;
            var sh = srcSize.Height;

            /*
            switch (currentClipMode)
            {
                case ClipMode.Letterbox: return th * sw > tw * sh ? new Size(tw, (2 * sh * tw + sw) / (2 * sw)) : new Size((2 * sw * th + sh) / (2 * sh), th);
                default: return th * sw < tw * sh ? new Size(tw, (2 * sh * tw + sw) / (2 * sw)) : new Size((2 * sw * th + sh) / (2 * sh), th);
            }
            */

            bool land, port, lett;

            land = (2 * th - 1) * (2 * sw - 1) >= (2 * tw + 1) * (2 * sh + 1);
            port = (2 * th + 1) * (2 * sw + 1) <= (2 * tw - 1) * (2 * sh - 1);
            lett = localClipMode == ClipMode.Letterbox;

            // ソースのアスペクト比に誤差がなければこちらでも良い
            // キャッシュを使わない場合はこちらを採用するということも考えられるが、
            // 外部プログラムがアスペクト比に誤差を与えた場合にも
            // 隙間を埋める処理を行うのは悪い選択肢ではないと判断しコメントアウト
            /*
            land = (2 * th - 1) * sw >= (2 * tw + 1) * sh;
            port = (2 * th + 1) * sw <= (2 * tw - 1) * sh;
            lett = localClipMode == ClipMode.Letterbox;
            */

            if (land && lett || port && !lett)
            {
                return new Size(tw, (2 * sh * tw + sw) / (2 * sw));
            }
            else if (land && !lett || port && lett)
            {
                return new Size((2 * sw * th + sh) / (2 * sh), th);
            }
            else
            {
                return new Size(tw, th);
            }
        }


        private static TimeSpan positionProviderForMovie(TimeSpan srcPosition)
        {
            //return TimeSpan.FromSeconds(1);
            return TimeSpan.FromSeconds(srcPosition.TotalSeconds / 3);
        }

        private Bitmap GetOtherFileThumbnail(string zipPath, BackgroundWorker backgroundWorker, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo)
        {
            filecount = MetaPageCount_NotBook;
            fileSize = -1;
            imageInfo = null;
            try
            {
                loadError = LoadResult.FileNotFound;
                imageInfo = null;
                try
                {
                    fileSize = (new FileInfo(zipPath)).Length;
                }
                catch { }
                //using (var b = GetFileBackBrush(zipPath))
                var b = GetFileBackBrush(zipPath);
                {
                    return getImageWithFileIInfo(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight,
                        /*Brushes.LightGray*/ b);//,
                                                 //DefaultFont, Path.GetFileName(zipPath), zipPath);
                }
            }
            catch
            {
                loadError = LoadResult.LoadError;
                if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                var result = Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                //using (var g = Graphics.FromImage(result))
                //{
                //drawFileImage(g, result.Width, result.Height, DefaultFont, Brushes.Blue, Path.GetFileName(zipPath), zipPath, Brushes.Yellow);
                //}
                return result;
            }

        }

        private Bitmap GetImageThumbnail(string zipPath, BackgroundWorker backgroundWorker, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo)
        {
            filecount = MetaPageCount_NotBook;
            try
            {
                fileSize = (new FileInfo(zipPath)).Length;
            }
            catch
            {
                fileSize = -1;
            }
            try
            {
                Bitmap img;
                //if (thumbnailCache != null && ImageLoader.SupportsFullReading(zipPath, ffmpegExists: true) && ImageInfo.Supports(zipPath))
                if (thumbnailCache != null && ImageLoader.SupportsFullReading(zipPath, ffmpegExists: true))
                {
                    byte[] data;
                    if (!(GPSizeThumbnail.TryGet(thumbnailCache, zipPath, tvCatalog.ThumbnailSize, currentClipMode == ClipMode.Letterbox, out img, out data) && ImageInfo.TryParseData(data, out imageInfo)))
                    {
                        if (img != null) img.Dispose();
                        img = ImageLoader.GetFullBitmap(zipPath);
                        imageInfo = ImageInfo.Supports(zipPath) ? new ImageInfo(zipPath) : ImageLoader.GetImageInfo(img);
                        Bitmap img2;
                        if (GPSizeThumbnail.TrySet(thumbnailCache, zipPath, -1, tvCatalog.ThumbnailSize, currentClipMode == ClipMode.Letterbox,
                            !ImageLoader.IsLowLoad(zipPath), img, imageInfo.ToData(), out img2))
                        {
                            img.Dispose();
                            img = img2;
                        }
                    }
                    if (img == null) imageInfo = null;
                    //imageInfo = img != null ? new ImageInfo(zipPath) : null; // img からではなくバイナリから取得
                }
                else
                {
                    img = ImageLoader.GetAtLeastThumbnailBitmap(zipPath, tvCatalog.ThumbnailSize, true, out imageInfo);
                }

                if (img != null)
                {
                    using (img)
                    {
                        loadError = LoadResult.Success;
                        //var sw = new Stopwatch();sw.Start();
                        var result = DoJustClipping(img, needToResize: true);
                        //sw.Stop();MessageBox.Show($"{sw.Elapsed}");
                        return result;
                    }
                }
                else // サムネイルしかサポートしていない形式でサムネイルを持たないなど想定内の読み取りミスは例外を投げず null を返す
                {
                    loadError = LoadResult.NotYet;
                    return null;
                }
            }
            //catch (Exception e)
            catch
            {
                // MessageBox.Show(e.ToString());
                loadError = LoadResult.LoadError;
                imageInfo = null;
                if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                var result = Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                //using (var g = Graphics.FromImage(result))
                //{
                //drawFileImage(g, result.Width, result.Height, DefaultFont, Brushes.Blue, Path.GetFileName(zipPath), zipPath, Brushes.Yellow);
                //}
                return result;
            }
        }

        private Rectangle Round(RectangleF rect) { return new Rectangle((int)Math.Round(rect.X), (int)Math.Round(rect.Y), (int)Math.Round(rect.Width), (int)Math.Round(rect.Height)); }


        /*private Bitmap DoJustClippingQuickGraphic(Image src, bool needToResize, ClipMode? localClipMode = null)
        {
            var tvCatalogThumbnailSize = tvCatalog.ThumbnailSize;
            if (src != null && src.Size == tvCatalogThumbnailSize) return new Bitmap(src);

            var clipMode = localClipMode != null ? (ClipMode)localClipMode : currentClipMode;
            Bitmap result = new Bitmap(tvCatalogThumbnailSize.Width, tvCatalogThumbnailSize.Height, PixelFormat.Format24bppRgb);
            try
            {
                // 自前のアルゴリズムを使う方法
                switch (clipMode)
                {
                    case ClipMode.Letterbox:
                        {
                            //var zoom = Math.Min(result.Width / (float)src.Width, result.Height / (float)src.Height);
                            //var w = zoom * src.Width;
                            //var h = zoom * src.Height;
                            var size = sizeProvider(src.Size, clipMode);
                            var w = size.Width;
                            var h = size.Height;
                            var poorRect = new RectangleF((result.Width - w) / 2, (result.Height - h) / 2, w, h);
                            using (var g = Graphics.FromImage(result))
                            {
                                g.FillRectangle(Brushes.White, new RectangleF(new PointF(), result.Size));
                            }

                            if (needToResize)
                            {
                                // 説明用クリッピングなしサムネイルの作成
                                //g.DrawImage(src, poorRect, new RectangleF(new PointF(), src.Size), GraphicsUnit.Pixel);
                                QuickGraphic.DrawImage(result, poorRect, src, null);
                            }
                            else
                            {
                                //g.DrawImageUnscaledAndClipped(src, Round(poorRect));
                                using (var g = Graphics.FromImage(result))
                                {
                                    g.DrawImageUnscaled(src, (int)Math.Round(poorRect.X), (int)Math.Round(poorRect.Y));
                                }
                            }
                            break;
                        }*//*
                    case ClipMode.PanAndScan:
                        {
                            var zoomP = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);
                            var wP = result.Width / zoomP;
                            var hP = result.Height / zoomP;
                            var poorRectP = new RectangleF((src.Width - wP) / 2, (src.Height - hP) / 2, wP, hP);
                            if ((src.PixelFormat & PixelFormat.Alpha) != 0)
                            {
                                using (var g = Graphics.FromImage(result))
                                {
                                    g.FillRectangle(Brushes.White, new RectangleF(new PointF(), result.Size));
                                }
                            }
                            if (needToResize)
                            {
                                g.DrawImage(src, new RectangleF(new PointF(), result.Size), poorRectP, GraphicsUnit.Pixel);
                            }
                            else
                            {
                                //g.DrawImageUnscaledAndClipped(src, Round(poorRectP));
                                g.DrawImageUnscaled(src, -(int)Math.Round(poorRectP.X), -(int)Math.Round(poorRectP.Y));
                            }
                            break;
                        }
                    default:
                        {
                            var focusPoint = BitmapAnalyzer.GetFocus(src);
                            var zoom = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);
                            var iw = src.Width;
                            var ih = src.Height;
                            var w = result.Width / zoom;
                            var h = result.Height / zoom;
                            var plaRectP = new RectangleF(focusPoint.X - w / 2, focusPoint.Y - h / 2, w, h);
                            if (plaRectP.Left < 0) plaRectP.X = 0;
                            else if (plaRectP.Right > iw) plaRectP.X = iw - w;
                            if (plaRectP.Top < 0) plaRectP.Y = 0;
                            else if (plaRectP.Bottom > ih) plaRectP.Y = ih - h;
                            var p = new PointF((focusPoint.X - plaRectP.X) * zoom, (focusPoint.Y - plaRectP.Y) * zoom);
                            var r = (float)Math.Sqrt(result.Width * result.Height) / 10;
                            if ((src.PixelFormat & PixelFormat.Alpha) != 0)
                            {
                                using (var g = Graphics.FromImage(result))
                                {
                                    g.FillRectangle(Brushes.White, new RectangleF(new PointF(), result.Size));
                                }
                            }
                            if (needToResize)
                            {
                                //g.DrawImageUnscaledAndClipped(src, Round(plaRectP));
                                g.DrawImage(src, new RectangleF(new PointF(), result.Size), plaRectP, GraphicsUnit.Pixel);
                            }
                            else
                            {
                                g.DrawImageUnscaled(src, -(int)Math.Round(plaRectP.X), -(int)Math.Round(plaRectP.Y));
                            }
#if DEBUG
                                using (var pen = new Pen(Color.Cyan, r / 5))
                                {
                                    g.DrawEllipse(pen, new RectangleF(p.X - r, p.Y - r, 2 * r, 2 * r));
                                }
#endif
                            break;
                        }
                        *//*
                }
                return result;
            }
            catch
            {
                result.Dispose();
                throw;
            }
        }*/

        private Bitmap DoJustClipping(Bitmap src, bool needToResize, ClipMode? localClipMode = null)
        {
            return DoJustClipping(src, needToResize, 1, localClipMode);
        }
        private Bitmap DoJustClipping(Bitmap src, bool needToResize, Fraction pixelRatio, ClipMode? localClipMode = null)
        {
            if (pixelRatio == 0) pixelRatio = 1;

            var tvCatalogThumbnailSize = tvCatalog.ThumbnailSize;
            if (needToResize && pixelRatio == 1 && src != null && src.Size == tvCatalogThumbnailSize)
            {
                return DoJustClipping(src, needToResize: false, pixelRatio: 1, localClipMode: localClipMode);
            }

            var clipMode = localClipMode != null ? (ClipMode)localClipMode : currentClipMode;
            Bitmap result = new Bitmap(tvCatalogThumbnailSize.Width, tvCatalogThumbnailSize.Height, PixelFormat.Format24bppRgb);
            try
            {
                // 自前のアルゴリズムを使う方法
                using (var g = Graphics.FromImage(result))
                {
                    //g.PixelOffsetMode = System.Drawing.Drawing2D.PixelOffsetMode.Half;

                    switch (clipMode)
                    {
                        case ClipMode.Letterbox:
                            {
                                //var zoom = Math.Min(result.Width / (float)src.Width, result.Height / (float)src.Height);
                                //var w = zoom * src.Width;
                                //var h = zoom * src.Height;

                                // これで概ね良いが、絶対的なサイズに応じて無意味な隙間を埋める処理をするので
                                // 厳密には正しくない
                                //var size = sizeProvider((Fraction)src.Size * pixelRatio, clipMode);

                                // こちらが正しい
                                Size size;
                                if (pixelRatio > 1)
                                {
                                    size = sizeProvider(new Size(src.Width, (src.Height / pixelRatio).FloorOfPlusHalf()), clipMode);
                                }
                                else
                                {
                                    size = sizeProvider(new Size((src.Width * pixelRatio).FloorOfPlusHalf(), src.Height), clipMode);
                                }

                                var w = size.Width;
                                var h = size.Height;
                                var poorRect = new RectangleF((result.Width - w) / 2, (result.Height - h) / 2, w, h);
                                g.FillRectangle(SystemBrushes.Window/*Brushes.White*/, new RectangleF(new PointF(), result.Size));
                                if (needToResize)
                                {
                                    // 説明用クリッピングなしサムネイルの作成
                                    g.DrawImage(src, poorRect, new RectangleF(new PointF(), src.Size), GraphicsUnit.Pixel);
                                }
                                else
                                {
                                    //g.DrawImageUnscaledAndClipped(src, Round(poorRect));
                                    g.DrawImageUnscaled(src, (int)Math.Round(poorRect.X), (int)Math.Round(poorRect.Y));
                                }
                                break;
                            }
                        case ClipMode.PanAndScan:
                            {
                                var resultSize2 = (Size)((Fraction)result.Size / pixelRatio);
                                var zoomP = Math.Max(resultSize2.Width / (float)src.Width, resultSize2.Height / (float)src.Height);
                                var wP = resultSize2.Width / zoomP;
                                var hP = resultSize2.Height / zoomP;
                                var poorRectP = new RectangleF((src.Width - wP) / 2, (src.Height - hP) / 2, wP, hP);
                                if ((src.PixelFormat & PixelFormat.Alpha) != 0)
                                {
                                    g.FillRectangle(SystemBrushes.Window/*Brushes.White*/, new RectangleF(new PointF(), result.Size));
                                }
                                if (needToResize)
                                {
                                    g.DrawImage(src, new RectangleF(new PointF(), result.Size), poorRectP, GraphicsUnit.Pixel);
                                }
                                else
                                {
                                    //g.DrawImageUnscaledAndClipped(src, Round(poorRectP));
                                    g.DrawImageUnscaled(src, -(int)Math.Round(poorRectP.X), -(int)Math.Round(poorRectP.Y));
                                }
                                break;
                            }
                        default:
                            {
                                /*
                                var focusPoint = BitmapAnalyzer.GetFocus(src);
                                var zoom = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);
                                var iw = src.Width;
                                var ih = src.Height;
                                var w = result.Width / zoom;
                                var h = result.Height / zoom;
                                var plaRectP = new RectangleF(focusPoint.X - w / 2, focusPoint.Y - h / 2, w, h);
                                if (plaRectP.Left < 0) plaRectP.X = 0;
                                else if (plaRectP.Right > iw) plaRectP.X = iw - w;
                                if (plaRectP.Top < 0) plaRectP.Y = 0;
                                else if (plaRectP.Bottom > ih) plaRectP.Y = ih - h;
                                var p = new PointF((focusPoint.X - plaRectP.X) * zoom, (focusPoint.Y - plaRectP.Y) * zoom);
                                var r = (float)Math.Sqrt(result.Width * result.Height) / 10;
                                */

                                /*
                                var focusPoint = BitmapAnalyzer.GetFocus(src);
                                var zoom = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);
                                var invZoomHalf = 0.5f / zoom;
                                var iw = src.Width - invZoomHalf;
                                var ih = src.Height - invZoomHalf;
                                var w = result.Width / zoom - invZoomHalf;
                                var h = result.Height / zoom - invZoomHalf;
                                var plaRectP = new RectangleF(focusPoint.X - w / 2, focusPoint.Y - h / 2, w, h);
                                if (plaRectP.Left < 0) plaRectP.X = 0;
                                else if (plaRectP.Right > iw) plaRectP.X = iw - w;
                                if (plaRectP.Top < 0) plaRectP.Y = 0;
                                else if (plaRectP.Bottom > ih) plaRectP.Y = ih - h;
#if DEBUG
                                var p = new PointF((focusPoint.X - plaRectP.X) * zoom, (focusPoint.Y - plaRectP.Y) * zoom);
                                var r = (float)Math.Sqrt(result.Width * result.Height) / 10;
#endif
*/
                                /*
                                                                var focusPoint = BitmapAnalyzer.GetFocus(src);
                                                                var zoom = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);
                                                                var iw = src.Width;
                                                                var ih = src.Height;
                                                                var w = (int)Math.Round(result.Width / zoom);
                                                                var h = (int)Math.Round(result.Height / zoom);
                                                                var plaRectP = new Rectangle(focusPoint.X - w / 2, focusPoint.Y - h / 2, w, h);
                                                                if (plaRectP.Left < 0) plaRectP.X = 0;
                                                                else if (plaRectP.Right > iw) plaRectP.X = iw - w;
                                                                if (plaRectP.Top < 0) plaRectP.Y = 0;
                                                                else if (plaRectP.Bottom > ih) plaRectP.Y = ih - h;
#if DEBUG
                                                                var p = new PointF((focusPoint.X - plaRectP.X) * zoom, (focusPoint.Y - plaRectP.Y) * zoom);
                                                                var r = (float)Math.Sqrt(result.Width * result.Height) / 10;
#endif
                                */
                                var focusPoint = BitmapAnalyzer.GetFocus(src, pixelRatio);
                                var resultSize2 = (Size)((Fraction)result.Size / pixelRatio);
                                var zoom = Math.Max(resultSize2.Width / (float)src.Width, resultSize2.Height / (float)src.Height);
                                var iw = src.Width;
                                var ih = src.Height;

                                var w = resultSize2.Width / zoom;
                                var h = resultSize2.Height / zoom;
                                var plaRectP = new RectangleF(focusPoint.X - w / 2, focusPoint.Y - h / 2, w, h);
                                if (plaRectP.Left < 0) plaRectP.X = 0;
                                else if (plaRectP.Right > iw) plaRectP.X = iw - w;
                                if (plaRectP.Top < 0) plaRectP.Y = 0;
                                else if (plaRectP.Bottom > ih) plaRectP.Y = ih - h;
#if DEBUG
                                var p = new PointF((focusPoint.X - plaRectP.X) * result.Width / w, (focusPoint.Y - plaRectP.Y) * result.Height / h);
                                var r = (float)Math.Sqrt(result.Width * result.Height) / 10;
#endif
                                if ((src.PixelFormat & PixelFormat.Alpha) != 0)
                                {
                                    g.FillRectangle(SystemBrushes.Window/*Brushes.White*/, new RectangleF(new PointF(), result.Size));
                                }
                                if (needToResize)
                                {
                                    // このオフセットが厳密に正しいものと思われる
                                    // width や height が soruce と一致する場合にオフセットがなくても正常に描画されるので一見筋が通らないように思えるが、
                                    // 実験の結果、一致する場合は例外的な処理が行われるらしく、オフセットを仕掛けておけば常に期待通りの結果が得られる
                                    // レターボックスやパンスキャンではその例外処理が有効に働くのでオフセットは必須ではない

                                    var zoom2 = Math.Max(result.Width / (float)src.Width, result.Height / (float)src.Height);

                                    var pOffset = 0.5f * (1 / zoom2 - 1);
                                    plaRectP.Width -= pOffset;
                                    plaRectP.Height -= pOffset;
                                    g.DrawImage(src, new Rectangle(new Point(), result.Size), plaRectP, GraphicsUnit.Pixel);
                                }
                                else
                                {
                                    g.DrawImageUnscaled(src, -(int)Math.Round(0.0 + plaRectP.X), -(int)Math.Round(0.0 + plaRectP.Y));
                                }
#if DEBUG
                                using (var pen = new Pen(Color.Cyan, r / 5))
                                {
                                    g.DrawEllipse(pen, new RectangleF(p.X - r, p.Y - r, 2 * r, 2 * r));
                                }
#endif
                                break;
                            }
                    }
                    return result;
                }
            }
            catch
            {
                result.Dispose();
                throw;
            }
        }

        private Bitmap GetArchiveThumbnail(string zipPath, double ratio)
        {
            int fileCount;
            long fileSize;
            ImageInfo imageInfo;
            LoadResult loadError;
            return GetArchiveThumbnail(zipPath, null, -1, -1, (float)ratio, out fileCount, out loadError, out fileSize, out imageInfo);
        }

        private Bitmap GetArchiveThumbnail(string zipPath, BackgroundWorker backgroundWorker, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo)
        {
            return GetArchiveThumbnail(zipPath, backgroundWorker, tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight, -1, out filecount, out loadError, out fileSize, out imageInfo);
        }

        private static readonly bool SystemColorsWindowIsNearToWhite = ZipTag.NearToWhite(SystemColors.Window);
        private static Brush GetFileBackBrush(string path)
        {
            return SystemColorsWindowIsNearToWhite ? Brushes.LightGray : Brushes.DimGray;// Brushes.LightYellow;;
            //return SystemColorsWindowIsNearToWhite ? Brushes.LightGray : Brushes.MidnightBlue;// Brushes.LightYellow;;
            //return SystemBrushes.Window;
        }

        private static Brush GetDirectoryBackBrush(string path)
        {
            //return SystemColorsWindowIsNearToWhite ? Brushes.LightYellow : Brushes.SaddleBrown;// Brushes.LightYellow;;// Brushes.LightYellow;;
            return SystemColorsWindowIsNearToWhite ? Brushes.LightYellow : Brushes.DarkSlateGray;// Brushes.LightYellow;;// Brushes.LightYellow;;
        }

        private static Brush GetFileDirectoryForeBrush(string path)
        {
            return SystemColorsWindowIsNearToWhite ? Brushes.Black : Brushes.White;// Brushes.LightYellow;
        }

        private Bitmap GetArchiveThumbnail(string zipPath, BackgroundWorker backgroundWorker, int width, int height, double ratio, out int filecount, out LoadResult loadError, out long fileSize, out ImageInfo imageInfo)
        {
            var givenSize = width > 0 && height > 0;
            loadError = LoadResult.Success;
            Bitmap MaxPointImage = null;
            var isDirectory = false;
            fileSize = -1;
            try
            {
                isDirectory = Directory.Exists(zipPath);
                if (isDirectory)
                {
                    /*
                    if (CheckDirectorySize)
                    {
                        try
                        {
                            fileSize = Program.GetDirectoryFileSize(new DirectoryInfo(zipPath));
                        }
                        catch { } // アクセス禁止のサブフォルダがあるとサイズは取得できない
                    }
                    */
                }
                else
                {
                    fileSize = new FileInfo(zipPath).Length;
                }

                double MaxPoint = double.NegativeInfinity;
                RectangleF MaxPointRectangleF = RectangleF.Empty;
                double ReadNextDownPoint = 0;

                var filepath = Path.GetFileName(zipPath);
                var thumbnailInfo = (new ZipPlaInfo(filepath)).ThumbnailInfo;
                var bindingModeNullable = ZipPlaInfo.GetOnlyBindingModeFromFullName(zipPath);
                var bindingMode = bindingModeNullable == null ? currentBindingMode : (BindingMode)bindingModeNullable;

                var coverPage = thumbnailInfo?.Item1;

                var index = coverPage != null && coverPage >= 0 ? (int)coverPage : -1;
                var indexWithAIAInfo = getArchiveIndexWithAIAInfo(index);

                var singleMode = bindingMode == BindingMode.SinglePage || bindingMode == BindingMode.SinglePageWithoutScalingUp;

                ClipMode localClipMode = givenSize && index < 0 ? currentClipMode : ClipMode.PlaClip;
                if (localClipMode == ClipMode.PlaClip && singleMode) localClipMode = ClipMode.PanAndScan;

                var supportCache = givenSize && thumbnailCache != null;
                var fromCache = false;
                filecount = -1;
                var isZipPlaImageData = false;

                var requiredSize = Size.Empty;

                if (supportCache)
                {
                    // 1 : √2 を切り出して更に内側を切り出す処理をする場合、requiredRectangle はサムネイルサイズに
                    // 外接する 1: √2 の長方形になる。この場合も clipMode が letterBox であるかどうかの真理値は変わらない
                    if (localClipMode == ClipMode.PlaClip)
                    {
                        var tsW = tvCatalog.ThumbnailWidth;
                        var tsH = tvCatalog.ThumbnailHeight;
                        var tsWSqrt2 = tsW * Math.Sqrt(2);
                        if (tsWSqrt2 < tsH)
                        {
                            requiredSize = new Size((int)Math.Round(tsH / Math.Sqrt(2)), tsH);
                        }
                        else
                        {
                            requiredSize = new Size(tsW, (int)Math.Round(tsWSqrt2));
                        }
                    }
                    else
                    {
                        requiredSize = tvCatalog.ThumbnailSize;
                    }

                    /*
                    ClipMode localLocalClipMode;
                    if (givenSize && index < 0)
                    {
                        localLocalClipMode = currentClipMode;
                    }
                    else
                    {
                        localLocalClipMode = ClipMode.PlaClip;
                    }
                    */

                    Bitmap got;
                    byte[] data;
                    if (GPSizeThumbnail.TryGet(thumbnailCache, zipPath, indexWithAIAInfo,
                        requiredSize, localClipMode == ClipMode.Letterbox, out got, out data))
                    {
                        try
                        {
                            dataToBookData(data, out filecount, out isZipPlaImageData);
                            if (isZipPlaImageData && index != -1)
                            {
                                isZipPlaImageData = false;
                                throw new Exception();
                            }
                            MaxPointImage = got;
                            fromCache = true;
                        }
                        catch
                        {
                            if (got != null) got.Dispose();
                        }
                    }
                    //else throw new Exception();
                    data = null;
                }

                if (!fromCache)
                {
                    List<PackedImageLoader.PackedImageEntry> entries;
                    using (var loader = new PackedImageLoader(zipPath, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode))
                    {
                        /*
                        if (loader.Type != PackedImageLoader.PackType.Directory)
                        {
                            isDirectory = false;
                            fileSize = (new FileInfo(zipPath)).Length;
                        }
                        else
                        {
                            isDirectory = true;
                            try
                            {
                                fileSize = Program.GetDirectoryFileSize(new DirectoryInfo(zipPath));
                            }
                            catch { } // 下位フォルダにアクセス出来ない箇所があった場合のため
                        }
                        */
                        // http://www.weblio.jp/content/DllImport+Attribute LogicalStringComparer インスタンスはスレッドセーフのため新たに作成する
                        //var entries = loader.GetPackedImageEntries().OrderBy(entry => entry.Path, new LogicalStringComparer());
                        entries = loader.GetPackedImageEntries();
                        filecount = entries.Count;

                        //var byZipPlaImageFile = false;
                        //if (coverPage == null)
                        /*
                        if (index < 0) // ZipPlaImageFile は手動で作成することも想定されるので削除は手軽ではない。従って ZipPlaImage と ZipPlaInfo の情報が競合した場合後者が優先されるべきである。
                        {
                            for (var i = 0; i < filecount; i++)
                            {
                                if (isZipPlaCoverImageFile(entries[i].Path))
                                {
                                    index = i;
                                    //coverPage = i;
                                    //byZipPlaImageFile = true;
                                    break;
                                }
                            }
                        }
                        */
                        if (index >= 0)
                        {
                            if (backgroundWorker != null && backgroundWorker.CancellationPending)
                            {
                                imageInfo = null;
                                if (MaxPointImage != null) MaxPointImage.Dispose();
                                return null;
                            }
                            try
                            {
                                var image = loader.OpenImageStream(entries[index]);
                                try
                                {
                                    MaxPointImage = image;


                                    var v = thumbnailInfo?.Item2;


                                    MaxPointRectangleF = getCoverRectangleByRatioFromThumbnailInfo(givenSize ? Math.Sqrt(0.5) : ratio, MaxPointImage.Size, v);

                                    //MaxPointRectangleF = getCoverRectangleByGivenImageFromThumbnailInfo(width, height, MaxPointImage.Size, v);


                                    ///////////
                                    /*
                                    int ThumbnailWidth, ThumbnailHeight;
                                    if (givenSize)
                                    {
                                        ThumbnailWidth = width;
                                        ThumbnailHeight = height;
                                    }
                                    else
                                    {
                                        var origRatio = (double)MaxPointImage.Width / MaxPointImage.Height;
                                        if (origRatio < ratio)
                                        {
                                            ThumbnailWidth = MaxPointImage.Width;
                                            ThumbnailHeight = (int)Math.Round(ThumbnailWidth / ratio);
                                        }
                                        else
                                        {
                                            ThumbnailHeight = MaxPointImage.Height;
                                            ThumbnailWidth = (int)Math.Round(ThumbnailHeight * ratio);
                                        }
                                    }
                                    if (v == null)
                                    {
                                        MaxPointRectangleF = new RectangleF(0, 0, image.Width, image.Height);
                                    }
                                    else if (image.Width * (2 * ThumbnailHeight - 1) >= image.Height * (2 * ThumbnailWidth + 1))
                                    {
                                        var shortEdge = image.Height * ThumbnailWidth / (double)ThumbnailHeight;
                                        MaxPointRectangleF = new RectangleF((float)(v * (image.Width - shortEdge)), 0, (float)shortEdge, image.Height);
                                    }
                                    else if (image.Width * (2 * ThumbnailHeight + 1) <= image.Height * (2 * ThumbnailWidth - 1))
                                    {
                                        var shortEdge = image.Width * ThumbnailHeight / (double)ThumbnailWidth;
                                        MaxPointRectangleF = new RectangleF(0, (float)(v * (image.Height - shortEdge)), image.Width, (float)shortEdge);
                                    }
                                    else
                                    {
                                        MaxPointRectangleF = new RectangleF(0, 0, image.Width, image.Height);
                                    }
                                    */
                                    //////////
                                }
                                catch
                                {
                                    image.Dispose();
                                    throw;
                                }
                            }
                            catch (ArgumentException) { }
                            //localClipMode = ClipMode.PlaClip;
                            //localClipMode = byZipPlaImageFile ? currentClipMode : ClipMode.PlaClip;
                        }
                        else
                        {
                            // ZipPlaImageFile は手動で作成することも想定されるので削除は手軽ではない。従って ZipPlaImage と ZipPlaInfo の情報が競合した場合後者が優先されるべきである。
                            var zipPlaImageIndex = -1;
                            for (var i = 0; i < filecount; i++)
                            {
                                if (isZipPlaCoverImageFile(entries[i].Path))
                                {
                                    zipPlaImageIndex = i;
                                    //coverPage = i;
                                    //byZipPlaImageFile = true;
                                    break;
                                }
                            }

                            if (zipPlaImageIndex >= 0)
                            {

                                try
                                {
                                    var image = loader.OpenImageStream(entries[zipPlaImageIndex]);
                                    try
                                    {
                                        double point;
                                        RectangleF rect;
                                        GetImagePointAndEtc(out point, out rect, image, leftToRight: bindingMode == BindingMode.LeftToRight); // point はゼロ以下、SignlePage では rect は使われない
                                        if (MaxPointImage != null) MaxPointImage.Dispose();
                                        MaxPointImage = image;

                                        isZipPlaImageData = true;
                                        //MaxPointRectangleF = new RectangleF(new PointF(0, 0), MaxPointImage.Size);

                                        //MaxPoint = point;
                                        //MaxPointRectangleF = rect;
                                    }
                                    catch
                                    {
                                        image.Dispose();
                                        throw;
                                    }
                                }
                                catch (ArgumentException) { }
                            }
                            else
                            {

                                /*
                                if (givenSize)
                                {
                                    localClipMode = currentClipMode;
                                }
                                else
                                {
                                    localClipMode = ClipMode.PlaClip;
                                }
                                */
                                foreach (var entry in entries)
                                {
                                    if (backgroundWorker != null && backgroundWorker.CancellationPending)
                                    {
                                        imageInfo = null;
                                        if (MaxPointImage != null) MaxPointImage.Dispose();
                                        return null;
                                    }
                                    try
                                    {
                                        var image = loader.OpenImageStream(entry);
                                        if (localClipMode != ClipMode.PlaClip)
                                        {
                                            if (MaxPointImage != null) MaxPointImage.Dispose();
                                            MaxPointImage = image;
                                            break;
                                        }
                                        try
                                        {
                                            double point;
                                            RectangleF rect;
                                            GetImagePointAndEtc(out point, out rect, image, leftToRight: bindingMode == BindingMode.LeftToRight); // point はゼロ以下、SignlePage では rect は使われない
                                            point += ReadNextDownPoint;
                                            if (point > MaxPoint)
                                            {
                                                if (MaxPointImage != null) MaxPointImage.Dispose();
                                                MaxPointImage = image;
                                                MaxPoint = point;
                                                MaxPointRectangleF = rect;
                                            }
                                        }
                                        catch
                                        {
                                            image.Dispose();
                                            throw;
                                        }
                                        if (MaxPoint >= ReadNextDownPoint - 1) break;
                                    }
                                    catch (ArgumentException) { }
                                    ReadNextDownPoint--;
                                }
                                //localClipMode = currentClipMode;
                            }
                        }
                    }
                }
                else
                {
                    /*
                    if (givenSize && (coverPage != null && coverPage < filecount)
                    {
                        localClipMode = currentClipMode;
                    }
                    else
                    {
                        localClipMode = ClipMode.PlaClip;
                    }
                    */
                }

                if (backgroundWorker != null && backgroundWorker.CancellationPending)
                {
                    imageInfo = null;
                    if (MaxPointImage != null) MaxPointImage.Dispose();
                    return null;
                }

                if (MaxPointImage == null)
                {
                    if (width < 0 || height < 0) throw new Exception(Message.NoReadableFile);
                    loadError = LoadResult.FileNotFound;
                    imageInfo = null;
                    if (isDirectory)
                    {
                        //using (var b = GetDirectoryBackBrush(zipPath))
                        var b = GetDirectoryBackBrush(zipPath);
                        {
                            return getImageWithFileIInfo(width, height,
                                b);//,
                                   //DefaultFont, FileDirectoryForeBrush, Path.GetFileName(zipPath), zipPath);
                        }
                    }
                    else
                    {
                        //using (var b = GetFileBackBrush(zipPath))
                        var b = GetFileBackBrush(zipPath);
                        {
                            return getImageWithFileIInfo(width, height,
                                b);//,
                                   //DefaultFont, FileDirectoryForeBrush, Path.GetFileName(zipPath), zipPath);
                        }
                    }
                    //return Program.GetErrorImage(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight);
                }

                var resized = false;
                if (supportCache && !fromCache)
                {
                    Bitmap img2;
                    var mpiBitmap = MaxPointImage as Bitmap;
                    if (mpiBitmap != null)
                    {
                        if (GPSizeThumbnail.TrySet(thumbnailCache, zipPath, indexWithAIAInfo, requiredSize, localClipMode == ClipMode.Letterbox, true, mpiBitmap, fileCountToData(filecount, isZipPlaImageData), out img2))
                        {
                            MaxPointImage.Dispose();
                            MaxPointImage = img2;
                            resized = true;
                        }
                    }
                    else
                    {
                        using (mpiBitmap = new Bitmap(MaxPointImage))
                        {
                            if (GPSizeThumbnail.TrySet(thumbnailCache, zipPath, indexWithAIAInfo, requiredSize, localClipMode == ClipMode.Letterbox, true, mpiBitmap, fileCountToData(filecount, isZipPlaImageData), out img2))
                            {
                                MaxPointImage.Dispose();
                                MaxPointImage = img2;
                                resized = true;
                            }
                        }
                    }
                }

                if (resized || MaxPointRectangleF.IsEmpty)
                {
                    if (index >= 0)
                    {
                        var v = thumbnailInfo?.Item2;
                        //MaxPointRectangleF = getCoverRectangleByGivenImageFromThumbnailInfo(width, height, MaxPointImage.Size, v);
                        MaxPointRectangleF = getCoverRectangleByRatioFromThumbnailInfo(givenSize ? Math.Sqrt(0.5) : ratio, MaxPointImage.Size, v);
                    }
                    else if (isZipPlaImageData)
                    {
                        //MaxPointRectangleF = new RectangleF(new PointF(0, 0), MaxPointImage.Size);
                    }
                    else
                    {
                        double point;
                        GetImagePointAndEtc(out point, out MaxPointRectangleF, MaxPointImage, leftToRight: bindingMode == BindingMode.LeftToRight); // point はゼロ以下、SignlePage では rect は使われない
                    }
                }

                if (!givenSize)
                {
                    var origRatio = (double)MaxPointImage.Width / MaxPointImage.Height;
                    if (origRatio < ratio)
                    {
                        width = MaxPointImage.Width;
                        height = (int)Math.Round(width / ratio);
                    }
                    else
                    {
                        height = MaxPointImage.Height;
                        width = (int)Math.Round(height * ratio);
                    }

                }
                Bitmap canvas;
                if (isZipPlaImageData)
                {
                    var result = DoJustClipping(MaxPointImage, needToResize: true);
                    imageInfo = ImageLoader.GetImageInfo(MaxPointImage);
                    MaxPointImage.Dispose();
                    return result;
                }
                else if (localClipMode == ClipMode.PlaClip)
                {
                    canvas = new Bitmap(width, height, PixelFormat.Format24bppRgb);
                    try
                    {
                        using (var g = Graphics.FromImage(canvas))
                        {

                            ratio = (double)canvas.Width / canvas.Height;
                            Point focusPoint = Point.Empty;
                            float z = 0;
                            if (ratio < 0.7 || ratio > 0.714)
                            {
                                //throw new Exception();
                                z = Math.Min(MaxPointRectangleF.Width / canvas.Width, MaxPointRectangleF.Height / canvas.Height);
                                //var zHalf = z / 2;
                                var rectWidth = z * canvas.Width;// - zHalf;
                                var rectHeight = z * canvas.Height;// - zHalf;
                                focusPoint = BitmapAnalyzer.GetFocus(MaxPointImage, MaxPointRectangleF, pixelRatio: 1);
                                var newRect = new RectangleF(focusPoint.X - rectWidth / 2, focusPoint.Y - rectHeight / 2, rectWidth, rectHeight);
                                if (newRect.Left < MaxPointRectangleF.Left) newRect.X = MaxPointRectangleF.Left;
                                else if (newRect.Right > MaxPointRectangleF.Right) newRect.X = MaxPointRectangleF.Right - rectWidth;
                                if (newRect.Top < MaxPointRectangleF.Top) newRect.Y = MaxPointRectangleF.Top;
                                else if (newRect.Bottom > MaxPointRectangleF.Bottom) newRect.Y = MaxPointRectangleF.Bottom - rectHeight;
                                MaxPointRectangleF = newRect;

                            }
                            if ((MaxPointImage.PixelFormat & PixelFormat.Alpha) != 0)
                            {
                                g.FillRectangle(SystemBrushes.Window/*Brushes.White*/, new RectangleF(new PointF(), canvas.Size));
                            }
                            var pOffset = (z - 1) / 2;
                            g.DrawImage(MaxPointImage, new RectangleF(new PointF(), canvas.Size),
                                new RectangleF(MaxPointRectangleF.X, MaxPointRectangleF.Y, MaxPointRectangleF.Width - pOffset, MaxPointRectangleF.Height - pOffset), GraphicsUnit.Pixel);
#if DEBUG
                            var p = new PointF((focusPoint.X - MaxPointRectangleF.X) / z, (focusPoint.Y - MaxPointRectangleF.Y) / z);
                            var r = (float)Math.Sqrt(canvas.Width * canvas.Height) / 10;
                            using (var pen = new Pen(Color.Cyan, r / 5))
                            {
                                g.DrawEllipse(pen, new RectangleF(p.X - r, p.Y - r, 2 * r, 2 * r));
                            }
#endif
                        }
                    }
                    catch
                    {
                        canvas.Dispose();
                        throw;
                    }
                }
                else if (!givenSize) // givenSize でないのに PlaClip にならないのは SinglePage でフォルダのサムネイルを作る場合のみ
                {
                    // MaxPointImage はそのままでは保存できないケースがある
                    canvas = new Bitmap(MaxPointImage);
                }
                else
                {
                    canvas = DoJustClipping(MaxPointImage, needToResize: true, localClipMode: localClipMode);
                }
                imageInfo = ImageLoader.GetImageInfo(MaxPointImage);
                MaxPointImage.Dispose();

                /*
            Bitmap canvas = new Bitmap(tvCatalog.ThumbnailWidth, tvCatalog.ThumbnailHeight, PixelFormat.Format24bppRgb);
            try
            {
                // 自前のアルゴリズムを使う方法
                //Program.DrawBitmap(canvas, MaxPointImage, new Rectangle(new Point(), canvas.Size), new Rectangle((int)Math.Round(MaxPointRectangleF.X), (int)Math.Round(MaxPointRectangleF.Y), (int)Math.Round(MaxPointRectangleF.Width), (int)Math.Round(MaxPointRectangleF.Height)));

                /*
                using (var g = Graphics.FromImage(canvas))
                {
                    switch (localClipMode)
                    {
                        case ClipMode.Letterbox:
                            // 説明用クリッピングなしサムネイルの作成
                            var zoom = Math.Min(canvas.Width / (float)MaxPointImage.Width, canvas.Height / (float)MaxPointImage.Height);
                            var w = zoom * MaxPointImage.Width;
                            var h = zoom * MaxPointImage.Height;
                            var poorRect = new RectangleF((canvas.Width - w) / 2, (canvas.Height - h) / 2, w, h);
                            //using (var g = Graphics.FromImage(canvas))
                            {
                                g.FillRectangle(Brushes.White, new RectangleF(new PointF(), canvas.Size));
                                g.DrawImage(MaxPointImage, poorRect, new RectangleF(new PointF(), MaxPointImage.Size), GraphicsUnit.Pixel);
                            }
                            break;
                        case ClipMode.PanAndScan:
                            var zoomP = Math.Max(canvas.Width / (float)MaxPointImage.Width, canvas.Height / (float)MaxPointImage.Height);
                            var wP = canvas.Width / zoomP;
                            var hP = canvas.Height / zoomP;
                            var poorRectP = new RectangleF((MaxPointImage.Width - wP) / 2, (MaxPointImage.Height - hP) / 2, wP, hP);
                            //using (var g = Graphics.FromImage(canvas))
                            {
                                if ((MaxPointImage.PixelFormat & PixelFormat.Alpha) != 0)
                                {
                                    g.FillRectangle(Brushes.White, new RectangleF(new PointF(), canvas.Size));
                                }
                                g.DrawImage(MaxPointImage, new RectangleF(new PointF(), canvas.Size), poorRectP, GraphicsUnit.Pixel);
                            }
                            break;
                        case ClipMode.PlaClip:
                            //using (var g = Graphics.FromImage(canvas))
                            {
                                //g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.High;
                                //g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;

                                var ratio = (double)canvas.Width / canvas.Height;
                                Point focusPoint = Point.Empty;
                                float z = 0;
                                if (ratio < 0.7 || ratio > 0.714)
                                {
                                    //throw new Exception();
                                    z = Math.Min(MaxPointRectangleF.Width / canvas.Width, MaxPointRectangleF.Height / canvas.Height);
                                    var width = z * canvas.Width;
                                    var height = z * canvas.Height;
                                    focusPoint = BitmapAnalyzer.GetFocus(MaxPointImage, MaxPointRectangleF);
                                    var newRect = new RectangleF(focusPoint.X - width / 2, focusPoint.Y - height / 2, width, height);
                                    if (newRect.Left < MaxPointRectangleF.Left) newRect.X = MaxPointRectangleF.Left;
                                    else if (newRect.Right > MaxPointRectangleF.Right) newRect.X = MaxPointRectangleF.Right - width;
                                    if (newRect.Top < MaxPointRectangleF.Top) newRect.Y = MaxPointRectangleF.Top;
                                    else if (newRect.Bottom > MaxPointRectangleF.Bottom) newRect.Y = MaxPointRectangleF.Bottom - height;
                                    MaxPointRectangleF = newRect;

                                }
                                if ((MaxPointImage.PixelFormat & PixelFormat.Alpha) != 0)
                                {
                                    g.FillRectangle(Brushes.White, new RectangleF(new PointF(), canvas.Size));
                                }
                                g.DrawImage(MaxPointImage, new RectangleF(new PointF(), canvas.Size), MaxPointRectangleF, GraphicsUnit.Pixel);
#if DEBUG
                                var p = new PointF((focusPoint.X - MaxPointRectangleF.X) / z, (focusPoint.Y - MaxPointRectangleF.Y) / z);
                                var r = (float)Math.Sqrt(canvas.Width * canvas.Height) / 10;
                                using (var pen = new Pen(Color.Cyan, r / 5))
                                {
                                    g.DrawEllipse(pen, new RectangleF(p.X - r, p.Y - r, 2 * r, 2 * r));
                                }
#endif
                            }
                            break;
                    }
                    imageInfo = new ImageInfo(MaxPointImage);
                    MaxPointImage.Dispose();

                }
                
            }
            catch
                {
                    canvas.Dispose();
                    throw;
                }
                */

                return canvas;
            }
            catch (PasswordLockedException)
            {
                filecount = -1;

                if (MaxPointImage != null) MaxPointImage.Dispose();

                if (!givenSize) throw new Exception(Message.FailedToLoadFile);

                loadError = LoadResult.FileNotFound;// LoadResult.LoadError;
                imageInfo = null;
                if (isDirectory)
                {
                    var b = GetDirectoryBackBrush(zipPath);
                    //using (var b = GetDirectoryBackBrush(zipPath))
                    {
                        return getImageWithFileIInfo(width, height,
                            b);//,
                               //DefaultFont, FileDirectoryForeBrush, Path.GetFileName(zipPath), zipPath);
                    }
                }
                else
                {
                    var b = GetFileBackBrush(zipPath);
                    //using (var b = GetFileBackBrush(zipPath))
                    {
                        return getImageWithFileIInfo(width, height,
                            b);//,
                               // DefaultFont, FileDirectoryForeBrush, Path.GetFileName(zipPath), zipPath);
                    }
                }
            }
            catch (Exception error)
            {
                filecount = -1;

                if (MaxPointImage != null) MaxPointImage.Dispose();

                if (!givenSize) throw new Exception(Message.FailedToLoadFile);

                if (IgnoreFileError)
                {
                    loadError = LoadResult.LoadError;
                    imageInfo = null;
                    if (backgroundWorker != null && backgroundWorker.CancellationPending) return null;
                    var result = Program.GetErrorImage(width, height);
                    //using (var g = Graphics.FromImage(result))
                    //{
                    //drawFileImage(g, result.Width, result.Height, DefaultFont, Brushes.Blue, Path.GetFileName(zipPath), zipPath, Brushes.Yellow);
                    //}
                    return result;
                }
                else
                {
                    throw new Exception(zipPath + "\r\n\r\n" + Message.FileBroken, error);
                }
            }
        }


        private static RectangleF getCoverRectangleByRatioFromThumbnailInfo(double ratio, Size imageSize, double? fractionalPortion)
        {
            if (fractionalPortion == null)
            {
                return new RectangleF(0, 0, imageSize.Width, imageSize.Height);
            }
            else if (imageSize.Width >= imageSize.Height * ratio)
            {
                var shortEdge = imageSize.Height * ratio;
                return new RectangleF((float)(fractionalPortion * (imageSize.Width - shortEdge)), 0, (float)shortEdge, imageSize.Height);
            }
            else
            {
                var shortEdge = imageSize.Width / ratio;
                return new RectangleF(0, (float)(fractionalPortion * (imageSize.Height - shortEdge)), imageSize.Width, (float)shortEdge);
            }
        }

        /*
        private static RectangleF getCoverRectangleByGivenImageFromThumbnailInfo(int width, int height, Size imageSize, double? fractionalPortion)
        {
            //var givenSize = width > 0 && height > 0;
            int ThumbnailWidth, ThumbnailHeight;
            ThumbnailWidth = width;
            ThumbnailHeight = height;
            
            if (fractionalPortion == null)
            {
                return new RectangleF(0, 0, imageSize.Width, imageSize.Height);
            }
            else if (imageSize.Width * (2 * ThumbnailHeight - 1) >= imageSize.Height * (2 * ThumbnailWidth + 1))
            {
                var shortEdge = imageSize.Height * ThumbnailWidth / (double)ThumbnailHeight;
                return  new RectangleF((float)(fractionalPortion * (imageSize.Width - shortEdge)), 0, (float)shortEdge, imageSize.Height);
            }
            else if (imageSize.Width * (2 * ThumbnailHeight + 1) <= imageSize.Height * (2 * ThumbnailWidth - 1))
            {
                var shortEdge = imageSize.Width * ThumbnailHeight / (double)ThumbnailWidth;
                return new RectangleF(0, (float)(fractionalPortion * (imageSize.Height - shortEdge)), imageSize.Width, (float)shortEdge);
            }
            else
            {
                return new RectangleF(0, 0, imageSize.Width, imageSize.Height);
            }
        }
        */

        private static Size drawFileIconImage(Graphics g, Rectangle rect, string iconPath, DateTime lastWriteTime, bool isDir, bool isExist)
        {
            try
            {
                var img = SmartStaticIconProvider.GetSmall(iconPath, lastWriteTime, isDir);
                //g.DrawImage(img, rect.Right - img.Width, rect.Y); // 右上
                g.DrawImage(img, rect.Left, rect.Bottom - img.Height); // 左下
                return img.Size;

                /*
                using (var img = FileTypeManager.GetSmallIconBitmap(iconPath, useFileAttrinutes: !isExist))
                {
                    //g.DrawImage(img, rect.Right - img.Width, rect.Y); // 右上
                    g.DrawImage(img, rect.Left, rect.Bottom - img.Height); // 左下
                    return img.Size;
                }
                */
            }
            catch
            {
                return new Size(0, 0);
            }
        }
        /*
        private static Size drawFileIconImage(Graphics g, Rectangle rect, string iconPath, bool isExist)
        {
            Bitmap iconBitmap = null;
            if (!string.IsNullOrEmpty(iconPath))
            {
                try
                {
                    var iconImage = IconUtility.FileAssociatedImage(iconPath, isLarge: false, isExist: isExist);
                    if (iconImage != null)
                    {
                        try
                        {
                            iconBitmap = new Bitmap(iconImage);
                        }
                        finally
                        {
                            iconImage.Dispose();
                        }
                    }
                }
                catch
                {
                }
            }

            if (iconBitmap == null)
            {
                return new Size(0, 0);
            }

            try
            {
                //g.DrawImage(iconBitmap, rect.Right - iconBitmap.Width, rect.Y); // 右上
                g.DrawImage(iconBitmap, rect.Left, rect.Bottom - iconBitmap.Height); // 左下
                return iconBitmap.Size;
            }
            finally
            {
                iconBitmap.Dispose();
            }
        }
        */


        private static void drawFileImage(Graphics g, Rectangle rect, Font font, Brush foreBrush, string text, string iconPath, DateTime lastWriteTime, Brush backBrush, bool isDir, bool isExist)
        {
            try
            {
                //var icon = iconPath != null ? FileTypeManager.GetLargeIconBitmap(iconPath, useFileAttrinutes: !isExist) : null;
                var icon = iconPath != null ? SmartStaticIconProvider.GetLarge(iconPath, lastWriteTime, isDir) : null;
                //try
                {
                    var size = g.MeasureString(text, font, rect.Width);
                    size.Width += drawLeftMagin + drawRightMagin;
                    size.Height += drawTopMagin + drawBottomMagin;

                    RectangleF textRectangle;
                    if (icon == null)
                    {
                        textRectangle = new RectangleF(rect.X + Math.Max(0, (rect.Width - size.Width) / 2), rect.Y + Math.Max(0, (rect.Height - size.Height) / 2), size.Width, size.Height);
                    }
                    else
                    {
                        var margin = 10 * Program.DisplayMagnificationY;
                        g.DrawImage(icon, rect.X + (rect.Width - icon.Width) / 2, rect.Y + (int)((rect.Height - icon.Height) / 2 + 0.5));
                        textRectangle = new RectangleF(rect.X + Math.Max(0, (rect.Width - size.Width) / 2), rect.Y + Math.Max(0, (rect.Height + icon.Height) / 2 + margin), size.Width, size.Height);
                    }
                    if (backBrush != null)
                    {
                        g.FillRectangle(backBrush, textRectangle);
                    }
                    g.DrawString(text, font, foreBrush, new RectangleF(textRectangle.X + drawLeftMagin, textRectangle.Y + drawTopMagin,
                        textRectangle.Width - (drawLeftMagin + drawRightMagin), textRectangle.Height - (drawTopMagin + drawBottomMagin)));
                }
                //finally
                {
                    //icon?.Dispose();
                }
            }
            catch
            {
            }
        }

        /*
    private static void drawFileImage(Graphics g, Rectangle rect, Font font, Brush foreBrush, string text, string iconPath = null, Brush backBrush = null)
    {
        Bitmap iconBitmap = null;
        if (!string.IsNullOrEmpty(iconPath))
        {
            try
            {
                var iconImage = IconUtility.FileAssociatedImage(iconPath, true, true);
                if (iconImage != null)
                {
                    try
                    {
                        iconBitmap = new Bitmap(iconImage);
                    }
                    finally
                    {
                        iconImage.Dispose();
                    }
                }
                //using (var icon = Icon.ExtractAssociatedIcon(iconPath)) { iconBitmap = icon.ToBitmap();  }
            }
            catch
            {
            }
        }

        try
        {
            var size = g.MeasureString(text, font, rect.Width);
            size.Width += drawLeftMagin + drawRightMagin;
            size.Height += drawTopMagin + drawBottomMagin;

            RectangleF textRectangle;
            if (iconBitmap == null)
            {
                textRectangle = new RectangleF(rect.X + Math.Max(0, (rect.Width - size.Width) / 2), rect.Y + Math.Max(0, (rect.Height - size.Height) / 2), size.Width, size.Height);
            }
            else
            {
                var margin = 10 * Program.DisplayMagnificationY;
                g.DrawImage(iconBitmap, rect.X + (rect.Width - iconBitmap.Width) / 2, rect.Y + (int)((rect.Height - iconBitmap.Height) / 2 + 0.5));
                textRectangle = new RectangleF(rect.X + Math.Max(0, (rect.Width - size.Width) / 2), rect.Y + Math.Max(0, (rect.Height + iconBitmap.Height) / 2 + margin), size.Width, size.Height);
            }
            if (backBrush != null)
            {
                g.FillRectangle(backBrush, textRectangle);
            }
            g.DrawString(text, font, foreBrush, new RectangleF(textRectangle.X + drawLeftMagin, textRectangle.Y + drawTopMagin,
                textRectangle.Width - (drawLeftMagin + drawRightMagin), textRectangle.Height - (drawTopMagin + drawBottomMagin)));
        }
        finally
        {
            iconBitmap?.Dispose();
        }
    }
    */

        private static Bitmap getImageWithFileIInfo(int width, int height, Brush backBrush)
        {
            Bitmap result = new Bitmap(width, height);

            using (var g = Graphics.FromImage(result))
            {
                g.FillRectangle(backBrush, 0, 0, width, height);
                //drawFileImage(g, width, height, font, foreBrush, text, iconPath);
            }
            return result;
        }

        private const int drawLeftMagin = 0;
        private const int drawRightMagin = -1;
        private const int drawTopMagin = 1;
        private const int drawBottomMagin = 0;

        private static void drawSimpleString(Graphics g, string str, Font font, Rectangle rect, Color foreColor, Brush backBrush, Dictionary<string, Size> sizeDictionary)
        {
            //var paintSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont);
            //var stringSize = TextRenderer.MeasureText(g, str, font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
            var stringSize = MeasureStringSizeByTextRenderer(g, str, font, sizeDictionary);

            //var sizeBack = new Size((int)(stringSize.Width + 0.5) + drawLeftMagin + drawRightMagin, (int)(stringSize.Height + 0.5) + drawTopMagin + drawBottomMagin);
            //var rectBack = new Rectangle(rect.X, rect.Y, stringSize.Width + TextRenderer.MeasureText(g, "★", font).Width / 2, stringSize.Height * 4 / 3);
            var rectBack = new Rectangle(rect.X, rect.Y, stringSize.Width + MeasureStringSizeByTextRenderer(g, str, font, sizeDictionary).Width / 2, stringSize.Height * 4 / 3);
            //var rectBack = new Rectangle(rect.X, rect.Y, sizeBack.Width, sizeBack.Height);
            var rectFore = rectBack;
            rectFore.X += (rectBack.Width - stringSize.Width) / 2;
            g.FillRectangle(backBrush, rectBack);
            TextRenderer.DrawText(g, str, font, rectFore, foreColor, TextFormatFlags.NoPadding | TextFormatFlags.VerticalCenter | TextFormatFlags.NoPrefix);
        }

        private static Size MeasureStringSizeByTextRenderer(Graphics g, string str, Font font, Dictionary<string, Size> sizeDictionary)
        {
            Size result;
            if (!sizeDictionary.TryGetValue(str, out result))
            {
                result = TextRenderer.MeasureText(g, str, font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                sizeDictionary[str] = result;
            }
            return result;
        }

        public Rectangle drawRating_Bound0 = Rectangle.Empty;
        public Rectangle drawRating_Bound = Rectangle.Empty;
        public Rectangle drawRating_StarsBound = Rectangle.Empty;
        private bool drawRating_StarSizeNotSet = true;
        //private Size drawRating_PaintSize;
        private Size drawRating_FiveStarSize;
        private Point drawRating_FiveStarLocation;
        private int[] drawRating_PartStarSizesWidth;

        private void drawRating(Graphics g, Rectangle rect, ZipPlaInfo zipPlaInfo) { drawRating(g, rect, zipPlaInfo.Rating); }
        private void drawRating(Graphics g, Rectangle rect, int? rating)
        {
            if (rating == null) rating = 0;
            var r = (int)rating;
            r = Math.Max(0, Math.Min(5, r));
            var font = DefaultFont;

            if (drawRating_StarSizeNotSet)
            {
                drawRating_StarSizeNotSet = false;

                var fiveStarRect = RainbowDataGridViewTextBoxCell.GetCharRectangle("★★★★★", font, TextFormatFlags.NoPadding, onlyHorizontal: false);
                //MessageBox.Show(fiveStarRect.ToString());
                var frameLeft = Program.DpiScaling(3);
                var frameRight = frameLeft;
                var frameTop = Program.DpiScaling(2);
                var frameBottom = frameLeft;
                drawRating_FiveStarSize = fiveStarRect.Size;
                drawRating_FiveStarLocation = new Point(frameLeft - fiveStarRect.X, frameTop - fiveStarRect.Y);

                drawRating_Bound0 = new Rectangle(0, 0, drawRating_FiveStarSize.Width + frameLeft + frameRight, drawRating_FiveStarSize.Height + frameTop + frameBottom);

                //drawRating_PaintSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont);
                //drawRating_FiveStarSize = fiveStarSize.Width; // TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;

                drawRating_PartStarSizesWidth = new int[6]
                {
                    TextRenderer.MeasureText(g, "", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                };

            }

            //var paintSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont);
            //var fiveStarsSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);
            var partStars = "★★★★★".Substring(0, r);
            //var partStarsSize = TextRenderer.MeasureText(g, partStars, DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);

            //var rectBack = new Rectangle(rect.X, rect.Y, drawRating_PaintSize.Width, drawRating_PaintSize.Height * 4 / 3);
            var rectBack = new Rectangle(rect.Location, drawRating_Bound0.Size);
            var rectFore = rectBack;
            rectFore.X += drawRating_FiveStarLocation.X; //(rectBack.Width - drawRating_FiveStarSize.Width) / 2;
            rectFore.Y += drawRating_FiveStarLocation.Y;
            //rectFore.X += TextRenderer.MeasureText(g, ",", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;

            if (!rect.Contains(rectBack))
            {
                drawRating_Bound = Rectangle.Empty;
                drawRating_StarsBound = Rectangle.Empty;
                return;
            }

            g.FillRectangle(Brushes.Black, rectBack);
            TextRenderer.DrawText(g, partStars, DefaultFont, rectFore, Color.Gold, TextFormatFlags.NoPadding);// | TextFormatFlags.VerticalCenter);
            rectFore.X += drawRating_PartStarSizesWidth[r];
            TextRenderer.DrawText(g, "★★★★★".Substring(r), DefaultFont, rectFore, Color.LightSlateGray, TextFormatFlags.NoPadding);// | TextFormatFlags.VerticalCenter);

            drawRating_Bound = drawRating_Bound0;
            drawRating_StarsBound = new Rectangle((rectBack.Width - drawRating_FiveStarSize.Width) / 2, 0, drawRating_FiveStarSize.Width, drawRating_FiveStarSize.Height);

            //drawRating_Bound = new Rectangle(0, 0, drawRating_PaintSize.Width, drawRating_PaintSize.Height * 4 / 3);
            //drawRating_StarsBound = new Rectangle((rectBack.Width - drawRating_FiveStarSizeWidth) / 2, 0, drawRating_FiveStarSizeWidth, drawRating_PaintSize.Height);
            /*
            var baseLabel = "★★★★★";
            var label = ""; for (var i = 0; i < rating; i++) label += "★";
            var labelSizeF = g.MeasureString(baseLabel, font);
            var labelSize = new Size((int)(labelSizeF.Width + 0.5) + drawLeftMagin + drawRightMagin, (int)(labelSizeF.Height + 0.5) + drawTopMagin + drawBottomMagin);
            g.FillRectangle(Brushes.Black, rect.X, rect.Y, labelSize.Width, labelSize.Height);
            g.DrawString(baseLabel, font, Brushes.LightSlateGray, drawLeftMagin + rect.X, drawTopMagin + rect.Y);
            g.DrawString(label, font, Brushes.Gold, drawLeftMagin + rect.X, drawTopMagin + rect.Y);

            drawRating_Bound = new Rectangle(0, 0, labelSize.Width, labelSize.Height);
            //DrowRating_StarsBound = new Rectangle()
            //g.DrawString("☆☆☆☆☆", font, Brushes.Black, drawLeftMagin, drawTopMagin);
            */
        }

        /*
        private void drawRatingOld(Graphics g, Rectangle rect, int? rating)
        {
            if (rating == null) rating = 0;
            var r = (int)rating;
            r = Math.Max(0, Math.Min(5, r));
            var font = DefaultFont;

            if(drawRating_StarSizeNotSet)
            {
                drawRating_StarSizeNotSet = false;
                drawRating_PaintSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont);
                drawRating_FiveStarSizeWidth = TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                drawRating_PartStarSizesWidth = new int[6]
                {
                    TextRenderer.MeasureText(g, "", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                    TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width,
                };
            }

            //var paintSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont);
            //var fiveStarsSize = TextRenderer.MeasureText(g, "★★★★★", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);
            var partStars = "★★★★★".Substring(0, r);
            //var partStarsSize = TextRenderer.MeasureText(g, partStars, DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);

            var rectBack = new Rectangle(rect.X, rect.Y, drawRating_PaintSize.Width, drawRating_PaintSize.Height * 4 / 3);
            var rectFore = rectBack;
            rectFore.X += (rectBack.Width - drawRating_FiveStarSizeWidth) / 2;
            //rectFore.X += TextRenderer.MeasureText(g, ",", DefaultFont, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;

            if (!rect.Contains(rectBack))
            {
                drawRating_Bound = Rectangle.Empty;
                drawRating_StarsBound = Rectangle.Empty;
                return;
            }

            g.FillRectangle(Brushes.Black, rectBack);
            TextRenderer.DrawText(g, partStars, DefaultFont, rectFore, Color.Gold, TextFormatFlags.NoPadding | TextFormatFlags.VerticalCenter);
            rectFore.X += drawRating_PartStarSizesWidth[r];
            TextRenderer.DrawText(g, "★★★★★".Substring(r), DefaultFont, rectFore, Color.LightSlateGray, TextFormatFlags.NoPadding | TextFormatFlags.VerticalCenter);


            drawRating_Bound = new Rectangle(0, 0, drawRating_PaintSize.Width, drawRating_PaintSize.Height * 4 / 3);
            drawRating_StarsBound = new Rectangle((rectBack.Width - drawRating_FiveStarSizeWidth) / 2, 0, drawRating_FiveStarSizeWidth, drawRating_PaintSize.Height);
        }
        */

        private static SizeF MeasureStringSizeByGraphics(Graphics g, string str, Font font, Dictionary<string, SizeF> sizeDictionary)
        {
            SizeF result;
            if (!sizeDictionary.TryGetValue(str, out result))
            {
                result = g.MeasureString(str, font);
                sizeDictionary[str] = result;
            }
            return result;
        }

        private readonly Dictionary<string, SizeF> drawTags_sizeDictionary = new Dictionary<string, SizeF>();
        private void drawTags(Graphics g, Rectangle rect, ZipPlaInfo zipPlaInfo, Size iconSize)
        {
            var tagNames = zipPlaInfo.TagArray;
            if (tagNames == null) return;

            var leftBorder = rect.X + iconSize.Width;

            var tags = Tags;
            if (tags == null) tags = new ZipTag[0];

            var font = DefaultFont;
            var bottommRight = new Point(rect.Right, rect.Bottom);
            for (var i = tagNames.Length - 1; i >= 0; i--)
            {
                var tagName = tagNames[i];
                var tag = tags.FirstOrDefault(t => t.Name == tagName);
                if (tag == default(ZipTag)) continue;

                var labelSizeF = MeasureStringSizeByGraphics(g, tagName, font, drawTags_sizeDictionary);
                var labelSize = new Size((int)(labelSizeF.Width + 0.5) + drawLeftMagin + drawRightMagin, (int)(labelSizeF.Height + 0.5) + drawTopMagin + drawBottomMagin);
                if (bottommRight.X < rect.Right && bottommRight.X < leftBorder + labelSize.Width)
                {
                    bottommRight.X = rect.Right;
                    bottommRight.Y -= labelSize.Height;

                    if (bottommRight.Y <= rect.Bottom - iconSize.Height)
                    {
                        leftBorder = rect.X;
                    }
                }
                var topLeft = new Point(bottommRight.X - labelSize.Width, bottommRight.Y - labelSize.Height);
                var labelRect = new Rectangle(topLeft, labelSize);
                if (labelRect.Left < leftBorder) labelRect.X = leftBorder;
                var fullDisplayed = rect.Contains(labelRect);
                Rectangle original = Rectangle.Empty;
                if (!fullDisplayed)
                {
                    original = labelRect;
                    labelRect.Intersect(rect);
                }

                using (var b = new SolidBrush(tag.BackColor))
                {
                    g.FillRectangle(b, labelRect);
                }

                var stringRect = new Rectangle(labelRect.X + drawLeftMagin, labelRect.Y + drawTopMagin,
                    labelRect.Width - drawLeftMagin - drawRightMagin, labelRect.Height - drawTopMagin - drawBottomMagin);

                using (var b = new SolidBrush(tag.ForeColor))
                {
                    //g.DrawString(tagName, font, b, Math.Max(0, topLeft.X) + drawLeftMagin, topLeft.Y + drawTopMagin);
                    if (fullDisplayed)
                    {
                        g.DrawString(tagName, font, b, stringRect.Location);
                    }
                    else
                    {
                        var canvasWidth = (int)Math.Ceiling(labelSizeF.Width);
                        var canvasHeight = (int)Math.Ceiling(labelSizeF.Height);
                        if (canvasWidth > 0 && canvasHeight > 0)
                        {
                            using (var canvas = new Bitmap(canvasWidth, canvasHeight))
                            {
                                using (var gc = Graphics.FromImage(canvas))
                                {
                                    gc.DrawString(tagName, font, b, 0, 0);
                                }
                                if (stringRect.Right > labelRect.Right) stringRect.Width = labelRect.Right - stringRect.Left;
                                g.DrawImageUnscaledAndClipped(canvas, stringRect);
                            }
                        }
                    }
                }

                bottommRight.X -= labelSize.Width;
            }
        }

        // point はゼロ以下
        private void GetImagePointAndEtc(out double point, out RectangleF clip, Bitmap image, bool leftToRight)
        {
            var thumbWidth = tvCatalog.ThumbnailWidth;
            var thumbHeight = tvCatalog.ThumbnailHeight;

            var blankAvoidRectangle = Program.GetBlankAvoidRectangle(image, thumbWidth, thumbHeight, 20, true);

            //MessageBox.Show($"{image.Width} {image.Height}\n{blankAvoidRectangle.X} {blankAvoidRectangle.Y} {blankAvoidRectangle.Width} {blankAvoidRectangle.Height}");

            point = 0;
            if (blankAvoidRectangle == Rectangle.Empty)
            {
                point = -3.75;
                blankAvoidRectangle = new Rectangle(0, 0, image.Width, image.Height);
            }

            float dstWidth, dstHeight;
            if (2 * thumbHeight + 1 <= Math.Sqrt(2) * (2 * thumbWidth - 1))
            {
                dstWidth = thumbWidth;
                dstHeight = (float)(Math.Sqrt(2) * thumbWidth);
            }
            else if (2 * thumbHeight - 1 >= Math.Sqrt(2) * (2 * thumbWidth + 1))
            {
                dstWidth = (float)(Math.Sqrt(1 / 2.0) * thumbHeight);
                dstHeight = thumbHeight;
            }
            else
            {
                dstWidth = thumbWidth;
                dstHeight = thumbHeight;
            }

            float srcWidth = blankAvoidRectangle.Width;
            float srcHeight = blankAvoidRectangle.Height;

            const float AspectRatio = 148f / 210f;
            const float ThickRatio = 15f / 210f;
            //const float ArmRatio = 85f / 210f;
            //const float ArmRatio = 82f / 210f;
            const float ArmRatio = 75f / 210f;

            var dstAsp = dstWidth / dstHeight;
            var dstTck = dstAsp * (ThickRatio / AspectRatio);
            var dstArm = dstAsp * (ArmRatio / AspectRatio);

            var srcAsp = srcWidth / srcHeight;

            float cutPerOpposite;

            // 最も近いもので決め打ち
            if (srcAsp < dstAsp)
            {
                cutPerOpposite = (1 / srcAsp - 1 / dstAsp) / 2;
            }
            else if (srcAsp < dstAsp + (dstTck + dstArm) * 0.5)
            {
                cutPerOpposite = 0;
            }
            else if (srcAsp < dstArm + dstAsp + 0.5 * dstTck)
            {
                cutPerOpposite = srcAsp - dstAsp;
            }
            //else if (srcAsp < dstAsp + dstTck + (dstArm + dstAsp)*0.5)
            else if (srcAsp < dstAsp + dstTck + dstArm * 0.45 + dstAsp * 0.55) // ここは非常にシビア
            {
                cutPerOpposite = srcAsp - dstAsp - dstTck;
            }
            else if (srcAsp < dstAsp + dstTck + dstAsp + 0.5 * dstArm)
            {
                cutPerOpposite = 0;
            }
            else if (srcAsp < dstArm + dstAsp + dstTck + dstAsp + dstArm * 0.15)
            {
                cutPerOpposite = srcAsp - 2 * dstAsp - dstTck;
                //cutPerOpposite = dstArm;
            }
            /*
            else if (srcAsp < dstArm + dstAsp + dstTck + dstAsp + dstArm)
            {
                cutPerOpposite = dstArm;
            }*/
            else
            {
                cutPerOpposite = (srcAsp - dstTck - 2 * dstAsp) / 2;
            }

            // 単純に線形補間
            /*
            if (srcAsp < dstAsp)
            {
                cutPerOpposite = (1 / srcAsp - 1 / dstAsp)/2;
            }
            else if (srcAsp < dstAsp + dstTck)
            {
                cutPerOpposite = 0;
            }
            else if (srcAsp < dstArm + dstAsp)
            {
                cutPerOpposite = (srcAsp - dstAsp - dstTck) / (dstArm - dstTck) * dstArm;
            }
            else if (srcAsp < dstArm + dstAsp + dstTck)
            {
                cutPerOpposite = dstArm;
            }
            else if (srcAsp < dstAsp + dstTck + dstAsp)
            {
                cutPerOpposite = (srcAsp - 2 * dstAsp - dstTck) / (dstArm - dstAsp) * dstArm;
            }
            else if (srcAsp < dstArm + dstAsp + dstTck + dstAsp)
            {
                cutPerOpposite = srcAsp - 2 * dstAsp - dstTck;
            }
            else if (srcAsp < dstArm + dstAsp + dstTck + dstAsp + dstArm)
            {
                cutPerOpposite = dstArm;
            }
            else
            {
                cutPerOpposite = (srcAsp - dstTck - 2 * dstAsp) / 2;
            }
            */

            if (srcAsp < dstAsp)
            {
                clip = new RectangleF(blankAvoidRectangle.X, blankAvoidRectangle.Y + srcWidth * cutPerOpposite, srcWidth, srcWidth * dstHeight / dstWidth);
            }
            else
            {
                if (leftToRight) cutPerOpposite = srcAsp - cutPerOpposite - dstAsp;
                clip = new RectangleF(blankAvoidRectangle.X + srcHeight * cutPerOpposite, blankAvoidRectangle.Y, srcHeight * dstWidth / dstHeight, srcHeight);
            }

            //blankAvoidRectangle.Width--;
            //blankAvoidRectangle.Height--;
            //clip.Intersect(blankAvoidRectangle);

            // 最も近いもので決め打ち
            if (srcAsp < 0.7 * dstAsp || srcAsp > 1.4 * (dstArm + dstAsp + dstTck + dstAsp + dstArm))
            {
                point -= 2.5;
            }
        }

        private static string getPathWithoutSeparator(string path)
        {
            if (path == null) return null;
            var length = path.Length;
            if (length >= 2 && path.EndsWith(Path.DirectorySeparatorChar.ToString()) && !path.EndsWith(Path.DirectorySeparatorChar.ToString() + Path.DirectorySeparatorChar))
            {
                return path.Substring(0, length - 1);
            }
            else
            {
                return path;
            }
        }

        public static string GetDirectoryOrRootFullPath(string path)
        {
            return getPathWithoutSeparator(Path.GetFullPath(GetDirectoryPathWithSeparator(path)));
        }

        public static bool IsSupportedByCatalogFormExceptFolder(string fileName)
        {
            if (fileName == null) return false;
            return VirtualFolder.IsBookmarkPath(fileName) || SmartFolder.IsSmartFolderPath(fileName) || PackedImageLoader.Supports(fileName) ||
                    (MovieThumbnailLoader.Supports(fileName) && MovieThumbnailLoader.ffmpegExists());
        }


        private static bool IsSupportedByCatalogFormAndExists(string fileName, out bool isDir)
        {
            isDir = false;
            if (fileName == null) return false;
            try
            {
                return (isDir = Directory.Exists(fileName)) || (File.Exists(fileName) && IsSupportedByCatalogFormExceptFolder(fileName));
            }
            catch
            {
                return false;
            }
        }

        private static bool IsSupportedByCatalogFormAndExists(string fileName)
        {
            if (fileName == null) return false;
            try
            {
                return Directory.Exists(fileName) || (File.Exists(fileName) && IsSupportedByCatalogFormExceptFolder(fileName));
            }
            catch
            {
                return false;
            }
        }

        object ZipPathArrayLocker = new object();
        class PackedImageLoaderWithEntries : IDisposable
        {
            public PackedImageLoaderWithEntries(PackedImageLoader loader, bool needToExecOnTask = false)
            {
                PackedImageLoader = loader;
                Entries = loader.GetPackedImageEntries(PackedImageLoaderFileInfo.All, needToExecOnTask).ToArray(); //.OrderBy(entry => entry.Path, new LogicalStringComparer()).ToArray();
            }
            public PackedImageLoader PackedImageLoader;
            public PackedImageLoader.PackedImageEntry[] Entries;

            public void Dispose()
            {
                if (PackedImageLoader != null)
                {
                    PackedImageLoader.Dispose();
                    PackedImageLoader = null;
                }
            }
        }
        PackedImageLoaderWithEntries loadingPackedImageLoader = null;
        readonly object loadingPackedImageLoaderLocker = new object();
        bool CreatingZipPathArray = false;
        string[] ZipPathArray;
        string[] ZipNameArray;
        int[] ZipPageArray;
        DateTime[] CreateTimeArray;
        DateTime[] LastAccessTimeArray;
        DateTime[] ModifiedTimeArray;
        int[] FileCountArray;
        ImageInfo[] ImageInfoArray;
        MovieInfo[] MovieInfoArray;
        LoadResult[] LoadResultArray;
        long[] ZipSizeArray;
        bool[] ZipMaskArray;
        ClipMode currentClipMode = ClipMode.PlaClip;
        BindingMode currentBindingMode = BindingMode.LeftToRight;
        private void MakePreview(string selectedFileName) { MakePreview(-1, -1, selectedFileName); }
        double MakePreview_tScrollbar = 0;
        int MakePreview_fScrollbar = -1;
        int MakePreview_selectedIndex = -1;
        string MakePreview_selectedFileName = null;
        Tuple<TimeSpan, TimeSpan> MakePreview_subdivideInterval = null;
        bool MakePreview_Que = false;
        bool MakePreview_StopResetFilter = false;
        const int MakePreview_fScrollbarMoveToSelectedFile = -2;
        const double MakePreview_tScrollbarMoveToSelectedFile = -2;
        bool MakePreview_needToSynchroTree = false;
        private void MakePreview(double tScrollbar = 0, int selectedIndex = -1, string selectedFileName = null, int manualUndoShift = 0, bool resetBookmark = true,
            int fScrollbar = -1, Tuple<Color, CatalogProfile> prevProfileInfo = null, Tuple<TimeSpan, TimeSpan> subdivideInterval = null, bool needToSynchroTree = true)
        {
            showStartHelpMessage = false;
            MakePreview_subdivideInterval = subdivideInterval;
            MakePreview_needToSynchroTree = needToSynchroTree;
            bool isDir;
            string finalMessage = null;
            var stopResetFilter = false;
            string text;
            try
            {
                if (MakePreview_StopResetFilter)
                {
                    MakePreview_StopResetFilter = false;
                    stopResetFilter = true;
                }
                //if (MakePreview_FromConfig)
                //{
                //    MakePreview_FromConfig = false;
                //}
                //else

                ImageLoader.SusieReset();
                PackedImageLoader.CheckSevenZipExistence(this);

                text = zabLocation.Text;
                if (string.IsNullOrEmpty(text))
                {
                    bmwMakePreviewRunWorkerStartingFinalAction = null;
                    return;
                }
                if (!IsSupportedByCatalogFormAndExists(text, out isDir))
                {
                    MessageBox.Show(this, Message._1CanNotBeOpend.Replace("$1", zabLocation.Text), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    MakePreview_Rollback(prevProfileInfo);
                    return;
                }

                if (isDir && thumbnailCache == GPSizeThumbnail.AlternateDataStream
                    && GPSizeThumbnail.SupportADSSize(text, checkNew: true) <= 0
                    && (string.IsNullOrEmpty(currentLocation)
                    || GPSizeThumbnail.SupportADSSize(currentLocation, checkNew: false) > 0
                    ))
                {
                    //MessageBox.Show(this, Message.AdsNotSupportedWarningMessage, Message.Warning, MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    //このタイミングでメッセージを表示するとフォルダが読み込まれない
                    finalMessage = Message.AdsNotSupportedWarningMessage;
                }

                var fullPath = Path.GetFullPath(/*File.Exists(text)*/ !isDir ? text : GetDirectoryPathWithSeparator(text));
                //if (fullPath != text) zabLocation.Text = getPathWithoutSeparator(fullPath);
                if (fullPath != text) zabLocation.SetText(getPathWithoutSeparator(fullPath), makeButtons: false, makeEvent: false);
            }
            catch (Exception error)
            {
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                MakePreview_Rollback(prevProfileInfo);
                return;
            }

            if (resetBookmark) foreach (DataGridViewRow row in dgvDirectoryList.Rows) row.Selected = false;

            setNonVolatilitySort();

            preCurrentLocation = getPathWithoutSeparator(zabLocation.Text);
            //addToolStripMenuItem.Enabled = false;

            /*
            {
                var lowerLocation = preCurrentLocation.ToLower();
                var filter = cbFilter.Text;
                var bookmarks = (from DataGridViewRow row in dgvDirectoryList.Rows select row.Cells[tbcDirectoryName.Index].Value as CatalogBookmark).ToArray();
                var exactMatchExists = bookmarks.Any(bookmark => bookmark.Location.ToLower() == lowerLocation && bookmark.Filter != null && bookmark.Filter == filter);
                var selected = false;
                foreach (var row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows orderby r.Index select r).ToArray())
                {
                    if (selected)
                    {
                        row.Selected = false;
                        continue;
                    }
                    var bookmark = row.Cells[tbcDirectoryName.Index].Value as CatalogBookmark;
                    if (bookmark.Location.ToLower() == lowerLocation && (!exactMatchExists || bookmark.Filter != null && bookmark.Filter == cbFilter.Text))
                    {
                        row.Selected = selected = true;
                    }
                    else row.Selected = false;
                }
                if (!selected)
                {
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as CatalogBookmark;
                        if (bookmark.Location.ToLower() == lowerLocation && (!exactMatchExists || bookmark.Filter != null && bookmark.Filter == cbFilter.Text))
                        {
                            row.Selected = selected = true;
                            break;
                        }
                    }
                }
            }
            */
            /*
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                if(selected)
                {
                    row.Selected = false;
                    continue;
                }
                var bookmark = row.Cells[tbcDirectoryName.Index].Value as CatalogBookmark;
                if (bookmark.Location.ToLower() == lowerLocation && (!exactMatchExists || bookmark.Filter != null && bookmark.Filter == cbFilter.Text))
                {
                    row.Selected = selected = true;
                }
                else row.Selected = false;
            }
            */

            undoBufferUpdateForMovingLocation(manualUndoShift, prevProfileInfo);
            /*
            if (prevProfileInfo != null && prevProfileInfo.Item2 == null) prevProfileInfo = null;
            if (undoBufferIndex >= 0 && !string.IsNullOrEmpty(currentLocation))
            {
                var index = tvCatalog.SelectedIndex;
                var zna = ZipNameArray;
                string fileName;
                if (index < 0 || zna == null || zna.Length <= index)
                {
                    fileName = null;
                }
                else
                {
                    fileName = zna[index];
                }
                var newData = new UndoBufferClass
                {
                    Location = currentLocation,
                    ThumbnailPosition = tvCatalog.ScrollBarPercentage,
                    FileListPosition = dgvFileList.FirstDisplayedScrollingRowIndex,
                    SelectedFileName = fileName,
                    ProfileColor = prevProfileInfo != null ? prevProfileInfo.Item1 : currentProfileColor,
                    Profile = prevProfileInfo != null ? prevProfileInfo.Item2 : currentConditionToProfile()
                };

                var preIndex = undoBufferIndex - manualUndoShift;
                if (0 <= preIndex && preIndex < undoBuffer.Count)
                {
                    undoBuffer[preIndex] = newData;
                }
            }

            if (manualUndoShift == 0)
            {
                var newPath = true;
                if (0 <= undoBufferIndex && undoBufferIndex < undoBuffer.Count)
                {
                    newPath = undoBuffer[undoBufferIndex].Location != preCurrentLocation ||
                        (prevProfileInfo != null && prevProfileInfo.Item1 != currentProfileColor);
                }
                if (newPath)
                {
                    var newData = new UndoBufferClass
                    {
                        Location = preCurrentLocation,
                        ProfileColor = currentProfileColor
                    };
                    undoBufferIndex++;
                    if (undoBufferIndex < undoBuffer.Count)
                    {
                        undoBuffer.RemoveRange(undoBufferIndex, undoBuffer.Count - undoBufferIndex);
                    }
                    if (undoBufferIndex > undoBuffer.Count)
                    {
                        undoBufferIndex = undoBuffer.Count;
                    }
                    undoBuffer.Add(newData);
                    btnGoToBack.Enabled = undoBufferIndex > 0;
                    btnGoToForward.Enabled = false;
                }
            }
            */

            if (!stopResetFilter && FilterRemovingMode == FilterRemovingMode.WhenMovingLocation)
            {
                cbFilter_TextChanged_StopResort = true;
                cbFilter.Text = "";
                cbFilter_TextChanged_StopResort = false;
            }

            MakePreview_tScrollbar = tScrollbar;
            MakePreview_fScrollbar = fScrollbar;
            MakePreview_selectedIndex = selectedIndex;
            if (/*scrollbar == 0 &&*/ selectedIndex < 0)
            {
                MakePreview_selectedFileName = selectedFileName;
            }
            else
            {
                MakePreview_selectedFileName = null;
            }
            zabLocation.Enabled = false;

            bmwMakePreview.CancelAsync();

            if (bwMakePreviewPrepare.IsBusy)
            {
                MakePreview_Que = true;
                bwMakePreviewPrepare.CancelAsync();
            }
            else
            {
                if (isDir)
                {
                    try
                    {
                        fileSystemWatcher.Path = preCurrentLocation;
                        fileSystemWatcher.IncludeSubdirectories = true;// SubfolderIsSearched()
                        fileSystemWatcher.EnableRaisingEvents = true;
                    }
                    catch
                    {
                        fileSystemWatcher.EnableRaisingEvents = false;
                    }
                }
                else
                {
                    fileSystemWatcher.EnableRaisingEvents = false;
                }

                CreatingZipPathArray = true;
                CloseVisibleContextMenuStrips(all: false);

                loadingGuid = Guid.Empty;
                bwMakePreviewPrepare.RunWorkerAsync(preCurrentLocation);
            }

            //MessageBox.Show($"{InvokeRequired}");
            //optionToolStripMenuItem.Text = "a";

            if (needToSynchroTree && SynchroFromBarToTree && folderTreeToolStripMenuItem.Checked)
            {
                setToTree(text, CollapseOthersWhenSynchronizing);
            }
            //optionToolStripMenuItem.Text = "b";

            if (finalMessage != null) MessageBox.Show(this, finalMessage, Message.Warning, MessageBoxButtons.OK, MessageBoxIcon.Warning);
        }

        private void setToTree(string path, bool collapse)
        {
            //var treeWnd = explorerTreeView.TreeViewWnd;
            //treeWnd.BeginUpdate();
            explorerTreeView.BeginUpdate();
            try
            {
                if (!folderTreeToolStripMenuItem.Checked)
                {
                    folderTreeToolStripMenuItem.Checked = true;
                    setFolderTreeVisible(silent: false);
                }

                explorerTreeView.TrySelect(path);

                var rootNode = explorerTreeView.TreeViewWnd.Nodes[0];

                if (!rootNode.IsExpanded)
                {
                    rootNode.Expand();
                }
                else if (collapse)
                {
                    var selectedNode = explorerTreeView.SelectedNode;
                    if (selectedNode != null)
                    {
                        var node = selectedNode == rootNode ? selectedNode : selectedNode.Parent;
                        var preNode = null as TreeNode;
                        do
                        {
                            foreach (TreeNode subNode in node.Nodes)
                            {
                                if (subNode != preNode && subNode.IsExpanded) subNode.Collapse();
                            }
                            preNode = node;
                            node = node.Parent;
                        }
                        while (node != null);

                        // text が長いと右にクスロールしてしまうのを回避
                        var text = selectedNode.Text;
                        selectedNode.Text = "";
                        selectedNode.EnsureVisible();
                        selectedNode.Text = text;
                    }
                }
            }
            catch { }
            finally
            {
                explorerTreeView.EndUpdate();
            }
        }

        private void MakePreview_Rollback(Tuple<Color, CatalogProfile> prevProfileInfo)
        {
            if (prevProfileInfo == null || prevProfileInfo.Item2 == null)
            {
                zabLocation.Text = currentLocation;
            }
            else
            {
                prepareMoveLocationWithChangingProfile(currentLocation, prevProfileInfo.Item1, prevProfileInfo.Item2, ApplicationProviderUser.Error);
            }
            bmwMakePreviewRunWorkerStartingFinalAction = null;

            // updatePreview のオーバーロードには currentLocation を書きかえるものがあるが
            // そのオーバーロードは ZipPla 自身がファイル名を書き換えたときに使うものなので
            // preCurrent よりも current の方が高い正当性が期待される
        }

        private void undoBufferUpdateForMovingLocation(int manualUndoShift, Tuple<Color, CatalogProfile> prevProfileInfo)
        {
            if (prevProfileInfo != null && prevProfileInfo.Item2 == null) prevProfileInfo = null;
            if (undoBufferIndex >= 0 && !string.IsNullOrEmpty(currentLocation))
            {
                var index = tvCatalog.SelectedIndex;
                var zna = ZipNameArray;
                string fileName;
                if (index < 0 || zna == null || zna.Length <= index)
                {
                    fileName = null;
                }
                else
                {
                    fileName = zna[index];
                }
                var newData = new UndoBufferClass
                {
                    Location = currentLocation,
                    ThumbnailPosition = tvCatalog.ScrollBarPercentage,
                    FileListPosition = dgvFileList.FirstDisplayedScrollingRowIndex,
                    SelectedFileName = fileName,
                    ProfileColor = prevProfileInfo != null ? prevProfileInfo.Item1 : currentProfileColor,
                    Profile = prevProfileInfo != null ? prevProfileInfo.Item2 : currentConditionToProfile()
                };

                var preIndex = undoBufferIndex - manualUndoShift;
                if (0 <= preIndex && preIndex < undoBuffer.Count)
                {
                    undoBuffer[preIndex] = newData;
                }
            }

            if (manualUndoShift == 0)
            {
                var newPath = true;
                if (0 <= undoBufferIndex && undoBufferIndex < undoBuffer.Count)
                {
                    newPath = undoBuffer[undoBufferIndex].Location != preCurrentLocation ||
                        (prevProfileInfo != null && prevProfileInfo.Item1 != currentProfileColor);
                }
                if (newPath)
                {
                    var newData = new UndoBufferClass
                    {
                        Location = preCurrentLocation,
                        ProfileColor = currentProfileColor
                    };
                    undoBufferIndex++;
                    if (undoBufferIndex < undoBuffer.Count)
                    {
                        undoBuffer.RemoveRange(undoBufferIndex, undoBuffer.Count - undoBufferIndex);
                    }
                    if (undoBufferIndex > undoBuffer.Count)
                    {
                        undoBufferIndex = undoBuffer.Count;
                    }
                    undoBuffer.Add(newData);
                    btnGoToBack.Enabled = undoBufferIndex > 0;
                    btnGoToForward.Enabled = false;
                }
            }
        }

        public void UpdatePreview(string renamedLocation = null, bool stopResetFilter = true)
        {
            var loc = renamedLocation != null ? renamedLocation : preCurrentLocation;

            //var locChanged = loc != preCurrentLocation; // 厳密には renamedLocation == null とは条件が異なる
            //var locChanged = loc != zabLocation.Text; // アドレスバーは表示中のテキストからボタンを作るのでこちらがより適切
            var locChanged = loc != currentLocation; // 仕様変更によりこちらが適切に

            currentLocation = renamedLocation;
            if (string.IsNullOrEmpty(loc)) return;
            var zna = ZipNameArray;
            var index = tvCatalog.SelectedIndex;
            string fileName;
            if (index < 0 || zna == null || zna.Length <= index) fileName = null;
            else fileName = zna[index];
            if (string.IsNullOrEmpty(fileName)) fileName = null;

            //zabLocation.Text = loc;
            zabLocation.SetText(loc, makeButtons: locChanged, makeEvent: locChanged);

            //MakePreview(tvCatalog.ScrollBarPercentage, tvCatalog.SelectedIndex, fScrollbar: dgvFileList.FirstDisplayedScrollingRowIndex)
            MakePreview_StopResetFilter = stopResetFilter;
            MakePreview(tvCatalog.ScrollBarPercentage, selectedIndex: -1, /*tvCatalog.SelectedIndex*/ selectedFileName: fileName, fScrollbar: dgvFileList.FirstDisplayedScrollingRowIndex);
        }

        private bool ShouldBeSkipForFileAndDirWithCheck_Only_Attributes(string path, bool? ffmpeExists)
        {
            try
            {
                if (Directory.Exists(path))
                {
                    //if (!IsDisplay(SubfolderMode)) return true;

                    return hasAttributeToSkip(new DirectoryInfo(path));
                }
                else
                {
                    return hasAttributeToSkip(new FileInfo(path));
                }
            }
            catch
            {
                // 想定外のドライブエラー
                return true;
            }
        }

        private bool ShouldBeSkippedForFileAndDirWithCheckAttributes(string path, bool? ffmpeExists)
        {
            try
            {
                if (Directory.Exists(path))
                {
                    if (!IsDisplay(SubfolderMode)) return true;

                    return hasAttributeToSkip(new DirectoryInfo(path));
                }

                int dummy;
                /*
                var archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
                var imageSkip = !imageFilesToolStripMenuItem.Checked;
                var videoSkip = !videoFilesToolStripMenuItem.Checked;
                var otherSkip = !otherFilesToolStripMenuItem.Checked;
                */
                var archiveSkip = ArchiveLoadLevel == ItemLoadLevel.Ignore;
                var imageSkip = ImageLoadLevel == ItemLoadLevel.Ignore;
                var videoSkip = VideoLoadLevel == ItemLoadLevel.Ignore;
                var otherSkip = OtherLoadLevel == ItemLoadLevel.Ignore;
                var result = ShouldBeSkipForFile(out dummy, path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpeExists);
                if (result)
                {
                    return true;
                }
                else
                {
                    return hasAttributeToSkip(new FileInfo(path));
                }
            }
            catch
            {
                // 想定外のドライブエラー
                return true;
            }
        }
        private bool ShouldBeSkipForFileAndDirWithCheckAttributes(string path, bool archiveSkip, bool imageSkip, bool videoSkip, bool otherSkip, bool? ffmpegExists, out bool becauseOfAtt)
        {
            try
            {
                if (Directory.Exists(path))
                {
                    if (!IsDisplay(SubfolderMode))
                    {
                        becauseOfAtt = false;
                        return true;
                    }

                    becauseOfAtt = true;
                    return hasAttributeToSkip(new DirectoryInfo(path));
                }
            }
            catch
            {
                // 想定外のドライブエラー
                becauseOfAtt = false;
                return true;
            }

            int dummy;
            var result = ShouldBeSkipForFile(out dummy, path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpegExists);
            if (result)
            {
                becauseOfAtt = false;
                return true;
            }
            else
            {
                becauseOfAtt = true;
                try
                {
                    return hasAttributeToSkip(new FileInfo(path));
                }
                catch
                {
                    return true;
                }
            }
        }

        private bool ShouldBeSkipForFile(out int initialPageCount, string path, bool archiveSkip, bool imageSkip, bool videoSkip, bool otherSkip, bool? ffmpegExists)
        {
            initialPageCount = MetaPageCount_NotBook;
            var extensionWithPeriodInLowerCase = Path.GetExtension(path).ToLower();
            if (PackedImageLoader.Supports(path, extensionWithPeriodInLowerCase))
            {
                if (archiveSkip) return true;
                initialPageCount = MetaPageCount_NotLoaded;
            }
            else if (ImageLoader.SupportsImageAtLeastThumbnailReadingByExtension(extensionWithPeriodInLowerCase, ffmpegExists))
            {
                if (imageSkip) return true;
            }
            else if (MovieThumbnailLoader.SupportsByExtension(extensionWithPeriodInLowerCase))
            {
                if (videoSkip) return true;
            }
            else
            {
                if (otherSkip) return true;
            }
            return false;
        }

        /*
        private string GetFileFilter(bool needToInvoke)
        {
            bool archiveSkip = true, imageSkip = true, videoSkip = true, otherSkip = true;
            if (needToInvoke)
            {
                try
                {
                    Invoke((MethodInvoker)(() =>
                    {
                        archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
                        imageSkip = !imageFilesToolStripMenuItem.Checked;
                        videoSkip = !videoFilesToolStripMenuItem.Checked;
                        otherSkip = !otherFilesToolStripMenuItem.Checked;
                    }));
                }
                catch (ObjectDisposedException) { }
            }
            else
            {
                archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
                imageSkip = !imageFilesToolStripMenuItem.Checked;
                videoSkip = !videoFilesToolStripMenuItem.Checked;
                otherSkip = !otherFilesToolStripMenuItem.Checked;
            }
            return GetFileFilter(archiveSkip, imageSkip, videoSkip, otherSkip);
        }
        
        private string GetFileFilter(bool archiveSkip, bool imageSkip, bool videoSkip, bool otherSkip)
        {
            if (!otherSkip) return "*";
            var result = "";
            if (!archiveSkip) result += PackedImageLoader.SupportedArchiveFileFilter;
            if (!imageSkip)
            {
                if (result != "") result += ";";
                result += ImageLoader.SupportedFileFilter;
            }
            if (!videoSkip)
            {
                if (result != "") result += ";";
                result += MovieThumbnailLoader.SupportedVideoFileFilter;
            }
            return result;
        }
        */

        private static bool hasAttributeToSkip(FileSystemInfo info)
        {
            FileAttributes attr;
            try
            {
                attr = info.Attributes;
            }
            catch
            {
                return true;
            }
            return hasAttributeToSkip(attr);
        }
        private static bool hasAttributeToSkip(FileAttributes attr)
        {
            return (attr & (FileAttributes.Hidden | FileAttributes.System)) != 0;
        }

        private void getDirectoryItemsInfo(
            //out string[] zipPathArrayDup,
            out string[] zipPathArray,
            out string[] zipNameArray,
            out int[] zipPageArray,
            out DateTime[] createTimeArray,
            out DateTime[] lastAccessTimeArray,
            out DateTime[] modifiedTimeArray,
            out int[] fileCountArray,
            out ImageInfo[] imageInfoArray,
            out MovieInfo[] movieInfoArray,
            out LoadResult[] loadResultArray,
            out long[] zipSizeArray,
            out bool[] zipMaskArray,
            bool archiveSkip,
            bool imageSkip,
            bool videoSkip,
            bool otherSkip,
            int dirPathFullPathLengthPlusOne,
            bool isDirectory,
            FileSystemInfo[] fileInfos,
            int[] filePages,
            DirectoryInfo[] dirInfos,
            int[] folderPages)
        {
            var filePathsLength = fileInfos != null ? fileInfos.Length : 0;
            var folderPathsLength = dirInfos != null ? dirInfos.Length : 0;

            int[] MatchIndexArray = new int[filePathsLength + folderPathsLength];
            int[] initialPageCountArray = new int[filePathsLength];
            //bool[] IsImageFileArray = new bool[filePathsLength];
            int MatchFilesCount = 0;
            var ffmpegExists = MovieThumbnailLoader.ffmpegExists();
            for (var i = 0; i < filePathsLength; i++)
            {
                var fileInfo = fileInfos[i];
                var entityInfo = FileInfoEx.GetEntityFileInfo(fileInfo);
                var path = entityInfo.FullName;
                int initialPageCount;
                if (ShouldBeSkipForFile(out initialPageCount, path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpegExists))
                {
                    continue;
                }
                //if (!PackedImageLoader.SupportedArchivesPath.IsMatch(path) && !PackedImageLoader.IsSupertedImage(path)) continue;
                /*
                FileAttributes attr;
                try
                {
                    attr = fileInfo.Attributes;//File.GetAttributes(path);
                }
                catch
                {
                    continue;
                }
                if ((attr & (FileAttributes.Hidden | FileAttributes.System)) != 0)
                {
                    continue;
                }
                */
                if (hasAttributeToSkip(entityInfo)) continue;

                //IsImageFileArray[MatchFilesCount] = isImageFile;
                MatchIndexArray[MatchFilesCount] = i;
                initialPageCountArray[MatchFilesCount] = initialPageCount;

                MatchFilesCount++;

                if (bwMakePreviewPrepare.CancellationPending)
                {
                    throw new TimeoutException();
                }
            }

            int MatchFilesAndFoldersCount = MatchFilesCount;
            for (var i = 0; i < folderPathsLength; i++)
            {
                var dirInfo = dirInfos[i];
                var path = dirInfo.FullName;

                /*
                FileAttributes attr;
                try
                {
                    attr = dirInfo.Attributes;// (new DirectoryInfo(path)).Attributes;
                }
                catch
                {
                    continue;
                }
                if ((attr & (FileAttributes.Hidden | FileAttributes.System)) != 0)
                {
                    continue;
                }
                */
                if (hasAttributeToSkip(dirInfo)) continue;

                MatchIndexArray[MatchFilesAndFoldersCount++] = i;

                if (bwMakePreviewPrepare.CancellationPending)
                {
                    throw new TimeoutException();
                }
            }

            /*
            if (bwMakePreviewPrepare.CancellationPending)
            {
                throw new TimeoutException();
            }
            */

            var MatchCountFolderPathsLength = MatchFilesAndFoldersCount; // MatchFilesCount + folderPathsLength;

            //zipPathArrayDup = new string[MatchCountFolderPathsLength * 2];

            var isNotDirectory = !isDirectory; //filePages != null && folderPages != null;

            zipPathArray = new string[MatchCountFolderPathsLength]; //ShowStatusBar();
            zipNameArray = new string[MatchCountFolderPathsLength];
            zipPageArray = new int[MatchCountFolderPathsLength];
            createTimeArray = new DateTime[MatchCountFolderPathsLength];
            lastAccessTimeArray = new DateTime[MatchCountFolderPathsLength];
            modifiedTimeArray = new DateTime[MatchCountFolderPathsLength];
            fileCountArray = new int[MatchCountFolderPathsLength];
            imageInfoArray = new ImageInfo[MatchCountFolderPathsLength];
            movieInfoArray = new MovieInfo[MatchCountFolderPathsLength];
            loadResultArray = new LoadResult[MatchCountFolderPathsLength];
            zipSizeArray = new long[MatchCountFolderPathsLength];
            zipMaskArray = new bool[MatchCountFolderPathsLength];

            var filePagesExists = filePages != null;
            var folderPagesExists = folderPages != null;

            for (var i = 0; i < MatchFilesCount; i++)
            {
                var index = MatchIndexArray[i];
                var fileInfo = fileInfos[index];
                var entityInfo = FileInfoEx.GetEntityFileInfo(fileInfo);

                var path = fileInfo.FullName;
                //zipPathArrayDup[2 * i] = zipPathArrayDup[2 * i + 1] = 
                zipPathArray[i] = path;
                var name = isNotDirectory ? /*getFileName(path)*/ fileInfo.Name : path.Substring(dirPathFullPathLengthPlusOne);
                zipNameArray[i] = name;
                zipPageArray[i] = filePagesExists ? filePages[index] : -1;

                createTimeArray[i] = Program.GetCreateTime(entityInfo);
                lastAccessTimeArray[i] = Program.GetLastAccessTime(entityInfo);// fileInfo.LastAccessTime;
                modifiedTimeArray[i] = Program.GetLastWriteTime(entityInfo);// fileInfo.LastWriteTime;
                fileCountArray[i] = initialPageCountArray[i];
                loadResultArray[i] = LoadResult.NotYet;
                zipSizeArray[i] = entityInfo.Length;// -1;
                zipMaskArray[i] = true;

                if (bwMakePreviewPrepare.CancellationPending)
                {
                    throw new TimeoutException();
                }
            }
            for (var i = MatchFilesCount; i < MatchCountFolderPathsLength; i++)
            {
                var index = MatchIndexArray[i];
                var dirInfo = dirInfos[index];

                var path = dirInfo.FullName;
                //zipPathArrayDup[2 * i] = zipPathArrayDup[2 * i + 1] = 
                zipPathArray[i] = path;
                var name = isNotDirectory ? /*getFileName(path)*/ dirInfo.Name : path.Substring(dirPathFullPathLengthPlusOne);
                zipNameArray[i] = name + Path.DirectorySeparatorChar.ToString();
                zipPageArray[i] = folderPagesExists ? folderPages[index] : -1;

                createTimeArray[i] = Program.GetCreateTime(dirInfo);
                lastAccessTimeArray[i] = Program.GetLastAccessTime(dirInfo);// dirInfo.LastAccessTime;
                modifiedTimeArray[i] = Program.GetLastWriteTime(dirInfo);// dirInfo.LastWriteTime;
                fileCountArray[i] = -1;
                //ImageSizeArray[i] = Size.Empty;
                loadResultArray[i] = LoadResult.NotYet;
                zipSizeArray[i] = -1; // フォルダのサイズ取得は時間がかかるので GetThumbnail で行う Program.GetDirectoryFileSize(dirInfo);
                zipMaskArray[i] = true;

                if (bwMakePreviewPrepare.CancellationPending)
                {
                    throw new TimeoutException();
                }
            }
        }

        private string currentLocation = "";
        private string preCurrentLocation = "";
        enum LoadTargetType { Directory, VirtualFolder, SmartFolder, ImageArchive, Movie }

        private static string GetDirectoryPathWithSeparator(string dirPath)
        {
            return dirPath.EndsWith(Path.DirectorySeparatorChar.ToString()) ? dirPath : (dirPath + Path.DirectorySeparatorChar);
        }

        // 大量のファイルがある場合の GetFiles の待ち時間でユーザーにストレスを与えないためにバックグラウンド処理
        private void bwMakePreviewPrepare_DoWork(object sender, DoWorkEventArgs e)
        {
            tvCatalog.DrawStop = true;

            /*
            bool archiveSkip = true, imageSkip = true, videoSkip = true, otherSkip = true;
            try
            {
                Invoke((MethodInvoker)(() =>
                {
                    archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
                    imageSkip = !imageFilesToolStripMenuItem.Checked;
                    videoSkip = !videoFilesToolStripMenuItem.Checked;
                    otherSkip = !otherFilesToolStripMenuItem.Checked;
                }));
            }
            catch (ObjectDisposedException) { }
            */
            var archiveSkip = ArchiveLoadLevel == ItemLoadLevel.Ignore;
            var imageSkip = ImageLoadLevel == ItemLoadLevel.Ignore;
            var videoSkip = VideoLoadLevel == ItemLoadLevel.Ignore;
            var otherSkip = OtherLoadLevel == ItemLoadLevel.Ignore;

            //var sw = new Stopwatch();
            //var ss = "";
            //sw.Start();

            var dirPath = (string)e.Argument;
            var dirPathWithSeparator = GetDirectoryPathWithSeparator(dirPath);

            // Path.GetFullPath("C:") がカレントディレクトリを返すのでこの方法は使えない
            //var dirPathFullPathLengthPlusOne = Path.GetFullPath(dirPath).Length + 1;
            var dirFullPathWithSeparator = Path.GetFullPath(dirPathWithSeparator);
            var dirPathFullPathLengthPlusOne = dirFullPathWithSeparator.Length;

            var subfolderMode = SubfolderMode;// (new GeneralConfig()).SubfolderMode;

            string[] filePaths = null, folderPaths = null;
            FileSystemInfo[] fileInfos = null;
            int[] filePages = null;
            int filePathsLength = 0;
            DirectoryInfo[] dirInfos = null;
            int[] folderPages = null;
            int folderPathsLength = 0;
            LoadTargetType type;
            try
            {
                if (File.Exists(dirPath))
                {
                    if (VirtualFolder.IsBookmarkPath(dirPath))
                    {
                        type = LoadTargetType.VirtualFolder;
                        VirtualFolder.GetBookmarkFiles(out filePaths, out filePages, out folderPaths, out folderPages, dirPath);
                        if (bwMakePreviewPrepare.CancellationPending)
                        {
                            return;
                        }

                        if (dirPath != Program.HistorySorPath) filePages = folderPages = null;

                        // ファイルが存在しない場合に FileInfo.Attribute がフルビット(-1)を返し、
                        // システムファイルのビットが立っていればそのファイルをスキップする動作のため
                        // 存在しないファイルをスキップする処理を行わなくても「たまたま」ほとんどの場合に問題は起こらないが、
                        // それに頼るのは明らかに不適切な上、FileInfo.Atrribute はフォルダの属性も取得するため
                        // ファイルが存在しないが同名のフォルダが存在する状況では明確に動作不良を起こすため明示的なスキップ処理は必要
                        var newFiles = new List<string>(filePaths.Length);
                        var newFilePages = filePages == null ? null : new List<int>(filePages.Length);
                        for (var i = 0; i < filePaths.Length; i++)
                        {
                            if (File.Exists(filePaths[i]))
                            {
                                newFiles.Add(filePaths[i]);
                                if (newFilePages != null) newFilePages.Add(filePages[i]);
                            }
                        }
                        if (newFiles.Count < filePaths.Length)
                        {
                            filePaths = newFiles.ToArray();
                            filePages = newFilePages?.ToArray();
                        }
                        newFiles = null;
                        newFilePages = null;

                        var newFolders = new List<string>(folderPaths.Length);
                        var newFolderPages = folderPages == null ? null : new List<int>(folderPages.Length);
                        for (var i = 0; i < folderPaths.Length; i++)
                        {
                            if (Directory.Exists(folderPaths[i]))
                            {
                                newFolders.Add(folderPaths[i]);
                                if (newFolderPages != null) newFolderPages.Add(folderPages[i]);
                            }
                        }
                        if (newFolders.Count < folderPaths.Length)
                        {
                            folderPaths = newFolders.ToArray();
                            folderPages = newFolderPages?.ToArray();
                        }
                        newFolders = null;
                        newFolderPages = null;

                        /*
                        if (Program.HistorySorPath.ToLower() == dirPath.ToLower())
                        {
                            var new2old = new List<int>();
                            for (var i = 0; i < filePaths.Length; i++)
                            {
                                if (File.Exists(filePaths[i])) new2old.Add(i);
                            }
                            if(new2old.Count < filePaths.Length)
                            {
                                filePaths = (from i in new2old select filePaths[i]).ToArray();
                                filePages = (from i in new2old select filePages[i]).ToArray();
                            }

                            new2old.Clear();
                            for (var i = 0; i < folderPaths.Length; i++)
                            {
                                if (Directory.Exists(folderPaths[i])) new2old.Add(i);
                            }
                            if (new2old.Count < folderPaths.Length)
                            {
                                folderPaths = (from i in new2old select folderPaths[i]).ToArray();
                                folderPages = (from i in new2old select folderPages[i]).ToArray();
                            }

                        }
                        */

                        filePathsLength = filePaths.Length;
                        folderPathsLength = folderPaths.Length;
                        fileInfos = new FileSystemInfo[filePathsLength];
                        for (var i = 0; i < filePathsLength; i++)
                        {
                            fileInfos[i] = new FileInfoEx(filePaths[i]);
                            if ((i & 15) == 15 && bwMakePreviewPrepare.CancellationPending)
                            {
                                return;
                            }
                        }
                        dirInfos = new DirectoryInfo[folderPathsLength];
                        for (var i = 0; i < folderPathsLength; i++)
                        {
                            dirInfos[i] = new DirectoryInfo(folderPaths[i]);
                            if ((i & 15) == 15 && bwMakePreviewPrepare.CancellationPending)
                            {
                                return;
                            }
                        }

                        //fileInfos = (from path in filePaths select new FileInfo(path)).ToArray();
                        //dirInfos = (from path in folderPaths select new DirectoryInfo(path)).ToArray();
                        if (bwMakePreviewPrepare.CancellationPending)
                        {
                            return;
                        }
                    }
                    else if (SmartFolder.IsSmartFolderPath(dirPath))
                    {
                        //var searchPatternForFiles = GetFileFilter(archiveSkip, imageSkip, videoSkip, otherSkip);
                        const string searchPatternForFiles = "*";

                        type = LoadTargetType.SmartFolder;
                        var searchOption = SubfolderIsSearched(subfolderMode) ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
                        var smartFolder = new SmartFolder(dirPath);
                        fileInfos = smartFolder.GetFiles(
                            searchPatternForFiles,
                            searchOption: searchOption,
                            bw: bwMakePreviewPrepare);
                        if (bwMakePreviewPrepare.CancellationPending)
                        {
                            return;
                        }
                        filePathsLength = fileInfos.Length;
                        if (IsDisplay(subfolderMode))
                        {
                            dirInfos = smartFolder.GetDirectories(searchPattern: "*", searchOption: searchOption, bw: bwMakePreviewPrepare);
                            if (bwMakePreviewPrepare.CancellationPending)
                            {
                                return;
                            }
                            folderPathsLength = dirInfos.Length;
                        }
                    }
                    else if (PackedImageLoader.Supports(dirPath))
                    {
                        type = LoadTargetType.ImageArchive;
                    }
                    else if (MovieThumbnailLoader.Supports(dirPath))
                    {
                        type = LoadTargetType.Movie;
                    }
                    else
                    {
                        throw new NotSupportedException();
                    }
                }
                else
                {
                    //var searchPatternForFiles = GetFileFilter(archiveSkip, imageSkip, videoSkip, otherSkip);
                    const string searchPatternForFiles = "*";

                    //sw.Restart();

                    type = LoadTargetType.Directory;
                    var dirInfo = new DirectoryInfo(dirPathWithSeparator);
                    var subfolderIsSearched = SubfolderIsSearched(subfolderMode);
                    if (subfolderIsSearched)
                    {
                        fileInfos = Program.GetFilesInAllDirectoriesOnErrorResumeNext(dirInfo, searchPatternForFiles, bwMakePreviewPrepare);
                    }
                    else
                    {
                        fileInfos = dirInfo.GetFiles(searchPatternForFiles, SearchOption.TopDirectoryOnly);
                    }
                    filePathsLength = fileInfos.Length;

                    //sw.Stop(); ss += $"GetFiles:\t{sw.Elapsed}\n";


                    if (bwMakePreviewPrepare.CancellationPending)
                    {
                        return;
                    }

                    if (IsDisplay(subfolderMode))
                    {
                        if (subfolderIsSearched)
                        {
                            dirInfos = Program.GetDirectoriesInAllDirectoriesOnErrorResumeNext(dirInfo, "*", bwMakePreviewPrepare);
                        }
                        else
                        {
                            dirInfos = dirInfo.GetDirectories("*", SearchOption.TopDirectoryOnly);
                        }
                        folderPathsLength = dirInfos.Length;

                        if (bwMakePreviewPrepare.CancellationPending)
                        {
                            return;
                        }
                    }
                }
            }
            catch (Exception error)
            {
                try
                {
                    Invoke((MethodInvoker)(() =>
                    {
                        cancelLastUndoBufferChange();

#if DEBUG
                        if (MessageBox.Show(this, error.ToString(), null, MessageBoxButtons.RetryCancel, MessageBoxIcon.Error) == DialogResult.Retry)
#else
                        if (MessageBox.Show(this, error.Message, null, MessageBoxButtons.RetryCancel, MessageBoxIcon.Error) == DialogResult.Retry)
#endif
                        {
                            //MakePreview(tScrollbar: MakePreview_tScrollbar, selectedIndex: MakePreview_selectedIndex, selectedFileName: MakePreview_selectedFileName,
                            //    fScrollbar: MakePreview_fScrollbar, subdivideInterval: MakePreview_subdivideInterval, needToSynchroTree: MakePreview_needToSynchroTree);
                            // Busy が分かりきっている＋Busy による先延ばしは UndoBuffer を更新するのでここでは明示的な予約をする


                            MakePreview_Que = true;
                        }
                        else
                        {
                            if (currentLocation != preCurrentLocation)
                            {
                                preCurrentLocation = currentLocation;
                                zabLocation.Text = currentLocation;
                            }
                        }
                        /*
                    }));
                }
                catch (ObjectDisposedException) { }
                try
                {
                    Invoke((MethodInvoker)(() =>
                    {
                    */
                        //cancelLastUndoBufferChange(); // makePreview よりも先に
                        zabLocation.Enabled = true;
                        tvCatalog.DrawStop = false;
                        tvCatalog.Invalidate();
                    }
              ));
                }
                catch (ObjectDisposedException) { }
                return;
            }

            //string[] ZipPathArrayDup = null;

            if (type == LoadTargetType.ImageArchive)
            {
                PackedImageLoaderWithEntries loader;
                try
                {
                    var pureLoader = new PackedImageLoader(dirPath, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode);
                    try
                    {
                        loader = new PackedImageLoaderWithEntries(pureLoader);
                    }
                    catch
                    {
                        pureLoader.Dispose();
                        throw;
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
                            MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            /*
                        }));
                    }
                    catch (ObjectDisposedException) { }
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
                        */
                            cancelLastUndoBufferChange();
                            zabLocation.Enabled = true;
                            tvCatalog.DrawStop = false;
                            tvCatalog.Invalidate();
                        }
                  ));
                    }
                    catch (ObjectDisposedException) { }
                    return;
                }

                var entries = loader.Entries;
                var fileCount = entries.Length;

                //ZipPathArrayDup = new string[fileCount * 2];

                lock (ZipPathArrayLocker)
                {
                    lock (loadingPackedImageLoaderLocker)
                    {
                        if (loadingPackedImageLoader != null)
                        {
                            loadingPackedImageLoader.Dispose();
                            loadingPackedImageLoader = null;
                        }
                        loadingPackedImageLoader = loader;
                    }

                    ZipPathArray = new string[fileCount];
                    ZipNameArray = new string[fileCount];
                    ZipPageArray = new int[fileCount];
                    CreateTimeArray = new DateTime[fileCount];
                    LastAccessTimeArray = new DateTime[fileCount];
                    ModifiedTimeArray = new DateTime[fileCount];
                    FileCountArray = new int[fileCount];
                    ImageInfoArray = new ImageInfo[fileCount];
                    MovieInfoArray = new MovieInfo[fileCount];
                    LoadResultArray = new LoadResult[fileCount];
                    ZipSizeArray = new long[fileCount];
                    ZipMaskArray = new bool[fileCount];

                    for (var i = 0; i < fileCount; i++)
                    {
                        var entry = entries[i];
                        var name = entry.Path;

                        //ZipPathArrayDup[2 * i] = ZipPathArrayDup[2 * i + 1] =
                        ZipPathArray[i] =
                            dirFullPathWithSeparator.Substring(0, dirFullPathWithSeparator.Length - 1) + Path.AltDirectorySeparatorChar + name;
                        ZipNameArray[i] = name;
                        ZipPageArray[i] = -1;

                        CreateTimeArray[i] = DateTime.MinValue;
                        LastAccessTimeArray[i] = DateTime.MinValue;
                        ModifiedTimeArray[i] = entry.LastWriteTime;
                        FileCountArray[i] = MetaPageCount_NotBook;
                        LoadResultArray[i] = LoadResult.NotYet;
                        ZipSizeArray[i] = entry.Size;
                        ZipMaskArray[i] = true;
                    }
                }
            }

            else if (type == LoadTargetType.Movie)
            {
                TimeSpan duration;
                MovieInfo movieInfo;
                try
                {
                    movieInfo = MovieInfo.FromFile(dirPath);
                    duration = movieInfo.Duration;
                    if (duration == default(TimeSpan))
                    {
                        throw new InvalidDataException();
                    }
                }
                catch (Exception ex)
                {
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
#if DEBUG
                            MessageBox.Show(this, ex.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                            MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                            /*
                        }));
                    }
                    catch (ObjectDisposedException) { }
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
                    */
                            cancelLastUndoBufferChange();
                            zabLocation.Enabled = true;
                            tvCatalog.DrawStop = false;
                            tvCatalog.Invalidate();
                        }
                  ));
                    }
                    catch (ObjectDisposedException) { }
                    return;
                }

                //const double minimumMovieThumbnailInterval = 1.0;
                //const int maximumMovieThumbnailCount = 60;
                int maximumMovieThumbnailCount = MaxCaptchaCountInAVideo <= 0 ? Math.Max(5, GetThumbnailCountInTvCatalogOrFileList(movieInfo)) : MaxCaptchaCountInAVideo;

                int thumbnailCount;
                double a, b;
                var subdivideInterval = MakePreview_subdivideInterval; // 右辺はメインスレッドで書き換えられる可能性あり
                if (subdivideInterval == null)
                {
                    var totalSeconds = duration.TotalSeconds;
                    var intTotalSeconds = (int)totalSeconds;
                    thumbnailCount = Math.Min(intTotalSeconds, maximumMovieThumbnailCount);
                    if (thumbnailCount > 0)
                    {
                        a = totalSeconds / thumbnailCount;
                        b = a / 2 + 0.5; // 両端を除く
                    }
                    else
                    {
                        thumbnailCount = 1;
                        a = 0;
                        b = 1; // Ceiling 用。Floor を使う場合は 0
                    }
                }
                else
                {
                    if (CoverSettingMode) ThumbnailSettingToCatalog_CoverSettingModeAtOnce = true;

                    var startTime = Math.Min(Math.Max(0, subdivideInterval.Item1.TotalSeconds), duration.TotalSeconds);
                    var totalSeconds = Math.Min(duration.TotalSeconds, subdivideInterval.Item2.TotalSeconds) - startTime;
                    var intTotalSeconds = (int)totalSeconds;


                    // thumbnailCount > 0 の場合のインクリメントで maximumMovieThumbnailCount を超えてしまう
                    /*
                    thumbnailCount = Math.Min(intTotalSeconds, maximumMovieThumbnailCount);
                    if (thumbnailCount > 0)
                    {
                        a = totalSeconds / thumbnailCount;
                        b = startTime + 0.5; // 両端を含む
                        thumbnailCount++; // 両端を含む
                    }
                    else
                    {
                        thumbnailCount = 1;
                        a = b = 0;
                    }
                    */

                    //修正版
                    if (intTotalSeconds == 0)
                    {
                        thumbnailCount = 1;
                        a = 0;
                        b = 1; // Ceiling 用。Floor を使う場合は 0
                    }
                    else
                    {
                        thumbnailCount = Math.Min(intTotalSeconds, maximumMovieThumbnailCount - 1);
                        a = totalSeconds / thumbnailCount;
                        b = startTime + 0.5; // 両端を含む
                        thumbnailCount++; // 両端を含む
                    }

                }

                //ZipPathArrayDup = new string[thumbnailCount * 2];

                lock (ZipPathArrayLocker)
                {
                    lock (loadingPackedImageLoaderLocker)
                    {
                        if (loadingPackedImageLoader != null)
                        {
                            loadingPackedImageLoader.Dispose();
                            loadingPackedImageLoader = null;
                        }
                    }

                    ZipPathArray = new string[thumbnailCount];
                    ZipNameArray = new string[thumbnailCount];
                    ZipPageArray = new int[thumbnailCount];
                    CreateTimeArray = new DateTime[thumbnailCount];
                    LastAccessTimeArray = new DateTime[thumbnailCount];
                    ModifiedTimeArray = new DateTime[thumbnailCount];
                    FileCountArray = new int[thumbnailCount];
                    ImageInfoArray = new ImageInfo[thumbnailCount];
                    MovieInfoArray = new MovieInfo[thumbnailCount];
                    LoadResultArray = new LoadResult[thumbnailCount];
                    ZipSizeArray = new long[thumbnailCount];
                    ZipMaskArray = new bool[thumbnailCount];


                    for (var i = 0; i < thumbnailCount; i++)
                    {
                        //var name = TimeSpan.FromSeconds(Math.Floor(a * i + b)).ToString(); // 四捨五入
                        var name = TimeSpan.FromSeconds(Math.Ceiling(a * i + b - 1)).ToString(); // 半整数は切り下げ

                        // 半整数は切り下げないと、a = 1 で b が半整数の場合に最後の一枚が切り上げられてサムネイル作成に失敗することがある
                        // この場合 a = 1 では 0 秒のサムネイルが作成されるが、これは失敗しない

                        //ZipPathArrayDup[2 * i] = ZipPathArrayDup[2 * i + 1] = 
                        ZipPathArray[i] =
                            dirFullPathWithSeparator.Substring(0, dirFullPathWithSeparator.Length - 1) + Path.AltDirectorySeparatorChar + name;
                        ZipNameArray[i] = name;
                        ZipPageArray[i] = -1;

                        CreateTimeArray[i] = DateTime.MinValue;
                        LastAccessTimeArray[i] = DateTime.MinValue;
                        ModifiedTimeArray[i] = DateTime.MinValue;
                        FileCountArray[i] = MetaPageCount_NotBook;
                        LoadResultArray[i] = LoadResult.NotYet;
                        ZipSizeArray[i] = -1;
                        ZipMaskArray[i] = true;

                        MovieInfoArray[i] = movieInfo;
                    }
                }
            }

            else if (type == LoadTargetType.Directory || type == LoadTargetType.VirtualFolder || type == LoadTargetType.SmartFolder)
            {
                //////////////////////////////////

                if ((!archiveSkip || IsDisplay(subfolderMode)) &&
                    LoadLastViewedPageFromHistory && string.Compare(dirPath, Program.HistorySorPath, ignoreCase: true) != 0 && File.Exists(Program.HistorySorPath))
                {
                    if (filePaths == null)
                    {
                        filePaths = new string[filePathsLength];
                        for (var i = 0; i < filePathsLength; i++)
                        {
                            filePaths[i] = fileInfos[i].FullName;
                        }
                    }
                    if (folderPaths == null)
                    {
                        folderPaths = new string[folderPathsLength];
                        for (var i = 0; i < folderPathsLength; i++)
                        {
                            folderPaths[i] = dirInfos[i].FullName;
                        }
                    }

                    VirtualFolder.GetPageFromBookmark(out filePages, out folderPages, filePaths, folderPaths, Program.HistorySorPath);
                    /*
                    filePages = new int[filePathsLength];
                    for (var i = 0; i < filePathsLength; i++) filePages[i] = 2;
                    folderPages = new int[folderPathsLength];
                    for (var i = 0; i < folderPathsLength; i++) filePages[i] = 2;
                    */
                }

                string[] zipPathArray;
                string[] zipNameArray;
                int[] zipPageArray;
                DateTime[] createTimeArray;
                DateTime[] lastAccessTimeArray;
                DateTime[] modifiedTimeArray;
                int[] fileCountArray;
                ImageInfo[] imageInfoArray;
                MovieInfo[] movieInfoArray;
                LoadResult[] loadResultArray;
                long[] zipSizeArray;
                bool[] zipMaskArray;

                try
                {
                    //sw.Start();
                    getDirectoryItemsInfo(
                        //out ZipPathArrayDup,
                        out zipPathArray,
                        out zipNameArray,
                        out zipPageArray,
                        out createTimeArray,
                        out lastAccessTimeArray,
                        out modifiedTimeArray,
                        out fileCountArray,
                        out imageInfoArray,
                        out movieInfoArray,
                        out loadResultArray,
                        out zipSizeArray,
                        out zipMaskArray,
                        archiveSkip,
                        imageSkip,
                        videoSkip,
                        otherSkip,
                        dirPathFullPathLengthPlusOne,
                        type == LoadTargetType.Directory,
                        fileInfos,
                        filePages,
                        dirInfos,
                        folderPages);
                    //sw.Stop(); ss += $"GetDirInfo:\t{sw.Elapsed}\n";
                    //MessageBox.Show($"{PackedImageLoader.Supports(".ZIP")}\n{PackedImageLoader.Supports("aaa")}\n{ss}");
                }
                catch (TimeoutException)
                {
                    return;
                }
                catch (Exception ex)
                {
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
#if DEBUG
                            MessageBox.Show(this, ex.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                            MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                            /*
                        }));
                    }
                    catch (ObjectDisposedException) { }
                    try
                    {
                        Invoke((MethodInvoker)(() =>
                        {
                        */
                            cancelLastUndoBufferChange();
                            zabLocation.Enabled = true;
                            tvCatalog.DrawStop = false;
                            tvCatalog.Invalidate();
                        }
                  ));
                    }
                    catch (ObjectDisposedException) { }
                    return;
                }


                if (bwMakePreviewPrepare.CancellationPending)
                {
                    return;
                }


                lock (ZipPathArrayLocker)
                {

                    lock (loadingPackedImageLoaderLocker)
                    {
                        if (loadingPackedImageLoader != null)
                        {
                            loadingPackedImageLoader.Dispose();
                            loadingPackedImageLoader = null;
                        }
                    }

                    ZipPathArray = zipPathArray; //ShowStatusBar();
                    ZipNameArray = zipNameArray;
                    ZipPageArray = zipPageArray;
                    CreateTimeArray = createTimeArray;
                    LastAccessTimeArray = lastAccessTimeArray;
                    ModifiedTimeArray = modifiedTimeArray;
                    FileCountArray = fileCountArray;
                    ImageInfoArray = imageInfoArray;
                    MovieInfoArray = movieInfoArray;
                    LoadResultArray = loadResultArray;
                    ZipSizeArray = zipSizeArray;
                    ZipMaskArray = zipMaskArray;
                }


                ////////////
            }
            else
            {
                try
                {
                    Invoke((MethodInvoker)(() =>
                    {
                        MessageBox.Show(this, (new NotSupportedException()).Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        /*
                    }));
                }
                catch (ObjectDisposedException) { }
                try
                {
                    Invoke((MethodInvoker)(() =>
                    {
                    */
                        cancelLastUndoBufferChange();
                        zabLocation.Enabled = true;
                        tvCatalog.DrawStop = false;
                        tvCatalog.Invalidate();
                    }
              ));
                }
                catch (ObjectDisposedException) { }
                return;
            }
            //sw.Stop();
            //MessageBox.Show($"{sw.Elapsed} {Image.GetPixelFormatSize(0)}");

            e.Result = true; // completed に成功を伝え、Creating を false にさせない

            try
            {
                Invoke((MethodInvoker)(() =>
                {
                    currentLocation = dirPath;
                    //addToolStripMenuItem.Enabled = locationValid();
                    currentClipMode = clipModeByControl;
                    currentBindingMode = bindingModeByControl;

                    //DefaultLeftToRight = SettingForm.LeftToRight;
                    InArchive = type == LoadTargetType.ImageArchive; // directoryは含まない。これによって currentLocation のリネームで対象がファイルであることを担保しているので不用意に変更しないこと
                    InMovie = type == LoadTargetType.Movie;
                    InRealDirectory = type == LoadTargetType.Directory;
                    InVirtualDirectory = type == LoadTargetType.VirtualFolder;
                    InSmartDirectory = type == LoadTargetType.SmartFolder;
                    InDirectoryVirtualDirectoryOrSmartDirectory = InRealDirectory || InVirtualDirectory || InSmartDirectory;
                    InDocument = InArchive && dirPath.ToLower().EndsWith(".pdf"); // 現在の実装では InArchive と等価
                    LocationZipPlaInfo = dirPath.Contains(Path.DirectorySeparatorChar) ? new ZipPlaInfo(dirPath) : null; // ルートは取得できない

                    cbFilter_Refresh(cbFilter.Text);

                    initialZipPathLength = ZipPathArray.Length;

                    while (cbLocation.Items.Contains(dirPath)) cbLocation.Items.Remove(dirPath);

                    cbLocation.Items.Insert(0, dirPath);
                    zabLocation.Text = dirPath;

                    //bmwMakePreview.RunWorkerAsyncWithInterrupt(ZipPathArrayDup, false);
                    bmwMakePreview.RunWorkerAsyncWithInterrupt(new object[2 * initialZipPathLength], false);

                    Text = $"{SimpleBookmark.GetDisplayName(dirPath)} - {Program.Name}";
                }));
            }
            catch (ObjectDisposedException) { }
        }

        private void cancelLastUndoBufferChange()
        {
            var last = undoBuffer.Count - 1;
            if (last >= 0 && last == undoBufferIndex)
            {
                undoBuffer.RemoveAt(undoBufferIndex);
                undoBufferIndex--;
                btnGoToBack.Enabled = undoBufferIndex > 0;
            }
        }

        int initialZipPathLength;
        public bool InArchive, InMovie, InDocument, InRealDirectory, InVirtualDirectory, InSmartDirectory, InDirectoryVirtualDirectoryOrSmartDirectory;
        ZipPlaInfo LocationZipPlaInfo;
        bool CoverSettingMode;

        private static string getFileName(string path)
        {
            var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            var sepPos = altPos >= 0 ? altPos : path.LastIndexOf(Path.DirectorySeparatorChar);
            if (sepPos >= 0)
            {
                if (sepPos < path.Length - 1) return path.Substring(sepPos + 1);
            }
            return path;
        }

        private void bwMakePreviewPrepare_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Program.AlertError(e.Error);
            if (e.Result as bool? != true) CreatingZipPathArray = false;
            if (MakePreview_Que && !CatalogForm_FormClosing_FormClosed)
            {
                MakePreview_Que = false;
                MakePreview(tScrollbar: MakePreview_tScrollbar, selectedIndex: MakePreview_selectedIndex,
                    selectedFileName: MakePreview_selectedFileName, fScrollbar: MakePreview_fScrollbar, subdivideInterval: MakePreview_subdivideInterval, needToSynchroTree: MakePreview_needToSynchroTree);


                //private void MakePreview(double tScrollbar = 0, int selectedIndex = -1, string selectedFileName = null, int manualUndoShift = 0, bool resetBookmark = true,
                //    int fScrollbar = -1, Tuple<Color, CatalogProfile> prevProfileInfo = null, Tuple<TimeSpan, TimeSpan> subdivideInterval = null, bool needToSynchroTree = true)
            }
        }

        // パフォーマンス向上のために呼び出す。必須ではない。
        private void prepareFileListRows(object itemCountIntObject)
        {
            var itemCount = (int)itemCountIntObject;
            var recycleCount = setFileListFromThumbnailViewer_Recycle.Count;
            if (recycleCount < itemCount)
            {
                var tbcFileNameIndex = tbcFileName.Index;
                var tbcRatingIndex = tbcRating.Index;
                var tbcIconIndex = tbcIcon.Index;
                var addCount = itemCount - recycleCount;
                setFileListFromThumbnailViewer_Recycle.AddRange(new DataGridViewRow[addCount]);

                // 並列化で高速化されない
                /*
                const int blockSize = 100;
                Parallel.For(0, (addCount + (blockSize - 1)) / blockSize, j =>
                {
                    var start = recycleCount + j * blockSize;
                    var stop =  Math.Min(start + blockSize, itemCount);

                    for (var i = start; i < stop; i++)
                    {
                        var row = new DataGridViewRow(); // ループ内の 4 割
                        row.CreateCells(dgvFileList); // ループ内の 3 割
                        setFileListFromThumbnailViewer_Recycle[i] = row;
                        row.Cells[tbcFileNameIndex] = new RainbowDataGridViewTextBoxCell(null);
                        var ratingGridViewTextBoxCell = new RatingGridViewTextBoxCell(activeStars: false, activeStarsFunc: fileListNotInGesturing);
                        ratingGridViewTextBoxCell.RatingClick += RatingGridViewTextBoxCell_RatingClick;
                        row.Cells[tbcRatingIndex] = ratingGridViewTextBoxCell;
                        var iconCell = new DataGridViewIconCell();
                        iconCell.GetMaskAlpha = GetMaskAlpha;
                        row.Cells[tbcIconIndex] = iconCell;
                    }
                });
                */

                for (var i = recycleCount; i < itemCount; i++)
                {
                    var row = new DataGridViewRow(); // ループ内の 4 割
                    row.CreateCells(dgvFileList); // ループ内の 3 割
                    setFileListFromThumbnailViewer_Recycle[i] = row;
                    row.Cells[tbcFileNameIndex] = new RainbowDataGridViewTextBoxCell(null);
                    var ratingGridViewTextBoxCell = new RatingGridViewTextBoxCell(activeStars: false, activeStarsFunc: notNeedToIgnoreMouseMoveOnRating);
                    ratingGridViewTextBoxCell.RatingClick += RatingGridViewTextBoxCell_RatingClick;
                    row.Cells[tbcRatingIndex] = ratingGridViewTextBoxCell;
                    var iconCell = new DataGridViewIconCell();
                    iconCell.GetMaskAlpha = GetMaskAlpha;
                    row.Cells[tbcIconIndex] = iconCell;
                }
            }
        }

        //private readonly Dictionary<string, FileSystemWatcher> folderWatchers = new Dictionary<string, FileSystemWatcher>();

        //private static readonly Color sorColor = Color.LightGreen;
        private void bmwMakePreview_RunWorkerStarting(object sender, BackgroundMultiWorker.RunWorkerStartingEventArgs e)
        {
            //var sw = new Stopwatch();
            //var ss = "";

            //sw.Restart();

            var zpa = ZipPathArray;
            var itemCount = zpa == null ? 0 : zpa.Length; // ロックしていないのでこのあとのロック時の数と異なる可能性があるが正確な値である必要はない
            Task prepareFileListRowsTask = null;
            if (itemCount > setFileListFromThumbnailViewer_Recycle.Count)
            {
                prepareFileListRowsTask = new Task(prepareFileListRows, itemCount);
                prepareFileListRowsTask.Start();
                //prepareFileListRows();
            }

            /*
            lock(folderWatchers)
            {
                foreach(var watcher in folderWatchers.Values) watcher?.Dispose();
                folderWatchers.Clear();
            }
            */

            SetFileListPageHeaderWidth();

            CreatingZipPathArray = false;
            int selectedIndex;
            double tScrollbar;
            int fScrollbar;
            var selectByName = !string.IsNullOrEmpty(MakePreview_selectedFileName);

            CoverSettingMode = ThumbnailSettingToCatalog_CoverSettingModeAtOnce && InMovie;

            ThumbnailSettingToCatalog();

            setCutFiles();
            addOrReloadItem_UserAddFileInLower = null;

            lock (ZipPathArrayLocker)
            {
                if (!selectByName)
                {
                    selectedIndex = MakePreview_selectedIndex;
                }
                else
                {
                    selectedIndex = Array.IndexOf(ZipNameArray, MakePreview_selectedFileName);
                }
                tScrollbar = MakePreview_tScrollbar;
                fScrollbar = MakePreview_fScrollbar;

                if (NumberOfLinesOfName == NumberOfLinesOfName.Full)
                {
                    tvCatalog.SetTextLinesFromText(getMaxLengthString(ZipNameArray), true);
                }

                var len = ZipNameArray.Length;

                //sw.Stop(); ss += $"sortStart:\t{sw.Elapsed}\n"; sw.Restart();
                var sortedArray = GetSortArray(preSortArray: null, careTvCatalog: false);
                //sw.Stop(); ss += $"srtEnd:\t{sw.Elapsed}\n"; sw.Restart();
                tvCatalog.Clear(len, selectedIndex, tScrollbar, sortedArray, ChangeThumbnailSize_Width, ChangeThumbnailSize_Height, Program.DpiScaling(ChangeThumbnailSize_Padding * currentMinimumFrameThickness));
                sortedArray = null;

                //sw.Stop(); ss += $"clearEnd:\t{sw.Elapsed}\n"; sw.Restart();
                for (var i = 0; i < len; i++)
                {
                    var item = new ThumbViewerItem();
                    item.Text = ZipNameArray[i];
                    if (i == selectedIndex) ThumbViewer.thumbViewerItemSelectedFieldInfo.SetValue(item, true);
                    //tvCatalog[i] = item;
                    tvCatalog.SilentSet(i, item);
                }

                //sw.Stop(); ss += $"setEnd:\t{sw.Elapsed}\n"; sw.Restart();

                tvCatalog.DrawStop = false;
                tvCatalog.Update();

                // 背景色を変えるならここで記述
                //tvCatalog.BackColor = XXX ? sorColor : WindowColor;

                // 仮想フォルダなどを開いた状態でサムネイルキャッシュが更新された場合の項目を削除するため
                // そもそもブラックリストに登録しないという実装もあり得るが、こちらの方が安定した動作が期待される
                GPSizeThumbnail.ClearBlackList();

                //sw.Stop(); ss += $"waitStart:\t{sw.Elapsed}\n"; sw.Restart();
                if (prepareFileListRowsTask != null)
                {
                    // 起動直後で Task の 25 % 程度は Wait
                    // 
                    prepareFileListRowsTask.Wait();
                    prepareFileListRowsTask.Dispose();
                    prepareFileListRowsTask = null;
                }
                //sw.Stop(); ss += $"waitStop:\t{sw.Elapsed}\n"; sw.Restart();

                //sw.Stop(); ss += $"flStart:\t{sw.Elapsed}\n"; sw.Restart();
                setFileListFromThumbnailViewer();
                //sw.Stop(); ss += $"flEnd:\t{sw.Elapsed}\n"; sw.Restart();
            }


            if (selectByName && selectedIndex >= 0 && tScrollbar < 0)
            {
                tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[selectedIndex]);
            }
            else
            {
                if (fScrollbar >= 0 && fScrollbar < dgvFileList.Rows.Count) dgvFileList.FirstDisplayedScrollingRowIndex = fScrollbar;
            }

            loadCountToolStripMenuItem.Text = 0 + " / " + ZipPathArray.Length;

            // cbLocation.Enabled = false 中の変化に対応
            //InitCursorIsOnControllField();
            /*
            if (cbLocation.ClientRectangle.Contains(cbLocation.PointToClient(MousePosition)))
            {
                GeneralMouseEnter(cbLocation);
            }
            else
            {
                GeneralMouseLeave(cbLocation);
            }
            */

            SetBackgroundMode(true, 0, true);

            zabLocation.Enabled = true;

            ShowStatusBar();

            // 先読み状態を解除
            StopLookAheadProcess();

            SetLookAheadArchive_PrevDataIndex = -1;

            setTagFilteringMenuItems(needToRepairTagsFromBookmark: false, needToSaveCurrentTag: true);

            /* firstShownItemSelect 内で行う
            if (pnlCenter.Visible) tvCatalog.Focus();
            else if (pnlRight.Visible) dgvFileList.Focus();show
            */

            SetLookAheadArchive_PrevDataIndex = -1;

            bmwMakePreviewRunWorkerStartingFinalAction?.Invoke();

            loadingGuid = e.WorkSetGuid;
            //sw.Stop(); ss += $"fin:\t{sw.Elapsed}\n";
            //MessageBox.Show(ss);

        }

        Guid loadingGuid = Guid.Empty;

        private void bmwMakePreview_DoWork(object sender, BackgroundMultiWorker.EachDoWorkEventArgs e)
        {
            e.Result = null;

            var index = e.WorkNumber;
            var index2 = index / 2;

            var zpa = ZipPathArray;

            if (loadingGuid != e.WorkSetGuid || zpa == null || zpa.Length <= index2) return;

            var zipPath = zpa[index2];


            //var zipPath = (string)e.Argument;
            int filecount;
            LoadResult loadResult;
            long fileSize;
            ImageInfo imageInfo;
            MovieInfo movieInfo;
            bool plainFile;
            var isDir = false;
            try
            {
                isDir = Directory.Exists(zipPath);
            }
            catch { }

            if (bmwMakePreview.CancellationPending) return;

            var task = Task.Run(() =>
            {
                try
                {
                    if ((index & 1) == 0)
                    {
                        if (bmwMakePreview.GetWorkState(index | 1) == BackgroundMultiWorker.WorkState.Waiting)
                        {
                            var done = GetHeader(zipPath, isDir, out plainFile, out filecount, out loadResult, out fileSize, out imageInfo, out movieInfo);
                            e.Result = done ? Tuple.Create(zipPath, null as Bitmap, plainFile, filecount, loadResult, fileSize, imageInfo, movieInfo) : null;
                        }
                        else
                        {
                            e.Result = null;
                        }
                    }
                    else
                    {
                        //var ma = MovieInfoArray;
                        //if (ma != null && ma.Length > index2) movieInfo = ma[index2]; else movieInfo = null;


                        var ma = MovieInfoArray;
                        var ia = ImageInfoArray;
                        var ca = FileCountArray;
                        if (ma != null && ia != null && ca != null && ma.Length > index2 && ia.Length > index2 && ca.Length > index2)
                        {
                            var m = ma[index2];
                            var i = ia[index2];
                            var c = ca[index2];
                            movieInfo = m;
                            var existsHeader = m != null || i != null || c >= 0;

                            var thumbnail = GetThumbnail(zipPath, isDir, (BackgroundWorker)sender, out plainFile, out filecount, out loadResult, out fileSize, out imageInfo, ref movieInfo, existsHeader);
                            e.Result = existsHeader && thumbnail == null ? null : Tuple.Create(zipPath, thumbnail,
                                plainFile, filecount, loadResult, fileSize, imageInfo, movieInfo);
                        }
                        else
                        {
                            e.Result = null;
                        }

                    }
                }
                catch { }
            });

            while (!bmwMakePreview.CancellationPending && !CatalogForm_FormClosing_FormClosed)
            {
                if (task.Wait(50))
                {
                    task.Dispose(); // task の Dispose は必須ではないが可能なら行う
                    break;
                }
            }
        }


        private string IfNegativeThenQuestion(int i)
        {
            return i >= 0 ? i.ToString() : "?";
        }

        private void bmwMakePreview_InconclusiveWorkerDisposing(object sender, BackgroundMultiWorker.EachRunWorkerCompletedEventArgs e)
        {
            var ResultTuple = e.Result as Tuple<string, Image, bool, int, LoadResult, long, ImageInfo, Tuple<MovieInfo>>;
            ResultTuple?.Item2?.Dispose();
        }

        Point bmwMakePreview_EachRunWorkerCompleted_CursorPosition = Point.Empty;
        private void bmwMakePreview_EachRunWorkerCompleted(object sender, BackgroundMultiWorker.EachRunWorkerCompletedEventArgs e)
        {
            Program.AlertError(e.Error);
            var hasThumbnail = (e.WorkNumber & 1) == 1;
            var newPhase = bmwMakePreview.GetWorkState(e.WorkNumber ^ 1) != BackgroundMultiWorker.WorkState.Finished;
            var ResultTuple = e.Result as Tuple<string, Bitmap, bool, int, LoadResult, long, ImageInfo, Tuple<MovieInfo>>; // Tuple.Create は要素が 8 以上の時こういう挙動になる
            var show = ResultTuple != null && !e.Cancelled && (hasThumbnail || newPhase) && e.WorkSetGuid == loadingGuid;
            if (!show && ResultTuple != null)
            {
                var image = ResultTuple.Item2;
                if (image != null) image.Dispose();
            }
            if (show)
            {
                var index = e.WorkNumber / 2;
                var plainFile = ResultTuple.Item3;
                //var singlePath = "";
                try
                {
                    //int page;
                    //bool allSelectionLoaded = false;
                    //bool allSelectionArchive = false;
                    bool loadedIsSelected = false;
                    //bool singleEmpty = false;
                    bool singleCannotOpen = false;
                    //bool isDir = false;
                    string path, name;
                    lock (ZipPathArrayLocker)
                    {
                        // リロードによって FileCountArray 等が変更されることがある。
                        // 一度消えて同じパスが再設定された場合ここでは判定できないが、
                        // その場合このまま続ければ良い
                        if (index >= FileCountArray.Length || index >= LoadResultArray.Length || ResultTuple.Item1 != ZipPathArray[index])
                        {
                            ResultTuple.Item2?.Dispose();
                            return;
                        }

                        // マスクされていたら何もしない
                        if (!ZipMaskArray[index])
                        {
                            ResultTuple.Item2?.Dispose();
                            return;
                        }

                        FileCountArray[index] = ResultTuple.Item4;
                        LoadResultArray[index] = ResultTuple.Item5;
                        if (ResultTuple.Item6 >= 0) ZipSizeArray[index] = ResultTuple.Item6;
                        if (ResultTuple.Item7 != null) ImageInfoArray[index] = ResultTuple.Item7;
                        if (ResultTuple.Rest.Item1 != null) MovieInfoArray[index] = ResultTuple.Rest.Item1;
                        //page = ZipPageArray[index];
                        path = ZipPathArray[index];
                        name = ZipNameArray[index];

                        if (cmsRightClickPrepareAndShow_ZipPlaInfoReady)
                        {
                            var selectedIndices = tvCatalog.SelectedIndices;
                            if (selectedIndices.Contains(index))
                            {
                                loadedIsSelected = true;
                                //allSelectionLoaded = selectedIndices.All(s => s >= 0 && LoadResultArray != null && s < LoadResultArray.Length &&
                                //    LoadResultArray[s] != LoadResult.NotYet);// && LoadResultArray[s] != LoadResult.FileNotFound);
                                //allSelectionArchive = selectedIndices.All(s => s >= 0 && s < ZipPathArray.Length &&
                                //     LoadResultArray[s] != LoadResult.NotYet && LoadResultArray[s] != LoadResult.FileNotFound &&
                                //(ZipNameArray[s].EndsWith(Path.DirectorySeparatorChar.ToString()) || PackedImageLoader.SupportedArchivesPath.IsMatch(ZipPathArray[s])));
                                if (selectedIndices.Length == 1)
                                {
                                    var selectedIndex = selectedIndices[0];
                                    if (0 <= selectedIndex && selectedIndex < LoadResultArray.Length)
                                    {
                                        //singlePath = ZipPathArray[selectedIndex];
                                        var loadResult = LoadResultArray[selectedIndex];
                                        singleCannotOpen = loadResult == LoadResult.FileNotFound || loadResult == LoadResult.LoadError;
                                        //if (singleCannotOpen)
                                        {
                                            // isDir = ZipNameArray[selectedIndex].EndsWith(Path.DirectorySeparatorChar.ToString());
                                        }
                                    }
                                }
                            }
                        }

                        setFileListRowInLock(index, dynamicOnly: true, localOnly: false, cultureForOnlyStatic: null, volatilitySortCancelIfChanged: true);
                    }

                    // tvCatalog が更新されるのは古いワーカーが片付いたあとなので
                    // インデクサへのアクセスは問題にならない。
                    /*
                    var item = new ThumbViewerItem();
                    item.Image = ResultTuple.Item2;
                    item.Text = name;
                    tvCatalog[index] = item;
                    */
                    if (hasThumbnail)
                    {
                        // 一度消えて同じパスが再設定された場合を考慮する必要がある
                        var item = tvCatalog[index];
                        if (item != null)
                        {
                            // 再設定後の読み込みに先を越される可能性も否定はできない
                            var oldImage = item.Image;
                            if (oldImage != null) oldImage.Dispose();
                            item.Image = ResultTuple.Item2;
                        }
                        else
                        {
                            item = new ThumbViewerItem();
                            item.Image = ResultTuple.Item2;
                            item.Text = name;
                            tvCatalog[index] = item;
                        }
                    }

                    // setFileListRowInLock 内部で行う
                    /*
                    if(dynamicRewrote)
                    {
                        resetVolatilitySort();
                    }
                    */

                    var dir = name.EndsWith(Path.DirectorySeparatorChar.ToString());
                    var archive = dir || PackedImageLoader.Supports(path);

                    /*
                    if (tvCatalog.SelectedIndex == index)
                    {
                        ShowStatusBar(index);
                    }
                    */
                    if (tvCatalog.SelectedIndices?.Contains(index) == true)
                    {
                        ShowStatusBar();
                    }

                    if (cmsRightClickPrepareAndShow_ZipPlaInfoReady && loadedIsSelected)
                    {
                        /*
                        if (allSelectionLoaded)
                        {
                            var renamable = InDirectoryVirtualDirectoryOrSmartDirectory;
                            ratingToolStripMenuItem.Enabled = renamable;
                            cutToolStripMenuItem.Enabled = InRealDirectory;
                            var singleSelected = singlePath != "";
                            var singleArchive = singleSelected && allSelectionArchive;//archive;
                            pageSequenceToolStripMenuItem.Enabled = allSelectionArchive;
                            thumbnailToolStripMenuItem.Enabled = InDirectoryVirtualDirectoryOrSmartDirectory && (singleArchive || MovieThumbnailLoader.Supports(singlePath)) || InMovie || InArchive;
                            setThumbnailManuallyToolStripMenuItem.Enabled = singleSelected;
                            tagToolStripMenuItem.Enabled = renamable;
                            renameToolStripMenuItem.Enabled = renamable;
                        }
                        */

                        if (singleCannotOpen)// && BuiltInViewerIsDefault())
                        {
                            /*
                            if (isDir)
                            {
                                openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Regular);
                                openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                                openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Regular);
                                openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                                openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Regular);
                                openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = null;
                                moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Bold);
                                moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                            }
                            else
                            {
                                openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Regular);
                                openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                                openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Regular);
                                openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                                openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Bold);
                                openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                                moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Regular);
                                moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = null;
                            }
                            */

                            setAppInContextMenu(-1);
                        }
                    }
                }
                catch (Exception error)
                {
                    Program.AlertError(error);
                }
            }

            var cp = Cursor.Position;
            if (cp != bmwMakePreview_EachRunWorkerCompleted_CursorPosition)
            {
                bmwMakePreview_EachRunWorkerCompleted_CursorPosition = cp;
                SetBackgroundMode(true, 1);
            }
            else
            {
                SetBackgroundMode(false, 1);
            }

            loadCountToolStripMenuItem.Text = bmwMakePreview.CurrentThreadCount + "   " + e.CompletedWorksCount + " / " + ZipPathArray.Length;
        }

        private void getSelectedPathArray(int clickedIndex, out string[] selectedPaths, out int[] pages, out bool[] isDirs, bool pageReset = false)
        {
            selectedPaths = null;
            isDirs = null;
            pages = null;
            var selectedIndices = tvCatalog.SelectedIndices;
            if (selectedIndices.Length == 0) return;
            var zpa = ZipPathArray;
            if (zpa == null) return;
            var zna = ZipNameArray;
            if (zna == null) return;
            var pga = ZipPageArray;
            if (pga == null) return;
            var count = zpa.Length;
            if (count != zna.Length || count != pga.Length) return;
            int[] fca;
            if (pageReset)
            {
                fca = FileCountArray;
                if (fca == null || fca.Length != count) return;
            }
            else fca = null;

            int[] d2s;
            try
            {
                d2s = tvCatalog.DataIndexToShowIndex;
                selectedIndices = selectedIndices.OrderBy(i => d2s[i]).ToArray();
                if (!pageReset) d2s = null;

                if (clickedIndex >= 0)
                {
                    var indexindex = Array.IndexOf(selectedIndices, clickedIndex);
                    if (indexindex < 0) return;
                    var newSelectedIndices = new int[selectedIndices.Length];
                    var j = 0;
                    for (var i = indexindex; i < selectedIndices.Length; i++)
                    {
                        newSelectedIndices[j++] = selectedIndices[i];
                    }
                    for (var i = 0; i < indexindex; i++)
                    {
                        newSelectedIndices[j++] = selectedIndices[i];
                    }
                    selectedIndices = newSelectedIndices;
                }
            }
            catch
            {
                return;
            }

            selectedPaths = new string[selectedIndices.Length];
            isDirs = new bool[selectedIndices.Length];
            if (!pageReset) pages = new int[selectedIndices.Length];
            var page = -1;
            var tbcPageIndex = pageReset ? tbcPage.Index : -1;
            for (var i = 0; i < selectedIndices.Length; i++)
            {
                var index = selectedIndices[i];
                if (index < 0 || index >= count)
                {
                    selectedPaths = null;
                    isDirs = null;
                    pages = null;
                    return;
                }
                var path = zpa[index];
                var name = zna[index];
                if (pageReset)
                {
                    pga[index] = -1;
                    dgvFileList.Rows[d2s[index]].Cells[tbcPageIndex].Value = getPageString(-1, fca[index]);
                }
                else
                {
                    page = pga[index];
                }
                if (string.IsNullOrEmpty(path) || string.IsNullOrEmpty(name))
                {
                    selectedPaths = null;
                    isDirs = null;
                    pages = null;
                    return;
                }
                selectedPaths[i] = path;
                isDirs[i] = name.EndsWith(Path.DirectorySeparatorChar.ToString());
                if (!pageReset) pages[i] = page;
            }
            if (pageReset) tvCatalog.Invalidate();
        }

        private void getSelectedPathArray(int clickedIndex, out string[] selectedPaths, out bool[] isDirs)
        {
            selectedPaths = null;
            isDirs = null;
            var selectedIndices = tvCatalog.SelectedIndices;
            if (selectedIndices.Length == 0) return;
            var zpa = ZipPathArray;
            if (zpa == null) return;
            var zna = ZipNameArray;
            if (zna == null) return;
            var count = zpa.Length;
            if (count != zna.Length) return;

            try
            {
                var d2s = tvCatalog.DataIndexToShowIndex;
                selectedIndices = selectedIndices.OrderBy(i => d2s[i]).ToArray();

                if (clickedIndex >= 0)
                {
                    var indexindex = Array.IndexOf(selectedIndices, clickedIndex);
                    if (indexindex < 0) return;
                    var newSelectedIndices = new int[selectedIndices.Length];
                    var j = 0;
                    for (var i = indexindex; i < selectedIndices.Length; i++)
                    {
                        newSelectedIndices[j++] = selectedIndices[i];
                    }
                    for (var i = 0; i < indexindex; i++)
                    {
                        newSelectedIndices[j++] = selectedIndices[i];
                    }
                    selectedIndices = newSelectedIndices;
                }
            }
            catch
            {
                return;
            }

            selectedPaths = new string[selectedIndices.Length];
            isDirs = new bool[selectedIndices.Length];
            for (var i = 0; i < selectedIndices.Length; i++)
            {
                var index = selectedIndices[i];
                if (index < 0 || index >= count)
                {
                    selectedPaths = null;
                    isDirs = null;
                    return;
                }
                var path = zpa[index];
                var name = zna[index];
                if (string.IsNullOrEmpty(path) || string.IsNullOrEmpty(name))
                {
                    selectedPaths = null;
                    isDirs = null;
                    return;
                }
                selectedPaths[i] = path;
                isDirs[i] = name.EndsWith(Path.DirectorySeparatorChar.ToString());
            }
        }

        private int setAppInContextMenu_LastClickedIndex;
        private void setAppInContextMenu(int clickedIndex)
        {
            if (clickedIndex < 0) clickedIndex = setAppInContextMenu_LastClickedIndex;
            else setAppInContextMenu_LastClickedIndex = clickedIndex;
            var items = cmsRightClick.Items;
            var start = items.IndexOf(appStartSeparator);
            if (start < 0) return;
            start++;
            var stop = items.IndexOf(appStopSeparator);
            if (stop < 0) return;

            for (var i = start; i < stop; i++)
            {
                var disposedItem = items[start];
                items.RemoveAt(start);
                disposedItem.Dispose();
            }

            stop = start;

            string[] selectedPaths;
            bool[] isDirs;
            getSelectedPathArray(clickedIndex, out selectedPaths, out isDirs);
            if (selectedPaths == null || selectedPaths.Length <= 0) return;
            /*
            var selectedIndices = tvCatalog.SelectedIndices;
            if (selectedIndices.Length == 0) return;
            var zpa = ZipPathArray;
            if (zpa == null) return;
            var zna = ZipNameArray;
            if (zna == null) return;
            if (zpa.Length != zna.Length) return;

            var selectedPaths = new string[selectedIndices.Length];
            var isDirs = new bool[selectedIndices.Length];
            for (var i = 0; i < selectedIndices.Length; i++)
            {
                var index = selectedIndices[i];
                if (index < 0 || index >= zpa.Length) return;
                selectedPaths[i] = zpa[index];
                isDirs[i] = zna[index].EndsWith(Path.DirectorySeparatorChar.ToString());
            }
            */

            var defaultNotFound = true;
            ApplicationProvider[] applicationArray;
            if (CoverSettingMode)
            {
                defaultNotFound = false;
                var tsmi = new ToolStripMenuItem(Message.SetCoverToThis);
                tsmi.Font = new Font(tsmi.Font, FontStyle.Bold);
                tsmi.ShortcutKeyDisplayString = "Enter";
                if (selectedPaths.Length == 1)
                {
                    tsmi.Click += setCoverToThisToolStripMenuItem_Click;
                }
                else
                {
                    tsmi.Enabled = false;
                }
                items.Insert(stop++, tsmi);

                var openInZipPla = ApplicationArray?.FirstOrDefault(a => a is MoveLocationProvider) ?? new MoveLocationProvider(this, null, null, null);
                applicationArray = new ApplicationProvider[1] { openInZipPla };
            }
            else
            {
                applicationArray = ApplicationArray;
            }
            var infos = new FileInfoForApplicationProvider[selectedPaths.Length];
            for (var i = 0; i < selectedPaths.Length; i++)
            {
                infos[i] = new FileInfoForApplicationProvider { Path = selectedPaths[i], IsDir = isDirs[i] };
            }
            /*
            foreach (var app in ApplicationArray)
            {
                var ok = app.Supports(infos);
                var isDefault = defaultNotFound && app.IsDefaultFor(infos);

                if (isDefault) defaultNotFound = false;
                if (!ok) continue;
                var tsmi = app.GetToolStripMenuItem(this, selectedPaths);
                if (isDefault)
                {
                    tsmi.Font = new Font(tsmi.Font, FontStyle.Bold);
                    tsmi.ShortcutKeyDisplayString = "Enter";
                }
                else
                {
                    tsmi.Font = new Font(tsmi.Font, FontStyle.Regular);
                    tsmi.ShortcutKeyDisplayString = null;
                }
                items.Insert(stop++, tsmi);
            }

            if (start == stop)
            */
            if (InsertAppToCToolStrip(items, stop, infos, defaultNotFound, selectedPaths, applicationArray, AppInContextMenuEnabled) == 0 && !CoverSettingMode)
            {
                var tsmi = new ToolStripMenuItem(Message.ApplicationIsNotSpecified);
                tsmi.Enabled = false;
                items.Insert(stop++, tsmi);
            }
        }
        
        bool AppInContextMenuEnabled;
        void SetAppInContextMenuEnabled(bool value)
        {
            if (AppInContextMenuEnabled != value)
            {
                var items = cmsRightClick.Items;
                var start = items.IndexOf(appStartSeparator);
                if (start < 0) return;
                start++;
                var stop = items.IndexOf(appStopSeparator);
                if (stop < 0) return;
                for (var i = start; i < stop; i++) items[i].Enabled = value;
                AppInContextMenuEnabled = value;
            }
        }

        /*
        private int InsertAppToCToolStrip(ToolStripItemCollection items, int startIndex, string path)
        {
            bool isDir; // “場所”はファイルもありうる。拡張子を持つような名前のフォルダも想定されるため名前だけからの判断はできない。
            try
            {
                isDir = Directory.Exists(path);
                if (!isDir && !File.Exists(path)) return 0; // 存在チェックも兼ねる
            }
            catch
            {
                return 0;
            }
            return InsertAppToCToolStrip(items, startIndex, new FileInfoForApplicationProvider[1] { new FileInfoForApplicationProvider { Path = path, IsDir = isDir } }, false, null);
        }
        */

        private int InsertAppToCToolStrip(ToolStripItemCollection items, int startIndex, FileInfoForApplicationProvider[] infos,
            bool addDefault, string[] selectedPaths, ApplicationProvider[] applicationArray, bool enabled)
        {
            if (applicationArray == null) return 0;
            if (selectedPaths == null) selectedPaths = (from info in infos select info.Path).ToArray();
            var index = startIndex;
            foreach (var app in applicationArray)
            {
                //if (selectedPaths.Length > 1 && app.GetMultiFileMode() == MultiFileMode.Single) continue;
                /*
                var ok = true;
                var isDefault = defaultNotFound;
                for (var i = 0; i < selectedPaths.Length; i++)
                {
                    var path = selectedPaths[i];
                    var isDir = isDirs[i];
                    if (ok && !app.Supports(path, isDir)) ok = false;
                    if (isDefault && !app.IsDefaultFor(path, isDir)) isDefault = false;
                    if (!ok && !isDefault) break;
                }
                */
                var ok = app.Supports(infos);
                var isDefault = addDefault && app.IsDefaultFor(infos);

                if (isDefault) addDefault = false;
                if (!ok) continue;
                var tsmi = app.GetToolStripMenuItem(this, selectedPaths);
                if (isDefault)
                {
                    tsmi.Font = new Font(tsmi.Font, FontStyle.Bold);
                    tsmi.ShortcutKeyDisplayString = "Enter";
                }
                else
                {
                    tsmi.Font = new Font(tsmi.Font, FontStyle.Regular);
                    tsmi.ShortcutKeyDisplayString = null;
                }
                if (!enabled) tsmi.Enabled = false;
                items.Insert(index++, tsmi);
            }
            return index - startIndex;

        }

        private void bmwMakePreview_AllRunWorkersCompleted(object sender, BackgroundMultiWorker.AllRunWorkerCompletedEventArgs e)
        {
            if (!CreatingZipPathArray)
            {
                // ベースの RunWorkerCompleted がメインスレッドで実行されないので
                try
                {
                    Invoke(((MethodInvoker)(() =>
                    {
                        if (!CreatingZipPathArray)
                        {
                            // ドラッグアウトのため Dispose してはいけない
                            // いずれにしても場所切替時に Dispose される
                            /*
                            lock (ZipPathArrayLocker)
                            {
                                lock (loadingPackedImageLoaderLocker)
                                {
                                    if (loadingPackedImageLoader != null)
                                    {
                                        loadingPackedImageLoader.Dispose();
                                        loadingPackedImageLoader = null;
                                    }
                                }
                            }
                            */

                            loadCountToolStripMenuItem.Text = bmwMakePreview.CurrentThreadCount + "   " + e.Results.Count + " / " + ZipPathArray.Length;
                        }
                    })));
                }
                catch (ObjectDisposedException) { }
            }
        }


        private bool selectionSynchronizing = false;

        private void tvCatalog_SelectedIndexChanged(object sender, ThumbViewer.SelectedIndexChangedEventArgs e)
        {
            var newIndex = e.NewIndex;
            lock (ZipPathArrayLocker)
            {
                if (newIndex >= 0 && ZipPathArray != null && ZipPathArray.Length > newIndex && LoadResultArray != null)
                {
                    if (LoadResultArray[newIndex] != LoadResult.LoadError && LoadResultArray[newIndex] != LoadResult.FileNotFound)
                    {
                        //SetLookAheadArchive(ZipPathArray[newIndex], ZipPageArray[newIndex]);
                        SetLookAheadArchive(newIndex);
                    }
                    //ShowStatusBar(newIndex);
                }
                else
                {
                    //ShowStatusBar(-1);
                }
                ShowStatusBar();
            }

            selectionSynchronizingFromThumbnailToFileList();
        }

        private void selectionSynchronizingFromThumbnailToFileList(bool changeScroll = true)
        {
            //if (!fileListToolStripMenuItem.Checked) return; // ファイルリストが一度も表示されていない場合この処理は不要、かつ正常に動作しない
            var firstDisplayedScrollingRowIndex = dgvFileList.FirstDisplayedScrollingRowIndex;
            if (firstDisplayedScrollingRowIndex < 0)
            {
                return; // こちらでより自然な動作に
            }
            if (!selectionSynchronizing && tvCatalog.ShowIndexToDataIndex.Length == dgvFileList.Rows.Count)
            {
                selectionSynchronizing = true;
                var selectedIndices = tvCatalog.SelectedIndices;
                var d2s = tvCatalog.DataIndexToShowIndex;
                var selectedIndicesCount = selectedIndices.Length;
                var minimumShowSelectedIndex = int.MaxValue;
                for (var i = 0; i < selectedIndicesCount; i++)
                {
                    var showIndex = d2s[selectedIndices[i]];
                    selectedIndices[i] = showIndex;
                    if (showIndex < minimumShowSelectedIndex)
                    {
                        minimumShowSelectedIndex = showIndex;
                    }
                }
                var firstDisplayedScrollingRowIndexShouldBeChange = false;
                if (dgvFileList.Visible)
                {
                    var f = tvCatalog.FocusedIndex;
                    if (f >= 0) f = d2s[f];
                    else f = minimumShowSelectedIndex;
                    if (0 <= f && f < dgvFileList.RowCount)
                    {
                        //dgvFileList.Focus();
                        dgvFileList.CurrentCell = dgvFileList.Rows[f].Cells[tbcFileName.Index];
                        if (dgvFileList.FirstDisplayedScrollingRowIndex != firstDisplayedScrollingRowIndex)
                        {
                            if (!changeScroll)
                            {
                                dgvFileList.FirstDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndex;
                            }
                            else
                            {
                                firstDisplayedScrollingRowIndexShouldBeChange = true;
                            }
                        }
                    }
                }
                foreach (DataGridViewRow row in dgvFileList.Rows)
                {
                    var currentSelected = selectedIndices.Contains(row.Index);
                    if (row.Selected != currentSelected)
                    {
                        row.Selected = currentSelected;
                    }
                }
                if (changeScroll)
                {
                    int selectedIndex;
                    if (selectedIndicesCount == 1 && (selectedIndex = selectedIndices[0]) >= 0)
                    {
                        if (selectedIndex < firstDisplayedScrollingRowIndex)
                        {
                            dgvFileList.FirstDisplayedScrollingRowIndex = selectedIndices[0];
                        }
                        else
                        {
                            var realFirstDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndexShouldBeChange ? dgvFileList.FirstDisplayedScrollingRowIndex : firstDisplayedScrollingRowIndex;
                            var topRect = dgvFileList.GetRowDisplayRectangle(realFirstDisplayedScrollingRowIndex, false);
                            if (topRect.Height > 0)
                            {
                                // CurrentCell 変更時に FirstDisplayedScrollingRowIndex が変わっていたら変化後の RowIndex が必要
                                var rowsHeight = dgvFileList.ClientRectangle.Bottom - topRect.Top;
                                var verticalOffset = rowsHeight / topRect.Height - 1;
                                var lastDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndex + verticalOffset;
                                if ((dgvFileList.ScrollBars & ScrollBars.Horizontal) != 0)
                                {
                                    var count1 = dgvFileList.Rows.Count - 1;
                                    while (verticalOffset > 0 && dgvFileList.GetRowDisplayRectangle(
                                        Math.Min(realFirstDisplayedScrollingRowIndex + verticalOffset, count1), true).Height < topRect.Height)
                                    {
                                        lastDisplayedScrollingRowIndex--;
                                        verticalOffset--;
                                    }
                                }
                                if (selectedIndex > lastDisplayedScrollingRowIndex)
                                {
                                    var firstIndex = Math.Max(selectedIndices[0] - verticalOffset, 0);
                                    dgvFileList.FirstDisplayedScrollingRowIndex = firstIndex;
                                }
                                else if (firstDisplayedScrollingRowIndexShouldBeChange)
                                {
                                    dgvFileList.FirstDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndex;
                                }
                            }
                            else if (firstDisplayedScrollingRowIndexShouldBeChange)
                            {
                                dgvFileList.FirstDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndex;
                            }
                        }

                    }
                    else if (firstDisplayedScrollingRowIndexShouldBeChange)
                    {
                        dgvFileList.FirstDisplayedScrollingRowIndex = firstDisplayedScrollingRowIndex;
                    }
                }
                selectionSynchronizing = false;
            }
        }

        private void dgvFileList_SelectionChanged(object sender, EventArgs e)
        {
            var s2d = tvCatalog.ShowIndexToDataIndex;
            if (fileListToolStripMenuItem.Checked && !selectionSynchronizing && s2d.Length == dgvFileList.Rows.Count)
            {
                selectionSynchronizing = true;

                var selectedIndices = (from DataGridViewRow row in dgvFileList.SelectedRows select row.Index).ToArray();
                var selectedIndicesCount = selectedIndices.Length;
                for (var i = 0; i < selectedIndicesCount; i++)
                {
                    selectedIndices[i] = s2d[selectedIndices[i]];
                }
                tvCatalog.SelectedIndices = selectedIndices;
                if (selectedIndices.Length == 1)
                {
                    tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[selectedIndices[0]]);
                }

                selectionSynchronizing = false;
            }
        }

        bool CatalogForm_FormClosing_FormClosed = false;
        //bool CatalogForm_FormClosing_Force = false;
#if AUTOBUILD
        private async void CatalogForm_FormClosing(object sender, FormClosingEventArgs e)
#else
        private void CatalogForm_FormClosing(object sender, FormClosingEventArgs e)
#endif
        {
            //if (CatalogForm_FormClosing_Force) return;

            if (CatalogForm_FormClosing_FormClosed) return;

            CatalogForm_FormClosing_FormClosed = true;
            bmwMakePreview.CancelAsync();

            setCurrentFilterToHistory(bringToTop: true);
            SaveSettings();

            // 一定確率でエラー
            //Environment.Exit(0);
            //Application.Exit();

            // bmw を使う方法
            bool realTime;
            bmwMakePreview.ReserveExit(0, out realTime);
            if (!realTime)
            {
                Visible = false;
                e.Cancel = true;
#if AUTOBUILD
                //await Task.Run(() => Thread.Sleep(10 * 1000));
                await Task.Delay(10 * 1000);
                Application.Exit();
#endif
            }
            /*
            else if(bmwMakePreview.IsBusy)
            {
                Visible = false;
                //e.Cancel = true;
                //await Task.Run(() => Thread.Sleep(1000));
                Thread.Sleep(5000);
                //CatalogForm_FormClosing_Force = true;
                //Close();
            }
            */
        }

        private ToolStripMenuItem SelectedThumbnailSize
        {
            get
            {
                foreach (object itemObject in thumbnailSizeToolStripMenuItem.DropDownItems)
                {
                    if (itemObject.GetType() != typeof(ToolStripMenuItem)) continue;
                    var item = (ToolStripMenuItem)itemObject;
                    if (item.Checked)
                    {
                        return item;
                    }
                }
                return normalToolStripMenuItem;
            }
        }

        /*
        /// <summary>
        /// ini ファイル等に用いる言語設定非依存のソート名を取得
        /// </summary>
        private string GetSortString(int sortIndex)
        {
            switch (sortIndex)
            {
                case 0: return "Name in asc.";
                case 1: return "Name in desc.";
                case 2: return "Rating in asc.";
                case 3: return "Rating in desc.";
                case 4: return "Access in asc.";
                case 5: return "Access in desc.";
                case 6: return "Random";
                default: return null;
            }
        }

        private int GetSortIndex(string sortName)
        {
            switch (sortName)
            {
                case "Name in asc.":
                    return 0;
                case "Name in desc.":
                    return 1;
                case "Rating in asc.":
                    return 2;
                case "Rating in desc.":
                    return 3;
                case "Access in asc.":
                    return 4;
                case "Access in desc.":
                    return 5;
                case "Random":
                    return 6;
                default:
                    return 0;
            }
        }
        */


        //Size SaveSettings_WindowSizeWhenNotMaximized;
        //Point SaveSettings_WindowLocationWhenNotMaximized;
        private bool SaveSettings()
        {
            try
            {
                var windowState = WindowState;
                var Maximized = windowState == FormWindowState.Maximized || windowState == FormWindowState.Minimized && CatalogForm_SizeChanged_BeforeMinimizedState == FormWindowState.Maximized;

                var config = new CatalogFormConfig();
                config.CurrentProfileColor = currentProfileColor;
                config.Maximized = Maximized;
                if (windowState == FormWindowState.Normal)
                {
                    config.Size = Size;
                    config.Point = Location;
                }
                else
                {
                    //config.Size = SaveSettings_WindowSizeWhenNotMaximized;
                    //config.Point = SaveSettings_WindowLocationWhenNotMaximized;

                    var bounds = /*WindowState == FormWindowState.Normal ? Bounds :*/ RestoreBounds;
                    config.Size = bounds.Size;
                    config.Point = bounds.Location;

                }
                config.Location = !string.IsNullOrEmpty(preCurrentLocation) ? preCurrentLocation : zabLocation.Text;
                config.ThumbnailScrollbar = tvCatalog.ScrollBarPercentage;
                config.FileListScrollbar = dgvFileList.FirstDisplayedScrollingRowIndex;
                var selectedIndex = tvCatalog.SelectedIndex;
                if (0 <= selectedIndex)
                {
                    lock (ZipPathArrayLocker)
                    {
                        if (selectedIndex < ZipNameArray.Length)
                        {
                            config.SelectedFileName = ZipNameArray[selectedIndex];
                        }
                        else
                        {
                            config.SelectedFileName = "";
                        }
                    }
                }
                else
                {
                    config.SelectedFileName = "";
                }
                config.LastSortMode = prevSortMode;
                config.SortMode = sortMode;
                config.RandomSeed = sortMode == SortMode.Random ? GetSortArray_RandomSeed : null;
                config.Filter = cbFilter.Text;
                config.ThumbnailSize = thumbnailSizeToolStripMenuItem.DropDownItems.IndexOf(SelectedThumbnailSize) - ChangeThumbnailSize_MenuItemOffset;
                config.AspectRatio = aspectRatio;
                config.ShowIcon = showIcon;
                config.ShowRating = showRating;
                config.ShowTags = showTags;
                config.ShowFilename = tvCatalog.ShowText;
                config.NumberOfLinesOfName = NumberOfLinesOfName;
                config.ClipMode = clipModeByControl;
                config.AligningMode = currentAligning;
                config.MinimumFrameThickness = currentMinimumFrameThickness;
                config.ThumbnailMouseWheelScrollAmount = tvCatalog.MouseWheelScrollAmount;
                config.ThumbnailMouseWheelScrollUnit = tvCatalog.MouseWheelScrollUnit;
                config.BookmarkVisible = bookmarkToolStripMenuItem.Checked;
                config.BookmarkWidth = pnlLeft.Width;
                config.BookmarkHeight = pnlBookmark.Dock == DockStyle.Fill ? pnlBookmarkNoFillHeight : pnlBookmark.Height;//pnlBookmark.Height;
                config.FolderTreeVisible = folderTreeToolStripMenuItem.Checked;
                config.ThumbnailListVisible = thumbnailListToolStripMenuItem.Checked;
                config.FileListVisible = fileListToolStripMenuItem.Checked;
                config.FileListDock = getFileListDock();
                config.FileListWidth = pnlRight_NormalWidth;
                config.FileListOrder = Program.EncodeDisplayIndices(dgvFileList.Columns);
                config.IconInFileList = tbcIcon.Visible;
                config.PageInFileList = tbcPage.Visible;
                config.RatingInFileList = tbcRating.Visible;
                config.DateCreatedInFileList = tbcCreateTime.Visible;
                config.DateAccessedInFileList = tbcAccessTime.Visible;
                config.DateModifiedInFileList = tbcWriteTime.Visible;
                config.SizeInFileList = tbcSize.Visible;
                config.ResolutionInFileList = tbcResolution.Visible;
                config.RatioInFileList = tbcRatio.Visible;
                config.WidthInFileList = tbcWidth.Visible;
                config.HeightInFileList = tbcHeight.Visible;
                config.LengthInFileList = tbcLength.Visible;
                config.FpsInFileList = tbcFPS.Visible;
                config.TinyOnScreenKeyboardVisible = TinyOnScreenKeyboardVisible;
                config.SelectionHighlightMode = SelectionHilightMode;
                config.FilterRemovingMode = FilterRemovingMode;
                config.LoadLastViewedPageFromHistory = LoadLastViewedPageFromHistory;
                config.DoubleClickFileOpenMode = DoubleClickFileOpenMode;
                config.RightClickContextMenu = RightClickContextMenu;
                config.MiddleContextMenu = MiddleClickContextMenu;
                config.ControlRightClickContextMenu = ControlRightClickContextMenu;
                config.ItemSelectionFeedback = ItemSelectionFeedback;
                config.SynchroFromTreeToBar = SynchroFromTreeToBar;
                config.SynchroFromBarToTree = SynchroFromBarToTree;
                config.CollapseOthersWhenSynchronizing = CollapseOthersWhenSynchronizing;
                config.FolderSortMode = FolderSortMode;
                //config.CheckDirectorySize = CheckDirectorySize;
                config.ArchivesInArchiveMode = ArchivesInArchiveMode;
                config.ReadOnMemoryMode = ReadOnMemoryMode;
                config.OpenInPreviousImageFilterSetting = OpenInPreviousImageFilterSetting;
                config.DefaultBindingMode = bindingModeByControl;
                config.CoverBindingMode = CoverBindingMode;
                config.SortSyncMode = SortSyncMode;
                config.AlwaysHideUI = AlwaysHideUI;
                config.AllowReadAheadProcess = AllowReadAheadProcess;
                config.BackColorOfBuiltInViewer = BackColorOfBuiltInViewer;
                config.SelectedColorForBackColorOfBuiltInViewer = SelectedColorForBackColorOfBuiltInViewer;
                config.BuiltInViewerInitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
                config.MaxCaptchaCountInOneVideo = MaxCaptchaCountInAVideo;
                config.DisplayArchiveFiles = ArchiveLoadLevel.ToString(); // archivesFilesPDFFielsToolStripMenuItem.Checked;
                config.DisplayImageFiles = ImageLoadLevel.ToString(); //imageFilesToolStripMenuItem.Checked;
                config.DisplayVideoFiles = VideoLoadLevel.ToString(); //videoFilesToolStripMenuItem.Checked;
                config.DisplayOtherFiles = OtherLoadLevel.ToString(); //otherFilesToolStripMenuItem.Checked;
                config.ThumbnailCacheRoot = thumbnailCache == null ? CatalogFormConfig.NOCACHE : thumbnailCache;
                config.SubfolderMode = SubfolderMode;
                config.LocationHistory = (from object item in cbLocation.Items select item.ToString()).ToArray();
                config.FilterHistory = (from object item in cbFilter.Items where !string.IsNullOrEmpty(item?.ToString()) select item.ToString()).ToArray();
                config.RatingReference = ratingReferenceValue;
                if (aliasesToFilteringStrings != null) config.FilterAliasToString = (from kav in aliasesToFilteringStrings select new KeyAndValue<string, string>(kav)).ToArray();
                config.InvariantFilter = invariantFilteringList;
                config.MouseGestureEnabled = mgCatalog.Enabled;
                config.MouseGestureLineWidth = mgCatalog.GetWidth();
                config.MouseGestureLineColor = mgCatalog.GetColor();
                config.MouseGestureCommands = mgCatalog.Actions != null && mgCatalog.Actions.Length > 0 ?
                    (from a in mgCatalog.Actions select new MouseGestureCommand() { Gesture = a.Gesture, Command = (Command)a.Key }).ToArray() : null;
                config.Save();

                return true;
            }
            catch (Exception error)
            {
                Program.AlertError(error);
                return false;
            }
        }

        private bool checkNgen = false;

        private bool firstCatalogFormRun = false;
        private bool emptyStartLocation = false;
        private enum LoadSettings_Result { INIFileNotFound, INILoadError, Completed }
        private LoadSettings_Result LoadSettings(string startDirectory = null, string selectedFileName = null,
            SortMode? sortModeOption = null, SortMode? preSortModeOption = null, string randomSeedOption = null)
        {
            // コマンドラインから指定された場合キーボードから実行されたとみなす
            var selectFirst = startDirectory != null && selectedFileName == null;

            /*
            if (!File.Exists(Configuration.XmlPath))
            {
                ChangeThumbnailSize((ToolStripMenuItem)thumbnailSizeToolStripMenuItem.DropDownItems[2 + ChangeThumbnailSize_MenuItemOffset]);
                return LoadSettings_Result.INIFileNotFound;
            }
            */

            Color color;
            bool maximized;
            //int width, height;
            Size size;
            Point point;
            string location;
            double tScrollbar;
            int fScrollbar;
            SortMode preSort;
            SortMode sort;
            string seed;
            string filter;
            int thumbnailsize;
            double aspect;
            bool showIcon, showRating, showTags, showFilename;
            NumberOfLinesOfName numOfLines;
            ClipMode clipMode;
            ThumbViewerAligningMode aligning;
            double minimumFrameThickness;
            int scrollA;
            ThumbViewerScrollUnit scrollU;
            bool bookmark;
            int bookmarkWidth, bookmarkHeight;
            bool folderTree;
            CoverBindingMode coverBinding;
            SortSyncMode sortSync;
            bool alwaysHide, readAhead;
            bool onScreenKeyboard;
            SelectionHighlightMode highlight;
            FilterRemovingMode? filterRemoving;
            bool loadPage;
            DoubleClickMode? doubleClick;
            CatalogFormConetxtMenu right, middle, control;
            ItemSelectionFeedback feedback;
            bool treeToBar, barToTree, collap;
            FolderSortMode folderSortMode;
            //bool checkDirectorySize;
            ArchivesInArchiveMode aia;
            ReadOnMemoryMode readOnMemoryMode;
            bool prevImageFilter;
            BindingMode? binding;
            Color viewrColor;
            Color selectedViewerColor;
            InitialFullscreenMode initialFullscreen;
            int maxCapcha;
            bool fileList, thumbnailList, iconInFileList, pageInFileList, ratingInFileList, createTimeInFileList, accessTimeInFileList, writeTimeInFileList, sizeInFileList,
                resolutionInFileList, ratioInFileList, widthInFileList, heightInFileList, lengthInFileList, fpsInFileList;
            ItemLoadLevel archives, images, videos, others;
            string tCache;
            SubfolderMode subfolderMode;
            DockStyle fileListDock;
            int fileListWidth;
            string[] fileListOrder;
            int ratingReference;
            KeyAndValue<string, string>[] alias;
            bool invariantFilter;
            bool mouseGestureEnabled;
            double mouseGestureLineWidth;
            Color mouseGestureLineColor;
            MouseGestureCommand[] mgCommands;
            //var locationHistory = new List<string>();
            //var filterHistory = new List<string>();
            string[] locationHistory, filterHistory;
            try
            {
                var config = new CatalogFormConfig();

                color = config.CurrentProfileColor;
                maximized = config.Maximized;
                size = config.Size; if (size == Size.Empty) size = Size;
                if (config.Point != null) point = (Point)config.Point; else point = Location;
                firstCatalogFormRun = config.Location == null;

                if (string.IsNullOrEmpty(startDirectory))
                {
                    location = config.Location;
                    tScrollbar = config.ThumbnailScrollbar;
                    fScrollbar = config.FileListScrollbar;
                    if (string.IsNullOrEmpty(selectedFileName))
                    {
                        selectedFileName = config.SelectedFileName;
                    }
                }
                else
                {
                    location = startDirectory;
                    if (string.IsNullOrEmpty(selectedFileName))
                    {
                        tScrollbar = 0;
                        fScrollbar = 0;
                    }
                    else
                    {
                        tScrollbar = -1;
                        fScrollbar = -1;
                    }
                }
                if (sortModeOption == null)
                {
                    preSort = config.LastSortMode;
                    sort = config.SortMode;
                    seed = config.RandomSeed;
                }
                else
                {
                    if (preSortModeOption != null)
                    {
                        preSort = (SortMode)preSortModeOption;
                    }
                    else
                    {
                        preSort = config.SortMode;
                    }
                    sort = (SortMode)sortModeOption;
                    if (sort == SortMode.Random && randomSeedOption != null)
                    {
                        seed = randomSeedOption;
                    }
                    else
                    {
                        seed = config.RandomSeed;
                    }
                }
                filter = config.Filter;
                thumbnailsize = config.ThumbnailSize;
                aspect = config.AspectRatio;
                showIcon = config.ShowIcon;
                showRating = config.ShowRating;
                showTags = config.ShowTags;
                showFilename = config.ShowFilename;
                numOfLines = config.NumberOfLinesOfName;
                clipMode = config.ClipMode;
                aligning = config.AligningMode;
                minimumFrameThickness = config.MinimumFrameThickness;
                scrollA = config.ThumbnailMouseWheelScrollAmount;
                scrollU = config.ThumbnailMouseWheelScrollUnit;
                bookmark = config.BookmarkVisible;
                bookmarkWidth = config.BookmarkWidth; if (bookmarkWidth <= 0) bookmarkWidth = pnlLeft.Width; // まずゼロなら初期値に
                bookmarkHeight = config.BookmarkHeight; if (bookmarkHeight <= 0) bookmarkHeight = pnlBookmark.Height;
                folderTree = config.FolderTreeVisible;
                thumbnailList = config.ThumbnailListVisible;
                fileList = config.FileListVisible;
                fileListDock = config.FileListDock;
                fileListWidth = config.FileListWidth;
                fileListOrder = config.FileListOrder;
                iconInFileList = config.IconInFileList;
                pageInFileList = config.PageInFileList;
                ratingInFileList = config.RatingInFileList;
                createTimeInFileList = config.DateCreatedInFileList;
                accessTimeInFileList = config.DateAccessedInFileList;
                writeTimeInFileList = config.DateModifiedInFileList;
                sizeInFileList = config.SizeInFileList;
                resolutionInFileList = config.ResolutionInFileList;
                ratioInFileList = config.RatioInFileList;
                widthInFileList = config.WidthInFileList;
                heightInFileList = config.HeightInFileList;
                lengthInFileList = config.LengthInFileList;
                fpsInFileList = config.FpsInFileList;
                coverBinding = config.CoverBindingMode;
                sortSync = config.SortSyncMode;
                alwaysHide = config.AlwaysHideUI;
                readAhead = config.AllowReadAheadProcess;
                onScreenKeyboard = config.TinyOnScreenKeyboardVisible;
                highlight = config.SelectionHighlightMode;
                filterRemoving = config.FilterRemovingMode;
                loadPage = config.LoadLastViewedPageFromHistory;
                doubleClick = config.DoubleClickFileOpenMode;
                right = config.RightClickContextMenu;
                middle = config.MiddleContextMenu;
                control = config.ControlRightClickContextMenu;
                feedback = config.ItemSelectionFeedback;
                treeToBar = config.SynchroFromTreeToBar;
                barToTree = config.SynchroFromBarToTree;
                collap = config.CollapseOthersWhenSynchronizing;
                folderSortMode = config.FolderSortMode;
                //checkDirectorySize = config.CheckDirectorySize;
                aia = config.ArchivesInArchiveMode;
                readOnMemoryMode = config.ReadOnMemoryMode;
                prevImageFilter = config.OpenInPreviousImageFilterSetting;
                binding = config.DefaultBindingMode;
                viewrColor = config.BackColorOfBuiltInViewer;
                selectedViewerColor = config.SelectedColorForBackColorOfBuiltInViewer;
                initialFullscreen = config.BuiltInViewerInitialFullscreenMode;
                maxCapcha = config.MaxCaptchaCountInOneVideo;
                archives = ParseItemLoadLevel(config.DisplayArchiveFiles);
                images = ParseItemLoadLevel(config.DisplayImageFiles);
                videos = ParseItemLoadLevel(config.DisplayVideoFiles);
                others = ParseItemLoadLevel(config.DisplayOtherFiles);
                tCache = config.ThumbnailCacheRoot;
                subfolderMode = config.SubfolderMode;
                ratingReference = config.RatingReference;
                alias = config.FilterAliasToString;
                invariantFilter = config.InvariantFilter;
                mouseGestureEnabled = config.MouseGestureEnabled;
                mouseGestureLineWidth = config.MouseGestureLineWidth;
                mouseGestureLineColor = config.MouseGestureLineColor;
                mgCommands = config.MouseGestureCommands;

                locationHistory = config.LocationHistory; if (locationHistory == null) locationHistory = new string[0];
                filterHistory = config.FilterHistory; if (filterHistory == null) filterHistory = new string[0];
            }
            catch (Exception error)
            {
                Program.AlertError(error);
                return LoadSettings_Result.INILoadError;
            }
            

            // 最も近いスクリーンにパックする
            var settingRect = new Rectangle(point, size);
            var nearestRect = Screen.FromRectangle(settingRect).WorkingArea;
            settingRect = BetterFormRestoreBounds.Pack(settingRect, nearestRect);
            if (IsLoaded)
            {
                Bounds = settingRect;

                if (maximized) WindowState = FormWindowState.Maximized; // 最大化はサイズと場所決定後に行わないと復元されるときに不自然な表示

                // if (!maximized) SaveSettings_WindowLocationWhenNotMaximized = Location = point; else SaveSettings_WindowLocationWhenNotMaximized = Location;// 最大化時はサイズ変更後ウインドウ位置が復元されない
            }
            else
            {
                //Screen.FromControl(this);
                //Bounds = settingRect;
                
                var evh = null as EventHandler;
                evh = (sender, e) =>
                {
                    Bounds = settingRect;
                    if (maximized) WindowState = FormWindowState.Maximized; // 最大化はサイズと場所決定後に行わないと復元されるときに不自然な表示

                    // if (!maximized) SaveSettings_WindowLocationWhenNotMaximized = Location = point; else SaveSettings_WindowLocationWhenNotMaximized = Location;// 最大化時はサイズ変更後ウインドウ位置が復元されない
                    Load -= evh;
                };
                Load += evh;
            }

            cbLocation.Items.Clear();
            foreach (var h in locationHistory)
            {
                try
                {
                    if (VirtualFolder.DirectoryOrBookmarkExists(h))
                    {
                        cbLocation.Items.Add(h);
                    }
                }
                catch { }
            }
            //zabLocation.Text = location; // setMainPanelWidth より後で

            prevSortMode = preSort;// GetSortIndex(preSort);
            GetSortArray_RandomSeed = seed;
            cbSortBy.SelectedIndex = (int)sort;

            cbFilter.Items.Clear();
            cbFilter.Items.Add("");
            foreach (var h in filterHistory)
            {
                cbFilter.Items.Add(h);
            }

            aliasesToFilteringStrings = new Dictionary<string, string>();
            foreach (var kav in alias) aliasesToFilteringStrings.Add(kav.Key, kav.Value);
            cbFilter.Text = filter;

            if (thumbnailsize < 0 || 5 <= thumbnailsize)
            {
                thumbnailsize = 2;
            }

            NumberOfLinesOfName = numOfLines;
            clipModeByControl = clipMode;
            aspectRatio = aspect;
            setAspectRatioCheckState();

            var temp = tvCatalog.StopUpdateRowsCols;
            tvCatalog.StopUpdateRowsCols = true;
            currentAligning = aligning;
            currentMinimumFrameThickness = minimumFrameThickness;
            tvCatalog.StopUpdateRowsCols = temp;

            setMouseWheelScrollAmount(scrollA, scrollU);

            ChangeThumbnailSize((ToolStripMenuItem)thumbnailSizeToolStripMenuItem.DropDownItems[thumbnailsize + ChangeThumbnailSize_MenuItemOffset]);
            this.showIcon = showIconToolStripMenuItem.Checked = showIcon;
            this.showRating = showRatingToolStripMenuItem.Checked = showRating;
            this.showTags = showTagsToolStripMenuItem.Checked = showTags;
            //tvCatalog.ShowText = showFilenameToolStripMenuItem.Checked = showFilename;
            setShowFileName(showFilename);

            Program.DecodeDisplayIndices(dgvFileList.Columns, fileListOrder);

            if (fileListWidth <= 0) fileListWidth = getFileListWidth();

            if (bookmarkWidth < SidePanellMinWidth) bookmarkWidth = SidePanellMinWidth;
            if (bookmarkHeight < splBookmark.MinSize) bookmarkHeight = splBookmark.MinSize;
            if (fileListWidth < SidePanellMinWidth) fileListWidth = SidePanellMinWidth;

            //pnlBookmark.Height = bookmarkHeight;
            pnlBookmarkNoFillHeight = bookmarkHeight;
            bookmarkToolStripMenuItem.Checked = bookmark;
            pnlLeft.Width = bookmarkWidth;
            if (folderTree)
            {
                folderTreeToolStripMenuItem.Checked = true;
            }
            else
            {
                pnlBookmark.Dock = DockStyle.Fill;
            }
            setFileListDock(fileListDock, keepWidth: false, fixWidth: false);

            pnlRight_NormalWidth = fileListWidth;

            // 最大化でない＋横並びの場合 Load 前だと意味のない 幅変更が起こる
            //setFileListWidthWithoutSettingWidth(fileListWidth);
            EventHandler setFileListWidthWithoutSettingWidth_fileListWidth = null;
            setFileListWidthWithoutSettingWidth_fileListWidth = (sender, e) =>
            {
                setFileListWidthWithoutSettingWidth(fileListWidth);
                Load -= setFileListWidthWithoutSettingWidth_fileListWidth;
                setFileListWidthWithoutSettingWidth_fileListWidth = null;
            };
            Load += setFileListWidthWithoutSettingWidth_fileListWidth;
            
            if (thumbnailList || fileList)
            {
                thumbnailListToolStripMenuItem.Checked = thumbnailList;
                fileListToolStripMenuItem.Checked = fileList;
            }
            else
            {
                fileListToolStripMenuItem.Checked = false;
            }
            tbcIcon.Visible = iconInFileList;
            tbcPage.Visible = pageInFileList;
            tbcRating.Visible = ratingInFileList;
            tbcCreateTime.Visible = createTimeInFileList;
            tbcAccessTime.Visible = accessTimeInFileList;
            tbcWriteTime.Visible = writeTimeInFileList;
            tbcSize.Visible = sizeInFileList;
            tbcResolution.Visible = resolutionInFileList;
            tbcRatio.Visible = ratioInFileList;
            tbcWidth.Visible = widthInFileList;
            tbcHeight.Visible = heightInFileList;
            tbcLength.Visible = lengthInFileList;
            tbcFPS.Visible = fpsInFileList;
            ratingReferenceValue = ratingReference;
            invariantFilteringList = invariantFilter;

            mgCatalog.Enabled = mgFileList.Enabled = mouseGestureEnabled;
            mgCatalog.Width = mgFileList.Width = mouseGestureLineWidth;
            mgCatalog.Color = mgFileList.Color = mouseGestureLineColor;
            if (mgCommands != null)
            {
                var actions = new List<MouseGestureAction>();
                var template = getMouseGestureSettingTemplate();
                foreach (var c in mgCommands)
                {
                    var gesture = c.Gesture;
                    if (gesture == null || gesture.Length == 0) continue;
                    var key = (int)c.Command;
                    var action = template.FirstOrDefault(t => t.Key == key);
                    if (action == default(MouseGestureSettingTemplate)) continue;
                    actions.Add(new MouseGestureAction(key, gesture, action.Action));
                }
                mgCatalog.Actions = mgFileList.Actions = actions.ToArray();
            }
            else
            {
                mgCatalog.Actions = mgFileList.Actions = null;
            }

            if (archives == ItemLoadLevel.Ignore && images == ItemLoadLevel.Ignore && videos == ItemLoadLevel.Ignore && others == ItemLoadLevel.Ignore && !IsDisplay(subfolderMode))
            {
                archives = ItemLoadLevel.Full;
            }

            SelectionHilightMode = highlight;
            if (filterRemoving != null)
            {
                FilterRemovingMode = (FilterRemovingMode)filterRemoving;
            }
            else
            {
                FilterRemovingMode = firstCatalogFormRun ? FilterRemovingMode.WhenMovingLocation : FilterRemovingMode.Never;
            }

            LoadLastViewedPageFromHistory = loadPage;

            // 移行完了後（nullable を外す必要がある）
            // DoubleClickFileOpenMode = doubleClick;

            // 移行用
            if (doubleClick == null)
            {
                /*
                bool exists;
                try
                {
                    exists = File.Exists(Configuration.XmlPath);
                }
                catch
                {
                    exists = false;
                }
                */
                DoubleClickFileOpenMode = !firstCatalogFormRun ? DoubleClickMode.SelectAndClick : DoubleClickMode.IgnoreMouseMove;
            }
            else
            {
                DoubleClickFileOpenMode = (DoubleClickMode)doubleClick;
            }

            RightClickContextMenu = right;
            MiddleClickContextMenu = middle;
            ControlRightClickContextMenu = control;

            ItemSelectionFeedback = feedback;

            setSynchroBetweenTreeAndBar(treeToBar, barToTree);
            CollapseOthersWhenSynchronizing = collap;

            SetFolderSortMode(folderSortMode, reSort: false);

            //CheckDirectorySize = checkDirectorySize;

            ArchivesInArchiveMode = aia;
            if (simplifiedKeyBoard == null)
            {
                tinyOnScreenKeyboardVisible = onScreenKeyboard;
            }
            else
            {
                TinyOnScreenKeyboardVisible = onScreenKeyboard;
            }
            OpenInPreviousImageFilterSetting = prevImageFilter;

            ReadOnMemoryMode = readOnMemoryMode;

            CoverBindingMode = coverBinding;
            BindingMode binding2;
            if (binding == null)
            {
                binding2 = Program.GetBindingModeFromCulture(Message.CurrentLanguage);
            }
            else
            {
                binding2 = (BindingMode)binding;
            }
            SortSyncMode = sortSync;
            SetAlwaysHideUI(alwaysHide, silent: true);
            SetAllowReadAheadProcess(readAhead, silent: true);
            BackColorOfBuiltInViewer = viewrColor;
            SelectedColorForBackColorOfBuiltInViewer = selectedViewerColor;
            SetBuiltInViewerInitialFullscreenMode(initialFullscreen, silent: true);
            MaxCaptchaCountInAVideo = maxCapcha;
            if (tCache != null)
            {
                thumbnailCache = tCache == CatalogFormConfig.NOCACHE ? null : tCache;
            }
            else
            {
                try
                {
                    thumbnailCache = GPSizeThumbnail.SupportADSSize(Application.ExecutablePath, checkNew: true) > 0 ? GPSizeThumbnail.AlternateDataStream :
                        DefaultThumbnailCache;
                }
                catch
                {
                    thumbnailCache = DefaultThumbnailCache;
                }
            }
            //archivesFilesPDFFielsToolStripMenuItem.Checked = archives;
            ArchiveLoadLevel = archives;
            bindingModeByControl = binding2;
            //imageFilesToolStripMenuItem.Checked = images;
            ImageLoadLevel = images;
            //videoFilesToolStripMenuItem.Checked = videos;
            VideoLoadLevel = videos;
            //otherFilesToolStripMenuItem.Checked = others;
            OtherLoadLevel = others;

            SubfolderMode = subfolderMode;

            var generalConfig = new GeneralConfig();

            ApplicationArray = (from info in generalConfig.Applications select info.GetApplicationProvider(this)).ToArray();
            var dynamicStringSelections = generalConfig.DynamicStringSelections;
            var dynamicStringSelectionsEnabled = generalConfig.DynamicStringSelectionsEnabled;
            allowRenameByCmsRightClick = generalConfig.DynamicStringSelectionsAllowUserToRenameItem;
            //startApplicationWithAccessKey = generalConfig.StartWithAccessKey;
            dragAndDropAction = generalConfig.DragAndDropAction;
            checkNgen = generalConfig.CheckNgen;

            loadBookmarkFromConfig();

            var zipTagConfig = new ZipTagConfig();// 準備しているため不要でも読み込まないとエラーになる
            if (string.IsNullOrEmpty(startDirectory))
            {
                currentProfileColor = color;
            }
            else
            {
                var startDirectoryInLower = startDirectory.ToLower();
                var colorCands = new List<Color>();
                foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                {
                    var bm = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                    if (bm != null && bm.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None) // セパレーターなら無視される
                    {
                        var sb = bm.SimpleBookmark;
                        if (sb?.Location?.ToLower() == startDirectoryInLower)
                        {
                            colorCands.Add(bm.Color);
                        }
                    }
                }
                var candCount = colorCands.Count;
                if (candCount == 1 || candCount > 1 && new HashSet<Color>(colorCands).Count == 1)
                {

                    currentProfileColor = colorCands[0];
                }
                else
                {
                    var lastColor = zipTagConfig.ProfileColor; // プログラムを終了しなくても保存されるプロファイルカラー
                    if (colorCands.Count == 0 || colorCands.Contains(lastColor))
                    {
                        currentProfileColor = lastColor;
                    }
                    else
                    {
                        currentProfileColor = colorCands[0];
                    }
                }
            }



            Shown += (sender, e) =>
            {
                if (WindowState != FormWindowState.Minimized)
                {
                    setMainPanelWidth();
                }
            };
            var esl = string.IsNullOrEmpty(location);
            emptyStartLocation = esl;
            EventHandler shown = null; // 言語仕様上、先に適当な値を代入しておく必要がある
            shown = new EventHandler((sender, e) =>
            {
                // 先にテキストボックスを設定する必要があるので
                setNewDynamicStringSelectionToolStripMenuItems(dynamicStringSelectionsEnabled, dynamicStringSelections);

                var nullLocation = esl;

                if (!nullLocation)
                {
                    zabLocation.Text = location; // setMainPanelWidth より後で
                }

                try
                {
                    if (IsSupportedByCatalogFormAndExists(location))
                    {
                        if (selectFirst)
                        {
                            // MakePreview の selectedIndex は dataIndex なので不適切
                            bmwMakePreviewRunWorkerStartingFinalAction = () =>
                            {
                                firstShownItemSelect();
                                bmwMakePreviewRunWorkerStartingFinalAction = null;
                            };
                        }

                        MakePreview_StopResetFilter = true;
                        MakePreview(tScrollbar: tScrollbar, selectedIndex: -1, selectedFileName: selectedFileName, fScrollbar: fScrollbar);
                    }
                    else
                    {
                        if (!nullLocation) MessageBox.Show(this, Message._1CanNotBeOpend.Replace("$1", zabLocation.Text), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        tvCatalog.ScrollBarPercentage = Math.Max(0, tScrollbar);
                        if (fScrollbar >= 0 && fScrollbar < dgvFileList.Rows.Count) dgvFileList.FirstDisplayedScrollingRowIndex = fScrollbar;
                    }
                }
                catch (UriFormatException error)
                {
                    MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    tvCatalog.ScrollBarPercentage = Math.Max(0, tScrollbar);
                    if (fScrollbar >= 0 && fScrollbar < dgvFileList.Rows.Count) dgvFileList.FirstDisplayedScrollingRowIndex = fScrollbar;
                }
                catch (Exception error)
                {
                    MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    tvCatalog.ScrollBarPercentage = Math.Max(0, tScrollbar);
                    if (fScrollbar >= 0 && fScrollbar < dgvFileList.Rows.Count) dgvFileList.FirstDisplayedScrollingRowIndex = fScrollbar;
                }

                // ヒントのため静的な Shown に移動
                //foreach (DataGridViewRow row in dgvDirectoryList.Rows) row.Selected = false;

                Shown -= shown;
            });
            Shown += shown;

            return LoadSettings_Result.Completed;
        }

        public static readonly string DefaultThumbnailCache = Path.Combine(Path.GetDirectoryName(Application.ExecutablePath), "thumbnails");

        private void preferenceToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;
            bool dssEnabled;
            DynamicStringSelectionInfo[] dss;
            var preDDA = dragAndDropAction;
            //var needToReload = Program.ShowSetting(this, out ApplicationArray, out dssEnabled, out dss);
            Program.ShowSetting(this, out ApplicationArray, /*out startApplicationWithAccessKey,*/ out dssEnabled,
                out allowRenameByCmsRightClick, out dss, out dragAndDropAction, out var historyTrimmed);
            setNewDynamicStringSelectionToolStripMenuItems(dssEnabled, dss);
            /*
            if (needToReload && SenseBindingMode())
            {
                UpdatePreview();
            }
            */
            if (historyTrimmed && string.Compare(currentLocation, Program.HistorySorPath, ignoreCase: true) == 0)
            {
                UpdatePreview();
            }
            if (showStartHelpMessage && preDDA != dragAndDropAction)
            {
                tvCatalog.Invalidate();
            }
            AllowFullpower = true;
        }

        private bool SenseBindingMode()
        {
            if (InDirectoryVirtualDirectoryOrSmartDirectory && (IsDisplay(SubfolderMode) || ArchiveLoadLevel != ItemLoadLevel.Ignore) &&
                currentClipMode == ClipMode.PlaClip && ZipPlaInfo.GetOnlyBindingModeFromFullName(currentLocation) == null)
            {
                var zna = ZipNameArray;
                var zma = ZipMaskArray;
                if (zna != null && zma != null)
                {
                    var count = zna.Length;
                    if (zma.Length == count)
                    {
                        for (var i = 0; i < count; i++)
                        {
                            if (zma[i])
                            {
                                var name = zna[i];
                                if (!string.IsNullOrEmpty(name) && (name.Last() == Path.DirectorySeparatorChar || PackedImageLoader.Supports(name)) &&
                                    ZipPlaInfo.GetOnlyBindingModeFromFullName(name) == null)
                                {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        int SetBackgroundMode_ShownRange = 0;
        int[] SetBackgroundMode_WorkerOrder = null;

        // サムネサムネ→リストヘッダ→残りヘッダ→残りサムネ
#if FALSE
        private void SetBackgroundMode(bool checkOrder, int processDecrease, bool DoEvenIfNotBusy = false)
        {
            var refThumbnail = pnlCenter.Visible;
            var refFileList = !refThumbnail || pnlRight.Visible;
            int[] s2d;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray == null || !DoEvenIfNotBusy && !bmwMakePreview.IsBusy) return;

                // ZipPathArray の作成がサブスレッドで行われ、その後メインスレッドで tvCatalog の初期化が行われるため、
                // その間にこの関数が呼びだされた場合インデックスの範囲に矛盾が生じるためこれを回避する。
                var d2s = tvCatalog.DataIndexToShowIndex;
                if (d2s == null || d2s.Length != ZipPathArray.Length)
                {
                    return;
                }

                s2d = tvCatalog.ShowIndexToDataIndex;

                long stt = 0, stp = -1;
                if (checkOrder)
                {
                    long u = -1, d = 0;
                    var Order = new int[ZipPathArray.Length * 2];
                    var alreadyAdded = new bool[ZipPathArray.Length];
                    var idx = 0;
                    var thumbStop = 0;
                    if (refThumbnail)
                    {
                        var preIdx = 0;
                        var start0 = tvCatalog.DisplayedStartShowIndex;
                        var stop = tvCatalog.DisplayedStopShowIndex;
                        var OrderInDisplay = new int[stop - start0];
                        var Distances = new int[stop - start0];
                        var p = tvCatalog.PointToClient(Cursor.Position);
                        int x = 2 * p.X - tvCatalog.gridSizeH, y = 2 * p.Y - tvCatalog.gridSizeV;
                        for (var i = (int)start0; i < stop; i++)
                        {
                            var p2 = tvCatalog.GetUpperLeftClientcoordinateOf(i);
                            int dx = x - 2 * p2.X, dy = y - 2 * p2.Y;
                            OrderInDisplay[preIdx] = i;
                            Distances[preIdx] = dx * dx + dy * dy;
                            preIdx++;
                        }
                        OrderInDisplay = OrderInDisplay.OrderBy(v => Distances[v - start0]).ToArray();
                        for (var i = 0; i < Distances.Length; i++)
                        {
                            var di = s2d[OrderInDisplay[i]];
                            if (!alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di + 1;
                            }
                        }
                        u = start0 - 1;
                        d = stop;
                        stt = start0;
                        stp = stop;
                        thumbStop = idx;
                    }
                    if (refFileList)
                    {
                        var preIdx = 0;
                        var start0 = dgvFileList.FirstDisplayedScrollingRowIndex;
                        var stop = start0 + dgvFileList.DisplayedRowCount(includePartialRow: true) - 1; if (stop >= s2d.Length) stop = s2d.Length - 1;
                        if (stop < start0) start0 = stop = 0;
                        var OrderInDisplay = new int[stop - start0];
                        var Distances = new int[stop - start0];
                        var p = dgvFileList.PointToClient(Cursor.Position);
                        var crec = dgvFileList.ClientRectangle;
                        var mouseShowIndex = dgvFileList.HitTest(crec.X, p.Y).RowIndex;
                        if (mouseShowIndex < 0)
                        {
                            if (p.X < crec.Bottom) mouseShowIndex = (int)start0;
                            else mouseShowIndex = (int)stop - 1;
                        }

                        for (var i = (int)start0; i < stop; i++)
                        {
                            var di = Math.Abs(i - mouseShowIndex);
                            OrderInDisplay[preIdx] = i;
                            Distances[preIdx] = di;
                            preIdx++;
                        }
                        OrderInDisplay = OrderInDisplay.OrderBy(v => Distances[v - start0]).ToArray();
                        for (var i = 0; i < Distances.Length; i++)
                        {
                            var di = s2d[OrderInDisplay[i]];
                            if (!alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di;
                            }
                        }
                        if (!refThumbnail)
                        {
                            u = start0 - 1;
                            d = stop;
                            stt = start0;
                            stp = stop;
                        }
                    }
                    
                    var shownCount = idx;
                    var listCount = shownCount - thumbStop;

                    SetBackgroundMode_ShownRange = idx;

                    long len = tvCatalog.ShowIndexToDataIndex.Length;
                    while (true)
                    {
                        if (stt - u < d - stp && u >= 0)
                        {
                            var di = s2d[u--];
                            if (!alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di;
                            }
                        }
                        else if (d < len)
                        {
                            var di = s2d[d++];
                            if (!alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    while (u >= 0)
                    {
                        var di = s2d[u--];
                        if (!alreadyAdded[di])
                        {
                            alreadyAdded[di] = true;
                            Order[idx++] = 2 * di;
                        }
                    }
                    while (d < len)
                    {
                        var di = s2d[d++];
                        if (!alreadyAdded[di])
                        {
                            alreadyAdded[di] = true;
                            Order[idx++] = 2 * di;
                        }
                    }
                    for (var i = 0; i < d2s.Length; i++)
                    {
                        if (d2s[i] < 0 && ZipMaskArray[i])
                        {
                            Order[idx++] = 2 * i;
                        }
                    }

                    var hideStop = idx;
                    var hideCount = idx - SetBackgroundMode_ShownRange;

                    var listAndhideCount = listCount + hideCount;
                    for (var i = thumbStop; i < hideStop; i++) Order[i + listAndhideCount] = Order[i] + 1;
                    idx += hideStop - thumbStop;


                    for (var i = 0; i < thumbStop; i++) Order[i + idx] = Order[i] - 1;

                    idx += thumbStop;
            

                    SetBackgroundMode_WorkerOrder = new int[idx];
                    Array.Copy(Order, SetBackgroundMode_WorkerOrder, idx);
                    bmwMakePreview.SetWorksOrder(SetBackgroundMode_WorkerOrder);
                }
            }

            if (!CursolIsOnControll() && !(((MouseButtons & MouseButtons.Left) == MouseButtons.Left || cbFilter.Focused) && Form.ActiveForm == this) && AllowFullpower)
            {
                bmwMakePreview.ThreadCount = Math.Max(2, Environment.ProcessorCount - 1);
            }
            else
            {
                try
                {
                    int WaitingDisplayedCount = 0;
                    if (SetBackgroundMode_WorkerOrder != null && SetBackgroundMode_WorkerOrder.Length >= SetBackgroundMode_ShownRange)
                    {
                        for (var i = 0; i < SetBackgroundMode_ShownRange; i++)
                        {
                            var workerIndex = SetBackgroundMode_WorkerOrder[i];
                            if (bmwMakePreview.GetWorkState(workerIndex) == BackgroundMultiWorker.WorkState.Waiting)
                            {
                                WaitingDisplayedCount++;
                            }
                        }
                    }
                    bmwMakePreview.ThreadCount = Math.Max(1, Math.Min(bmwMakePreview.ThreadCount + WaitingDisplayedCount - processDecrease, Environment.ProcessorCount / 2));
                    return;
                }
                catch (Exception error)
                {
                    Program.AlertError(error);
                }
            }
        }
#else

        // サムネヘッダ→リストヘッダ→サムネサムネ→残りヘッダ→残りサムネ
        private void SetBackgroundMode(bool checkOrder, int processDecrease, bool DoEvenIfNotBusy = false)
        {
            if (CreatingZipPathArray) return;
            if (RenameShownArchive_MakePreviewSleepRequest) return;

            var refThumbnail = pnlCenter.Visible;
            var refFileList = !refThumbnail || pnlRight.Visible;

            var cursorPosition = Cursor.Position;
            Point? cursorPositionOnTvCatalog = null;

            int thumbnailBitForShown, thumbnailBitForHidden;
            if (!refFileList)
            {
                thumbnailBitForShown = 1;
                thumbnailBitForHidden = 1;
            }
            else if (!refThumbnail)
            {
                thumbnailBitForShown = 0;
                thumbnailBitForHidden = 0;
            }
            else
            {
                Point p;
                p = tvCatalog.PointToClient(cursorPosition);
                /*
                try
                {
                    p = tvCatalog.PointToClient(cursorPosition);
                }
                catch(Exception e)
                {
                    p = Point.Empty;
                   // throw;
                }
                */
                cursorPositionOnTvCatalog = p;
                if (tvCatalog.Bounds.Contains(p))
                {
                    thumbnailBitForShown = 1;
                    thumbnailBitForHidden = 1;
                }
                else
                {
                    thumbnailBitForShown = 1;
                    thumbnailBitForHidden = 0;
                }
            }


            /*
            // ヘッダ優先
            //var thumbnailBitForShown = refFileList ? 0 : 1;

            // サムネイル優先
            var thumbnailBitForShown = refThumbnail ? 1 : 0;


            var thumbnailBitForHidden = refFileList ? 0 : 1;
            */

            int[] s2d;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray == null || !DoEvenIfNotBusy && !bmwMakePreview.IsBusy) return;

                // ZipPathArray の作成がサブスレッドで行われ、その後メインスレッドで tvCatalog の初期化が行われるため、
                // その間にこの関数が呼びだされた場合インデックスの範囲に矛盾が生じるためこれを回避する。
                var d2s = tvCatalog.DataIndexToShowIndex;
                if (d2s == null || d2s.Length != ZipPathArray.Length || d2s.Length > initialZipPathLength)
                {
                    return;
                }

                s2d = tvCatalog.ShowIndexToDataIndex;

                long stt = 0, stp = -1;
                if (checkOrder)
                {
                    long u = -1, d = 0;
                    var Order = new int[initialZipPathLength * 2];
                    var alreadyAdded = new bool[initialZipPathLength];
                    var idx = 0;
                    var thumbStop = 0;
                    if (refThumbnail)
                    {
                        var preIdx = 0;
                        var start0 = tvCatalog.DisplayedStartShowIndex;
                        var stop = tvCatalog.DisplayedStopShowIndex;
                        var OrderInDisplay = new int[stop - start0];
                        var Distances = new int[stop - start0];
                        var p = cursorPositionOnTvCatalog == null ? tvCatalog.PointToClient(cursorPosition) : (Point)cursorPositionOnTvCatalog;
                        int x = 2 * p.X - tvCatalog.gridSizeH, y = 2 * p.Y - tvCatalog.gridSizeV;
                        for (var i = (int)start0; i < stop; i++)
                        {
                            var p2 = tvCatalog.GetUpperLeftClientcoordinateOf(i);
                            int dx = x - 2 * p2.X, dy = y - 2 * p2.Y;
                            OrderInDisplay[preIdx] = i;
                            Distances[preIdx] = dx * dx + dy * dy;
                            preIdx++;
                        }
                        OrderInDisplay = OrderInDisplay.OrderBy(v => Distances[v - start0]).ToArray();
                        for (var i = 0; i < Distances.Length; i++)
                        {
                            var di = s2d[OrderInDisplay[i]];
                            if (di < initialZipPathLength && !alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di | thumbnailBitForShown;
                            }
                        }
                        u = start0 - 1;
                        d = stop;
                        stt = start0;
                        stp = stop;
                        thumbStop = idx;
                    }
                    if (refFileList)
                    {
                        var preIdx = 0;
                        var start0 = dgvFileList.FirstDisplayedScrollingRowIndex;
                        var stop = start0 + dgvFileList.DisplayedRowCount(includePartialRow: true); if (stop > s2d.Length) stop = s2d.Length;
                        if (stop < start0 || stop < 0 || start0 < 0) start0 = stop = 0;
                        var OrderInDisplay = new int[stop - start0];
                        var Distances = new int[stop - start0];
                        Point p;
                        p = dgvFileList.PointToClient(cursorPosition);
                        /*
                        try
                        {
                            p = dgvFileList.PointToClient(cursorPosition);
                        }
                        catch (Exception e)
                        {
                            p = Point.Empty;
                        }
                        */
                        var crec = dgvFileList.ClientRectangle;
                        var mouseShowIndex = dgvFileList.HitTest(crec.X, p.Y).RowIndex;
                        if (mouseShowIndex < 0)
                        {
                            if (p.X < crec.Bottom) mouseShowIndex = (int)start0;
                            else mouseShowIndex = (int)stop - 1;
                        }

                        for (var i = (int)start0; i < stop; i++)
                        {
                            var di = Math.Abs(i - mouseShowIndex);
                            OrderInDisplay[preIdx] = i;
                            Distances[preIdx] = di;
                            preIdx++;
                        }
                        OrderInDisplay = OrderInDisplay.OrderBy(v => Distances[v - start0]).ToArray();
                        for (var i = 0; i < Distances.Length; i++)
                        {
                            var di = s2d[OrderInDisplay[i]];
                            if (di < initialZipPathLength && !alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di;
                            }
                        }
                        if (!refThumbnail)
                        {
                            u = start0 - 1;
                            d = stop;
                            stt = start0;
                            stp = stop;
                        }
                    }

                    var shownCount = idx;
                    var listCount = shownCount - thumbStop;
                    {
                        for (var i = 0; i < thumbStop; i++) Order[i + idx] = Order[i] ^ 1;
                        idx += thumbStop;
                    }

                    SetBackgroundMode_ShownRange = idx;

                    long len = tvCatalog.ShowIndexToDataIndex.Length;
                    while (true)
                    {
                        if (stt - u < d - stp && u >= 0)
                        {
                            var di = s2d[u--];
                            if (di < initialZipPathLength && !alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di | thumbnailBitForHidden;
                            }
                        }
                        else if (d < len)
                        {
                            var di = s2d[d++];///
                            if (di < initialZipPathLength && !alreadyAdded[di])
                            {
                                alreadyAdded[di] = true;
                                Order[idx++] = 2 * di | thumbnailBitForHidden;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                    while (u >= 0)
                    {
                        var di = s2d[u--];
                        if (di < initialZipPathLength && !alreadyAdded[di])
                        {
                            alreadyAdded[di] = true;
                            Order[idx++] = 2 * di | thumbnailBitForHidden;
                        }
                    }
                    while (d < len)
                    {
                        var di = s2d[d++];
                        if (di < initialZipPathLength && !alreadyAdded[di])
                        {
                            alreadyAdded[di] = true;
                            Order[idx++] = 2 * di | thumbnailBitForHidden;
                        }
                    }
                    for (var i = 0; i < initialZipPathLength; i++)
                    {
                        if (d2s[i] < 0 && ZipMaskArray[i])
                        {
                            Order[idx++] = 2 * i | thumbnailBitForHidden;
                        }
                    }

                    var hideStop = idx;
                    var hideCount = idx - SetBackgroundMode_ShownRange;

                    var shownAndhideCount = shownCount + hideCount;
                    for (var i = thumbStop; i < shownCount; i++) Order[i + shownAndhideCount] = Order[i] ^ 1;

                    var hideAndListCount = shownCount + shownAndhideCount - SetBackgroundMode_ShownRange;

                    for (var i = SetBackgroundMode_ShownRange; i < hideStop; i++) Order[i + hideAndListCount] = Order[i] ^ 1;


                    idx = hideStop + hideAndListCount;

                    SetBackgroundMode_WorkerOrder = new int[idx];
                    Array.Copy(Order, SetBackgroundMode_WorkerOrder, idx);
                    bmwMakePreview.SetWorksOrder(SetBackgroundMode_WorkerOrder);
                }
            }

            if (AllowFullpower && !CursolIsOnControll() && !(((MouseButtons & MouseButtons.Left) == MouseButtons.Left || cbFilter.Focused) && Form.ActiveForm == this))
            {
                bmwMakePreview.ThreadCount = Math.Max(2, Environment.ProcessorCount - 1);
                Program.SetPriority(ProcessPriorityClass.BelowNormal);
            }
            else
            {
                try
                {
                    int WaitingDisplayedCount = 0;
                    if (SetBackgroundMode_WorkerOrder != null && SetBackgroundMode_WorkerOrder.Length >= SetBackgroundMode_ShownRange)
                    {
                        for (var i = 0; i < SetBackgroundMode_ShownRange; i++)
                        {
                            var workerIndex = SetBackgroundMode_WorkerOrder[i];
                            if (bmwMakePreview.GetWorkState(workerIndex) == BackgroundMultiWorker.WorkState.Waiting)
                            {
                                WaitingDisplayedCount++;
                            }
                        }
                    }
                    bmwMakePreview.ThreadCount = Math.Max(1, Math.Min(bmwMakePreview.ThreadCount + WaitingDisplayedCount - processDecrease, Environment.ProcessorCount / 2));
                    Program.SetPriority(ProcessPriorityClass.Normal);
                    return;
                }
                catch (Exception error)
                {
                    Program.AlertError(error);
                }
            }
        }
#endif


        private void tvCatalog_DisplayedChanged(object sender, EventArgs e)
        {
            SetBackgroundMode(true, 0);
        }

        private void dgvFileList_Scroll(object sender, ScrollEventArgs e)
        {
            //if (!tvCatalog.Visible)
            {
                SetBackgroundMode(true, 0);
            }
        }

        private void OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser user, MouseEventArgs e)
        {
            try
            {
                var selectedIndex = tvCatalog.SelectedIndex;
                if (selectedIndex < 0) return;
                var zpa = ZipPathArray;
                if (zpa == null || zpa.Length != tvCatalog.Count) return;
                var zna = ZipNameArray;
                if (zna == null || zna.Length != zpa.Length) return;
                var path = zpa[selectedIndex];
                var name = zna[selectedIndex];
                if (CoverSettingMode)
                {
                    setCoverToThisToolStripMenuItem_Click(null, null);
                    return;
                }
                RecentFfmpegExists = MovieThumbnailLoader.ffmpegExists();
                var isDir = name.EndsWith(Path.DirectorySeparatorChar.ToString());
                if (ApplicationArray != null)
                {
                    foreach (var app in ApplicationArray)
                    {
                        if (app.IsDefaultFor(path, isDir))
                        {
                            activateManager.CancelAcrivatorReady(e);
                            app.Exec(user, path);
                            return;
                        }
                    }
                }
                throw new Exception(Message.ApplicationIsNotSpecified);
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
            }
        }

        public void OpenInBuiltInViewer(string path)
        {
            if (string.IsNullOrEmpty(path)) return;

            var extendedPath = path;

            var altSepPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            var originalPath = path;
            if (altSepPos >= 0)
            {
                path = path.Substring(0, altSepPos);
            }

            var zpa = ZipPathArray;
            if (zpa == null)
            {
                OpenWaitingProcess(path, 0, false);
                return;
            }
            var index = Array.IndexOf(zpa, originalPath);
            if (index < 0)
            {
                OpenWaitingProcess(path, 0, false);
                return;
            }
            var lra = LoadResultArray;
            if (lra == null || lra.Length != zpa.Length)
            {
                OpenWaitingProcess(path, 0, false);
                return;
            }
            var lr = lra[index];
            if (lr == LoadResult.FileNotFound)
            {
                MessageBox.Show(this, Message.NoReadableFile, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            else if (lr == LoadResult.LoadError)
            {
                MessageBox.Show(this, Message.FailedToLoadFile, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (altSepPos < 0)
            {
                var zga = ZipPageArray;
                if (zga == null || zpa.Length != zpa.Length)
                {
                    OpenWaitingProcess(path, 0, false);
                    return;
                }
                try
                {
                    OpenWaitingProcess(path, zga[index], false);
                }
                catch
                {
                }
            }
            else
            {
                //OpenWaitingProcess(path, index, coverSettingMode: false);
                OpenWaitingProcess(extendedPath, -1, coverSettingMode: false);
            }
        }

        public bool IsNotEmptyAndIsNotLoadError(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            var zpa = ZipPathArray;
            if (zpa == null) return true;
            var index = Array.IndexOf(zpa, path);
            if (index < 0) return true;
            var lra = LoadResultArray;
            if (lra == null || lra.Length != zpa.Length) return true;
            var lr = lra[index];
            return lr != LoadResult.FileNotFound && lr != LoadResult.LoadError;
        }

        private bool OpenInBuiltInViewer(int index)
        {
            if (index < 0) return false;
            var zpa = ZipPathArray;
            if (zpa == null || index != zpa.Length) return false;
            var path = zpa[index];
            var lra = LoadResultArray;
            if (lra == null || lra.Length != zpa.Length) return false;
            var lr = lra[index];
            if (lr == LoadResult.FileNotFound || lr == LoadResult.LoadError) return false;
            var zga = ZipPageArray;
            if (zga == null || zpa.Length != zpa.Length) return false;
            try
            {
                OpenWaitingProcess(path, zga[index], false);
            }
            catch
            {
                return false;
            }
            return true;
        }

        private void OpenSelectedArchiveInBuiltInViewer()
        {
            OpenInBuiltInViewer(tvCatalog.SelectedIndex);
        }

        private void checkFileOrDirectoryExists(string path, bool isDirectory)
        {
            if (isDirectory)
            {
                if (!Directory.Exists(path))
                {
                    throw new DirectoryNotFoundException();
                }
            }
            else
            {
                if (!File.Exists(path))
                {
                    throw new FileNotFoundException(null, path);
                }
            }
        }

        private bool setDropDownList()
        {
            if (CloseVisibleContextMenuStrips_ContextMenuStripCollection == null)
            {
                if (addToolStripMenuItemDropDown == null || ratingFilterToolStripMenuItemDropDown == null) return false;

                var result = new HashSet<ToolStripDropDown>();
                foreach (var field in typeof(CatalogForm).GetFields(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Instance))
                {
                    var type = field.FieldType;
                    if (type == typeof(System.Windows.Forms.ContextMenuStrip))
                    {
                        var cms = field.GetValue(this) as System.Windows.Forms.ToolStripDropDown;
                        if (cms == null)
                        {
                            return false;
                        }
                        result.Add(cms);
                    }
                    else if (type == typeof(System.Windows.Forms.ToolStripMenuItem))
                    {
                        // 例外
                        switch (field.Name)
                        {
                            // 閉じる必要がなく、初めからは存在しないもの
                            case nameof(zabLocation_DirectoryButtonContextMenuStripOpening_SelectTreeNode): continue;
                            case nameof(zabLocation_DirectoryButtonContextMenuStripOpening_EditSmartFolder): continue;

                            // all でなければ閉じないもの
                            case nameof(viewToolStripMenuItem): continue;
                            case nameof(thumbnailSizeToolStripMenuItem): continue;
                        }

                        var tsmi = field.GetValue(this) as System.Windows.Forms.ToolStripMenuItem;
                        if (tsmi == null)
                        {
                            return false;
                        }
                        var ddm = tsmi.DropDown;
                        if (ddm != null) result.Add(ddm);
                    }
                }

                // 実体は null にされているので
                if (!result.Contains(addToolStripMenuItemDropDown)) result.Add(addToolStripMenuItemDropDown);
                if (!result.Contains(ratingFilterToolStripMenuItemDropDown)) result.Add(ratingFilterToolStripMenuItemDropDown);

                CloseVisibleContextMenuStrips_ContextMenuStripCollection = result.ToArray();
            }

            return true;
        }

        private System.Windows.Forms.ToolStripDropDown[] CloseVisibleContextMenuStrips_ContextMenuStripCollection;
        private void CloseVisibleContextMenuStrips(bool all = true)
        {
            if (!setDropDownList()) return;

            foreach (var cms in CloseVisibleContextMenuStrips_ContextMenuStripCollection)
            {
                cms.Close();
            }

            foreach (var cms in zabLocation.VisibleContextMenuStripSet)
            {
                try
                {
                    cms.Close();
                }
                catch { } // 破棄済みに備える
            }

            var temp = setTagFilteringMenuItems_DropDown;
            if (temp != null)
            {
                foreach (var cms in temp)
                {
                    try
                    {
                        cms.Close();
                    }
                    catch { } // 破棄済みに備える
                }
            }

            if (all)
            {
                try
                {
                    viewToolStripMenuItem.DropDown.Close();
                }
                catch { } // 破棄済みに備える
                try
                {
                    thumbnailSizeToolStripMenuItem.DropDown.Close();
                }
                catch { } // 破棄済みに備える
            }
        }
        private bool VisibleCobtextMenuStripExists()
        {
            if (!setDropDownList()) return false;

            if (CloseVisibleContextMenuStrips_ContextMenuStripCollection.Any(cms => cms.Visible) ||
            zabLocation.VisibleContextMenuStripSet.Any(cms =>
            {
                try
                {
                    return cms.Visible;
                }
                catch { return false; }  // 破棄済みに備える
            })) return true;

            var temp = setTagFilteringMenuItems_DropDown;
            if (temp != null)
            {
                foreach (var cms in temp)
                {
                    try
                    {
                        if (cms.Visible) return true;
                    }
                    catch { } // 破棄済みに備える
                }
            }

            return false;
        }

        private new Keys ModifierKeys
        {
            get
            {
                return simplifiedKeyBoard.GetModifierKeys();
            }
        }

        private static Rectangle ClickRectangle(Point center)
        {
            var size = SystemInformation.DoubleClickSize;
            var w = size.Width;
            var h = size.Height;
            return new Rectangle(center.X - w / 2, center.Y - h / 2, w | 1, h | 1);
        }

        private static bool InDoubleClickTime(int now, int lastClickedTime)
        {
            var delta = now - lastClickedTime;
            return 0 <= delta && delta <= SystemInformation.DoubleClickTime;
        }

        //private static readonly TimeSpan DoubleClickTime = TimeSpan.FromMilliseconds(SystemInformation.DoubleClickTime);

        //private int tvCatalog_MouseDown_LastExcuseIndex = -1;
        //private DateTime tvCatalog_MouseDown_LastExcuseTime = DateTime.MinValue;
        //int count;
        private int tvCatalog_MouseDown_ClickCount = 0;
        private int tvCatalog_MouseDown_LastClickTime = 0;
        private int tvCatalog_MouseDown_LastClickIndex = -1;
        private Rectangle tvCatalog_MouseDown_LastClickRectangle = Rectangle.Empty;
        private void tvCatalog_MouseDown(object sender, MouseEventArgs e2)
        {
            // ActivateManager 側で対応
            /*
            if (cbLocation.Focused) // アクティブ化停止を妨げないように条件を付けておく
            {
                tvCatalog.Focus(); // ロケーションバーをボタンモードに戻すのが主な目的。UserControl のときは不要だった。
            }
            */

            LatestControledControl = sender as Control;

            var e = e2 as HandlableMouseEventArgs;

            if (e.Button == MouseButtons.Right)
            {
                if (AllowRightDragFromThumbnail)
                {
                    var index = tvCatalog.PointToIndex(e.Location);
                    if (index >= 0)
                    {
                        var dragStart = !mgCatalog.Enabled;
                        if (!dragStart)
                        {
                            var selected = index == tvCatalog.SelectedIndexDelay;
                            if (!selected)
                            {
                                var selectedIndices = tvCatalog.SelectedIndices;
                                selected = selectedIndices.Length >= 2 && selectedIndices.Contains(index);
                            }
                            dragStart = selected;
                        }
                        if (!dragStart)
                        {
                            simplifiedKeyBoard.GetModifierKeys(upHeldKeys: (e2.Button & mgCatalog.MouseButtons) == 0 || !mgCatalog.Enabled);
                            e.Handled = true;
                        }
                    }
                    else
                    {
                        e.Handled = true;
                        if (!mgCatalog.Enabled)
                        {
                            rightClickContextMenuPrepareAndShow(Cursor.Position, ModifierKeys); // この時点で ModifierKeys のホールド解除
                        }
                    }
                }
                else
                {
                    var mk = simplifiedKeyBoard.GetModifierKeys(upHeldKeys: (e2.Button & mgCatalog.MouseButtons) == 0 || !mgCatalog.Enabled); // こちらが後なので upHeldKeys = true で良い
                    if (!mgCatalog.Enabled)
                    {
                        rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                    }
                    e.Handled = true;
                }
            }
            else
            {
                var mk = simplifiedKeyBoard.GetModifierKeys(upHeldKeys: (e2.Button & mgCatalog.MouseButtons) == 0 || !mgCatalog.Enabled); // こちらが後なので upHeldKeys = true で良い
                if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Middle)
                {
                    var onStars = !drawRating_Bound.IsEmpty && showRating && InDirectoryVirtualDirectoryOrSmartDirectory;
                    Rectangle imageRectangle = Rectangle.Empty;
                    if (onStars)
                    {
                        imageRectangle = tvCatalog.PointToContainerImageRectangle(e.Location);
                        var backRectangle = drawRating_Bound;
                        backRectangle.X += imageRectangle.X;
                        backRectangle.Y += imageRectangle.Y;
                        onStars = backRectangle.Contains(e.Location);
                    }
                    if (onStars)
                    {
                        int? r;
                        if (e.Button == MouseButtons.Left)
                        {
                            r = Math.Max(1, Math.Min(5, 5 * (e.Location.X - (imageRectangle.X + drawRating_StarsBound.Left)) / drawRating_StarsBound.Width + 1));
                        }
                        else
                        {
                            r = null;
                        }
                        SetRating(r, tvCatalog.PointToIndex(e.Location));
                        e.Handled = true;
                    }
                    else
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            if ((mk & (Keys.Control | Keys.Shift)) == 0)
                            {
                                var dcm = DoubleClickFileOpenMode;
                                var clickedIndex = dcm ==
                                    DoubleClickMode.SelectAndClick ? tvCatalog.SelectedIndexDelay : tvCatalog.PointToIndex(e.Location);
                                if (clickedIndex >= 0)
                                {
                                    var now = Environment.TickCount;
                                    if (
                                        tvCatalog_MouseDown_LastClickIndex == clickedIndex &&
                                        InDoubleClickTime(now, tvCatalog_MouseDown_LastClickTime) &&
                                        (dcm != DoubleClickMode.Standard ||
                                        tvCatalog_MouseDown_ClickCount == 0 ||
                                        tvCatalog_MouseDown_LastClickRectangle.Contains(e.Location))
                                        )
                                    {
                                        tvCatalog_MouseDown_ClickCount++;
                                    }
                                    else
                                    {
                                        tvCatalog_MouseDown_ClickCount = 1;
                                        tvCatalog_MouseDown_LastClickRectangle = ClickRectangle(e.Location);
                                    }
                                    tvCatalog_MouseDown_LastClickIndex = clickedIndex;
                                    tvCatalog_MouseDown_LastClickTime = now;

                                    if (clickedIndex == tvCatalog.SelectedIndex)
                                    {
                                        if (dcm == DoubleClickMode.SelectAndClick && tvCatalog_MouseDown_ClickCount == 1
                                            || dcm != DoubleClickMode.SelectAndClick && tvCatalog_MouseDown_ClickCount == 2)
                                        {
                                            tvCatalog.DoMouseUp();
                                            OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.MouseClick, e2);
                                            e.Handled = true;
                                        }
                                    }
                                }
                                else
                                {
                                    tvCatalog_MouseDown_ClickCount = 0;
                                    tvCatalog_MouseDown_LastClickIndex = -1;
                                }
                            }

                            /*
                            var index = tvCatalog.SelectedIndex;
                            if (tvCatalog.SelectedIndexDelay == index && (mk & (Keys.Control | Keys.Shift)) == 0)
                            {
                                var now = DateTime.Now;
                                var noChat = index != tvCatalog_MouseDown_LastExcuseIndex || now - tvCatalog_MouseDown_LastExcuseTime > DoubleClickTime;
                                tvCatalog_MouseDown_LastExcuseIndex = index;
                                tvCatalog_MouseDown_LastExcuseTime = now;
                                if (noChat)
                                {
                                    //optionToolStripMenuItem.Text = (count++).ToString();
                                    tvCatalog.DoMouseUp();
                                    OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.MouseClick);
                                }
                            }
                            */
                        }
                        else
                        {
                            //cmsRightClickPrepareAndShow(Cursor.Position, onlyTag: true);
                            middleClickContextMenuPrepareAndShow(Cursor.Position);
                        }
                    }
                }
                else
                {
                    CloseVisibleContextMenuStrips();

                    if (e.Button == MouseButtons.XButton1)
                    {
                        btnGoToBack_Click(null, null);
                    }
                    else if (e.Button == MouseButtons.XButton2)
                    {
                        btnGoToForward_Click(null, null);
                    }
                }
            }
        }

        private void FocusLatestControledControl()
        {
            // LatestControledControl は null にならないように工夫されている
            LatestControledControl.Focus();
        }

        //private int dgvFileList_MouseDown_LastExcuseIndex = -1;
        //private DateTime dgvFileList_MouseDown_LastExcuseTime = DateTime.MinValue;

        private int dgvFileList_MouseDown_ClickCount = 0;
        private int dgvFileList_MouseDown_LastClickTime = 0;
        private int dgvFileList_MouseDown_LastClickIndex = -1;
        private Rectangle dgvFileList_MouseDown_LastClickRectangle = Rectangle.Empty;
        private void dgvFileList_MouseDown(object sender, MouseEventArgs e2)
        {
            // ActivateManager 側で対応
            /*
            if (cbLocation.Focused) // アクティブ化停止を妨げないように条件を付けておく
            {
                dgvFileList.Focus(); // ロケーションバーをボタンモードに戻すのが主な目的。ActiveteManager を使うことで詳細表示でも必要になった
            }
            */

            LatestControledControl = sender as Control;

            var e = e2 as HandlableMouseEventArgs;

            var hit = dgvFileList.HitTest(e.X, e.Y);
            if ((e.Button == MouseButtons.Right && !AllowRightDragFromDetail) || e.Button == MouseButtons.Middle)
            {
                if (!dgvFileList.ReadOnly && !(hit.RowIndex == dgvFileList.CurrentCell.RowIndex && hit.ColumnIndex == dgvFileList.CurrentCell.ColumnIndex))
                {
                    dgvFileList.EndEdit();
                }

                Keys mk = Keys.None;
                if ((e.Button & mgFileList.MouseButtons) == 0 || !mgFileList.Enabled)
                {
                    mk = ModifierKeys;
                }

                if (e.Button == MouseButtons.Middle || !mgFileList.Enabled)
                {
                    if (hit.RowIndex >= 0)
                    {
                        var clickedRow = dgvFileList.Rows[hit.RowIndex];
                        if (!clickedRow.Selected)
                        {
                            var temp = selectionSynchronizing;
                            selectionSynchronizing = true;
                            foreach (DataGridViewRow row in dgvFileList.SelectedRows.Cast<DataGridViewRow>().ToArray())
                            {
                                row.Selected = false;
                            }
                            selectionSynchronizing = temp;
                            clickedRow.Selected = true;
                            dgvFileList.CurrentCell = clickedRow.Cells[tbcFileName.Index];
                        }
                    }

                    if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                    {
                        tvCatalog.SelectedIndices = null;
                    }

                    if (e.Button == MouseButtons.Right)
                    {
                        if (!mgFileList.Enabled)
                        {
                            if (hit.RowIndex >= 0 || hit.Type == DataGridViewHitTestType.None)
                            {
                                rightClickContextMenuPrepareAndShow(Cursor.Position, mk);
                            }
                        }
                    }
                    else if (hit.RowIndex >= 0 && hit.ColumnIndex != tbcRating.Index)
                    {
                        //cmsRightClickPrepareAndShow(Cursor.Position, onlyTag: true);
                        middleClickContextMenuPrepareAndShow(Cursor.Position);
                    }
                }
            }
            else if (e.Button == MouseButtons.Right) // この条件で AllowRightDragFromDetail 確定
            {
                if (!dgvFileList.ReadOnly && !(hit.RowIndex == dgvFileList.CurrentCell.RowIndex && hit.ColumnIndex == dgvFileList.CurrentCell.ColumnIndex))
                {
                    dgvFileList.EndEdit();
                }

                bool selected;
                if (hit.RowIndex >= 0)
                {
                    var clickedRow = dgvFileList.Rows[hit.RowIndex];
                    if (!(selected = clickedRow.Selected) && !mgFileList.Enabled)
                    {
                        var temp = selectionSynchronizing;
                        selectionSynchronizing = true;
                        foreach (DataGridViewRow row in dgvFileList.SelectedRows.Cast<DataGridViewRow>().ToArray())
                        {
                            row.Selected = false;
                        }
                        selectionSynchronizing = temp;
                        clickedRow.Selected = true;
                        dgvFileList.CurrentCell = clickedRow.Cells[tbcFileName.Index];
                    }
                }
                else
                {
                    selected = false;
                }

                var s2d = tvCatalog.ShowIndexToDataIndex;
                var index = hit.RowIndex >= 0 && hit.RowIndex < s2d.Length ? s2d[hit.RowIndex] : -1;
                if (index >= 0)
                {
                    var dragStart = !mgFileList.Enabled || selected;
                    if (!dragStart)
                    {
                        simplifiedKeyBoard.GetModifierKeys(upHeldKeys: (e2.Button & mgFileList.MouseButtons) == 0 || !mgFileList.Enabled);
                        e.Handled = true;
                    }
                }
                else
                {
                    e.Handled = true;
                    if (hit.Type == DataGridViewHitTestType.None)
                    {
                        if (!mgFileList.Enabled)
                        {
                            tvCatalog.SelectedIndex = -1;
                            rightClickContextMenuPrepareAndShow(Cursor.Position, ModifierKeys); // この時点で ModifierKeys のホールド解除
                        }
                    }
                }
                /*
                else if (hit.ColumnIndex >= 0)
                {
                    e.Handled = true;

                    if (!mgFileList.Enabled)
                    {
                        tvCatalog.SelectedIndex = -1;
                        rightClickContextMenuPrepareAndShow(Cursor.Position, ModifierKeys); // この時点で ModifierKeys のホールド解除
                    }
                }
                */
            }
            else if (e.Button == MouseButtons.Left)
            {
                var md = ModifierKeys;

                if (hit.RowIndex >= 0)
                {
                    var onRating = hit.ColumnIndex == tbcRating.Index;
                    e.Handled = onRating;
                    if (!onRating && dgvFileList.ReadOnly)
                    {
                        var s2d = tvCatalog.ShowIndexToDataIndex;
                        if ((md & (Keys.Control | Keys.Shift)) == 0 && s2d != null && s2d.Length > hit.RowIndex)
                        {
                            var dcm = DoubleClickFileOpenMode;
                            var clickedIndex = dcm == DoubleClickMode.SelectAndClick && !dgvFileList.Rows[hit.RowIndex].Selected ? -1 : s2d[hit.RowIndex];
                            if (clickedIndex >= 0)
                            {
                                var now = Environment.TickCount;
                                if (
                                    dgvFileList_MouseDown_LastClickIndex == clickedIndex &&
                                    InDoubleClickTime(now, dgvFileList_MouseDown_LastClickTime) &&
                                    (dcm != DoubleClickMode.Standard ||
                                    dgvFileList_MouseDown_ClickCount == 0 ||
                                    dgvFileList_MouseDown_LastClickRectangle.Contains(e.Location))
                                    )
                                {
                                    dgvFileList_MouseDown_ClickCount++;
                                }
                                else
                                {
                                    dgvFileList_MouseDown_ClickCount = 1;
                                    dgvFileList_MouseDown_LastClickRectangle = ClickRectangle(e.Location);
                                }
                                dgvFileList_MouseDown_LastClickIndex = clickedIndex;
                                dgvFileList_MouseDown_LastClickTime = now;

                                if (dcm == DoubleClickMode.SelectAndClick && dgvFileList_MouseDown_ClickCount == 1
                                    || dcm != DoubleClickMode.SelectAndClick && dgvFileList_MouseDown_ClickCount == 2)
                                {
                                    if (tvCatalog.SelectedIndex >= 0)
                                    {
                                        OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.MouseClick, e2);
                                        e.Handled = true;
                                    }
                                }
                            }
                            else
                            {
                                dgvFileList_MouseDown_ClickCount = 0;
                                dgvFileList_MouseDown_LastClickIndex = -1;
                            }
                            /*
                            var index = hit.ColumnIndex;

                            var now = DateTime.Now;
                            var noChat = index != dgvFileList_MouseDown_LastExcuseIndex || now - dgvFileList_MouseDown_LastExcuseTime > DoubleClickTime;
                            dgvFileList_MouseDown_LastExcuseIndex = index;
                            dgvFileList_MouseDown_LastExcuseTime = now;

                            if (noChat)
                            {
                                //tvCatalog.DoMouseUp();
                                //Application.DoEvents();

                                // ★ DataGridView の不具合の影響を受ける
                                // DataGridViewBugFixed 内で詳細の説明
                                OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.MouseClick);

                                //Application.DoEvents();
                            }
                            */
                        }
                    }
                }
                if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                {
                    tvCatalog.SelectedIndices = null;
                    dgvFileList.EndEdit();
                }
            }

            //Thread.Sleep(1);
            //Application.DoEvents();
            try
            {
                Task.Run(() => Invoke((MethodInvoker)(() => dgvFileList.Update())));
            }
            catch (ObjectDisposedException) { }
        }


        private int pointToIndex(Point screenLocation)
        {
            Point localLocation;
            if (thumbnailListToolStripMenuItem.Checked)
            {
                localLocation = tvCatalog.PointToClient(screenLocation);
                if (tvCatalog.ClientRectangle.Contains(localLocation))
                {
                    return tvCatalog.PointToIndex(localLocation);
                }
            }

            localLocation = dgvFileList.PointToClient(screenLocation);
            if (dgvFileList.ClientRectangle.Contains(localLocation))
            {
                var showIndex = dgvFileList.HitTest(localLocation.X, localLocation.Y).RowIndex;
                var s2d = tvCatalog.ShowIndexToDataIndex;
                return 0 <= showIndex && s2d != null && showIndex < s2d.Length ? s2d[showIndex] : -1;
            }
            else return -1;
        }

        /*
        private static bool CanBeCopied(string path)
        {
            if (string.IsNullOrEmpty(path)) return false;
            var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            if (altPos < 0) return true;
            return PackedImageLoader.Supports(path.Substring(0, altPos));
        }
        */

        public bool RecentFfmpegExists;

        private void rightClickContextMenuPrepareAndShow(Point point, Keys mk)
        {
            if ((mk & Keys.Control) == Keys.Control)
            {
                contextMenuPrepareAndShow(point, ControlRightClickContextMenu);
            }
            else
            {
                contextMenuPrepareAndShow(point, RightClickContextMenu);
            }
        }

        private void rightClickContextMenuPrepareAndShow(Point point)
        {
            contextMenuPrepareAndShow(point, RightClickContextMenu);
        }

        private void middleClickContextMenuPrepareAndShow(Point point)
        {
            contextMenuPrepareAndShow(point, MiddleClickContextMenu);
        }
        private void ctrlRightClickContextMenuPrepareAndShow(Point point)
        {
            contextMenuPrepareAndShow(point, ControlRightClickContextMenu);
        }

        private void contextMenuPrepareAndShow(Point point, CatalogFormConetxtMenu menu)
        {
            if (menu == CatalogFormConetxtMenu.ZipPla)
            {
                cmsRightClickPrepareAndShow_(point, false);
            }
            else if (menu == CatalogFormConetxtMenu.Tag)
            {
                cmsRightClickPrepareAndShow_(point, true);
            }
            else
            {
                explorerContextMenuPrepareAndShow(point);
            }
        }

        private void explorerContextMenuPrepareAndShow(Point point)
        {
            if (CreatingZipPathArray) return;

            AllowFullpower = false;

            var clickedIndex = pointToIndex(point);
            if (clickedIndex < 0)
            {
                AllowFullpower = true;
                cmsRightClickPrepareAndShow_(point, false);
                return;
            }

            string[] pathArray;
            bool[] isDirArray;
            getSelectedPathArray(clickedIndex, out pathArray, out isDirArray);
            if (pathArray == null || isDirArray == null)
            {
                AllowFullpower = true;
                return;
            }

            var infoArray = (from path in pathArray select new FileInfo(path)).ToArray();
            pathArray = null;
            isDirArray = null;

            if (cmsRightClick.Visible)
            {
                cmsRightClick.Close();
            }

            explorerContextMenu.ShowContextMenu(infoArray, point);

            AllowFullpower = true;
        }
        readonly Peter.ShellContextMenu explorerContextMenu = new Peter.ShellContextMenu();

        private CheckState[] cmsRightClickPrepareAndShow_TagInitialCheckState = null;
        private string[] cmsRightClickPrepareAndShow_SelectedPathList = null;
        private ToolStripItem[] cmsRightClickPrepareAndShow_tagToolStripMenuItemDropDownItems = null;
        //private string[] cmsRightClickPrepareAndShow_TagNames = null;
        bool cmsRightClickPrepareAndShow_ZipPlaInfoReady = false;
        string cmsRightClickPrepareAndShow_InitialTextBoxText;
        private void cmsRightClickPrepareAndShow_(Point point, bool onlyTag = false)
        {
            if (CreatingZipPathArray) return;

            AllowFullpower = false;

            if (cmsRightClick.Visible)
            {
                cmsRightClick.Close();
            }

            if (tvCatalog.SelectedIndicesCount == 0)
            {
                if (!onlyTag)
                {
                    pasteOnBackGroundToolStripMenuItem.Enabled = (InRealDirectory || InVirtualDirectory) && clipBoardHasFile(InRealDirectory);
                    if (this != ActiveForm) Activate();
                    AllowFullpower = false;
                    cmsRightClickOnBackground.Show(point);
                }
                else
                {
                    AllowFullpower = true;
                }
                return;
            }

            var clickedIndex = pointToIndex(point);
            if (clickedIndex < 0)
            {
                AllowFullpower = true;
                return;
            }

            bool openedInFileList = dgvFileList.RectangleToScreen(dgvFileList.ClientRectangle).Contains(point);

            var selectedIndex = tvCatalog.SelectedIndex;
            var singleSelected = selectedIndex >= 0;

            if (openedInFileList && !dgvFileList.ReadOnly)
            {
                var clientPosition = dgvFileList.PointToClient(point);
                var hit = dgvFileList.HitTest(clientPosition.X, clientPosition.Y);
                if (hit.RowIndex == dgvFileList.CurrentCell.RowIndex)
                {
                    AllowFullpower = true;
                    return;
                }
            }


            listFileToolStripMenuItem.Enabled = InDirectoryVirtualDirectoryOrSmartDirectory;

            try
            {
                deleteonlyForListFileToolStripMenuItem.Enabled = InDirectoryVirtualDirectoryOrSmartDirectory;
            }
            catch
            {
                deleteonlyForListFileToolStripMenuItem.Enabled = false;
            }

            if (InVirtualDirectory)
            {
                deleteonlyForListFileToolStripMenuItem.Text = Message.RemoveFromVirtualFolder;
            }
            else
            {
                deleteonlyForListFileToolStripMenuItem.Text = Message.Delete;
            }

            /*
            var externalViewer = GetExternalViewer();
            if (string.IsNullOrEmpty(externalViewer))
            {
                openInExternalViewerToolStripMenuItem.Visible = false;
            }
            else
            {
                openInExternalViewerToolStripMenuItem.Visible = true;
                openInExternalViewerToolStripMenuItem.Text = Regex.Replace(Path.GetFileNameWithoutExtension(externalViewer), "^(.*)$", Message.OpenIn1);
                openInExternalViewerToolStripMenuItem.Enabled = singleSelected;
            }
            */

            /*
            var isDir = false;
            try
            {
                isDir = Directory.Exists(currentLocation);
            }
            catch { }
            */

            /*
            openInBuiltinViewerToolStripMenuItem.Enabled = singleSelected;
            openInAssociationToolStripMenuItem.Enabled = singleSelected;
            openInExplorerToolStripMenuItem.Enabled = singleSelected;
            */
            propertiesToolStripMenuItem.Enabled = singleSelected;

            var vfBookmarks = getVirtualFoldersInBookmarks().ToArray();
            var spPos = listFileToolStripMenuItem.DropDownItems.IndexOf(tmsSeparatorForVirtualFolder);

            // 新規作成が下（デザイナで移動すること）
            while (spPos > 0)
            {
                listFileToolStripMenuItem.DropDownItems[--spPos].Dispose();
            }
            if (vfBookmarks.Length == 0)
            {
                tmsSeparatorForVirtualFolder.Visible = false;
            }
            else
            {
                tmsSeparatorForVirtualFolder.Visible = true;
                var tsmiList = new List<ToolStripMenuItem>();
                foreach (var bookmark in vfBookmarks)
                {
                    var tsmi = new ToolStripMenuItem();
                    tsmi.Text = Message.AddTo1.Replace("$1", bookmark.ToString());
                    var simpleBookmark = bookmark.SimpleBookmark;
                    tsmi.Enabled = simpleBookmark?.Location != currentLocation;
                    var vfPath = simpleBookmark?.Location;
                    tsmi.Click += (sender, e) => addSelectedToList(true, sorPath: vfPath);
                    tsmiList.Add(tsmi);
                }
                var ddi = listFileToolStripMenuItem.DropDownItems;
                ddi.Clear();
                if (string.Compare(currentLocation, Program.HistorySorPath, ignoreCase: true) == 0)
                {
                    ddi.AddRange(tsmiList.Concat(new ToolStripItem[2] { tmsSeparatorForVirtualFolder, addToNewListToolStripMenuItem }).ToArray());
                }
                else
                {
                    ddi.AddRange(tsmiList.Concat(new ToolStripItem[3] { tmsSeparatorForVirtualFolder, addToNewListToolStripMenuItem, removeFromHistoryToolStripMenuItem }).ToArray());
                }
            }

            // 新規作成が上（デザイナで移動すること、履歴から削除は未実装）
            /*
            while (spPos + 1 < listFileToolStripMenuItem.DropDownItems.Count)
            {
                listFileToolStripMenuItem.DropDownItems[spPos + 1].Dispose();
            }
            if (vfBookmarks.Length == 0)
            {
                tmsSeparatorForVirtualFolder.Visible = false;
            }
            else
            {
                tmsSeparatorForVirtualFolder.Visible = true;
                var tsmiList = new List<ToolStripMenuItem>();
                foreach (var bookmark in vfBookmarks)
                {
                    var tsmi = new ToolStripMenuItem();
                    tsmi.Text = Message.AddTo1.Replace("$1", bookmark.ToString());
                    var simpleBookmark = bookmark.SimpleBookmark;
                    tsmi.Enabled = simpleBookmark?.Location != currentLocation;
                    var vfPath = simpleBookmark?.Location;
                    tsmi.Click += (sender, e) => addSelectedToList(true, sorPath: vfPath);
                    tsmiList.Add(tsmi);
                }
                listFileToolStripMenuItem.DropDownItems.AddRange(tsmiList.ToArray());
            }
            */

            ZipPlaInfo zipPlaInfo = null;
            ZipPlaInfo[] zipPlaInfos = null;
            var selectedIndices = tvCatalog.SelectedIndices; if (selectedIndices?.Contains(clickedIndex) != true)
            {
                AllowFullpower = true;
                return;
            }
            string[] selectedNameArray = new string[selectedIndices.Length];
            string[] selectedPathArray = new string[selectedIndices.Length];
            //bool allSelectionLoaded;
            //bool allSelectionArchive
            bool allSelectionArchiveOrDirectoryOrEmptyDirectory;
            bool atLeast1SelectionArchive;
            bool allSelectionEntity;
            //bool allSelectionCanBeCopied;
            //bool isSingleEmpty = false;
            //bool isSingleCannotOpen = false;
            var singlePath = "";
            var singleName = "";
            bool allSelectionFile;
            lock (ZipPathArrayLocker)
            {
                if (singleSelected)
                {
                    if (ZipPathArray == null || selectedIndex >= ZipPathArray.Length) selectedIndex = -1;
                    if (selectedIndex >= 0)
                    {
                        singlePath = ZipPathArray[selectedIndex];
                        singleName = ZipNameArray[selectedIndex];
                        zipPlaInfo = new ZipPlaInfo(singlePath);
                        zipPlaInfos = new ZipPlaInfo[1] { zipPlaInfo };
                    }
                }
                else if (selectedIndices.Length > 1 && ZipPathArray != null)
                {
                    zipPlaInfos = new ZipPlaInfo[selectedIndices.Length];
                    for (var i = 0; i < selectedIndices.Length; i++)
                    {
                        var index = selectedIndices[i];
                        if (index >= ZipPathArray.Length)
                        {
                            zipPlaInfos = null;
                            break;
                        }
                        zipPlaInfos[i] = new ZipPlaInfo(ZipPathArray[index]);
                    }
                }
                if (ZipNameArray == null)
                {
                    selectedNameArray = null;
                    selectedPathArray = null;
                    //allSelectionLoaded = false;
                    //allSelectionArchive = false;
                    allSelectionArchiveOrDirectoryOrEmptyDirectory = false;
                    atLeast1SelectionArchive = false;
                    allSelectionEntity = false;
                    //allSelectionCanBeCopied = false;
                    allSelectionFile = false;
                }
                else
                {
                    //allSelectionLoaded = true;
                    //allSelectionArchive = true;
                    allSelectionArchiveOrDirectoryOrEmptyDirectory = true;
                    atLeast1SelectionArchive = false;
                    allSelectionEntity = InDirectoryVirtualDirectoryOrSmartDirectory;
                    //allSelectionCanBeCopied = InDirectoryVirtualDirectoryOrSmartDirectory || InArchive;
                    allSelectionFile = !InArchive && !InMovie;
                    for (var i = 0; i < selectedIndices.Length; i++)
                    {
                        var index = selectedIndices[i];
                        if (index >= ZipNameArray.Length)
                        {
                            selectedNameArray = null;
                            selectedPathArray = null;
                            //allSelectionLoaded = false;
                            //allSelectionArchive = false;
                            allSelectionArchiveOrDirectoryOrEmptyDirectory = false;
                            atLeast1SelectionArchive = false;
                            allSelectionEntity = false;
                            //allSelectionCanBeCopied = false;
                            allSelectionFile = false;
                            break;
                        }
                        var selectedName = selectedNameArray[i] = ZipNameArray[index];
                        var path = ZipPathArray[index];
                        selectedPathArray[i] = path;
                        var loadResult = LoadResultArray[index];
                        //if (allSelectionLoaded && (loadResult == LoadResult.NotYet))// || loadResult == LoadResult.FileNotFound))
                        {
                            //    allSelectionLoaded = false;
                        }
                        var thisIsFolder = selectedName.Length > 0 && selectedName.Last() == Path.DirectorySeparatorChar;
                        if (allSelectionFile && thisIsFolder)
                        {
                            allSelectionFile = false;
                        }

                        /*
                        if (allSelectionArchive && (loadResult == LoadResult.LoadError || loadResult == LoadResult.FileNotFound ||
                                !(thisIsFolder || PackedImageLoader.Supports(ZipPathArray[index]))))
                        {
                            allSelectionArchive = false;
                        }
                        */
                        if (allSelectionArchiveOrDirectoryOrEmptyDirectory && ((!thisIsFolder && (loadResult == LoadResult.LoadError || loadResult == LoadResult.FileNotFound)) ||
                                !(thisIsFolder || PackedImageLoader.Supports(path))))
                        {
                            allSelectionArchiveOrDirectoryOrEmptyDirectory = false;
                        }
                        if (!atLeast1SelectionArchive && !(loadResult == LoadResult.LoadError || loadResult == LoadResult.FileNotFound ||
                                !(thisIsFolder || PackedImageLoader.Supports(path))))
                        {
                            atLeast1SelectionArchive = true;
                        }
                        if (InVirtualDirectory)
                        {
                            var notEntity = true;
                            if (allSelectionEntity && (notEntity = path.Contains(Path.AltDirectorySeparatorChar)))
                            {
                                allSelectionEntity = false;
                            }
                            /*
                            if (allSelectionCanBeCopied && (notEntity || !CanBeCopied(path)))
                            {
                                allSelectionCanBeCopied = false;
                            }
                            */
                        }
                        /*
                        if (singleSelected && i == 0 && (loadResult == LoadResult.FileNotFound || loadResult == LoadResult.LoadError))
                        {
                            isSingleCannotOpen = true;
                        }
                        */
                    }

                }
            }

            cmsRightClickPrepareAndShow_SelectedPathList = selectedPathArray;

            //var isSingleDirectory = singleSelected && selectedNameArray != null && selectedNameArray.Length == 1 &&
            //    selectedNameArray[0].EndsWith(Path.DirectorySeparatorChar.ToString());

            /*
            moveToThisFolderToolStripMenuItem.Enabled = isSingleDirectory;

            if (BuiltInViewerIsDefault())
            {
                if (isSingleCannotOpen)
                {
                    if (isSingleDirectory)
                    {
                        openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Regular);
                        openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                        openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Regular);
                        openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                        openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Regular);
                        openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = null;
                        moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Bold);
                        moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                    }
                    else
                    {
                        openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Regular);
                        openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                        openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Regular);
                        openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                        openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Bold);
                        openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                        moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Regular);
                        moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = null;
                    }
                }
                else
                {
                    openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Bold);
                    openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                    openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Regular);
                    openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                    openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Regular);
                    openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = null;
                    moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Regular);
                    moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = null;
                }

            }
            else
            {
                openInBuiltinViewerToolStripMenuItem.Font = new Font(openInBuiltinViewerToolStripMenuItem.Font, FontStyle.Regular);
                openInBuiltinViewerToolStripMenuItem.ShortcutKeyDisplayString = null;
                openInExternalViewerToolStripMenuItem.Font = new Font(openInExternalViewerToolStripMenuItem.Font, FontStyle.Bold);
                openInExternalViewerToolStripMenuItem.ShortcutKeyDisplayString = "Enter";
                openInAssociationToolStripMenuItem.Font = new Font(openInAssociationToolStripMenuItem.Font, FontStyle.Regular);
                openInAssociationToolStripMenuItem.ShortcutKeyDisplayString = null;
                moveToThisFolderToolStripMenuItem.Font = new Font(moveToThisFolderToolStripMenuItem.Font, FontStyle.Regular);
                moveToThisFolderToolStripMenuItem.ShortcutKeyDisplayString = null;

            }
            */

            var ffmpegExists = MovieThumbnailLoader.ffmpegExists();
            RecentFfmpegExists = ffmpegExists;
            AppInContextMenuEnabled = true;
            setAppInContextMenu(clickedIndex); // RecentFfmpegExists を使う


            renameToolStripMenuItem.Visible = openedInFileList;
            renameToolStripMenuItem.Enabled = false;

            var singleMovie = singleSelected && allSelectionFile && MovieThumbnailLoader.Supports(singleName);
            //var ffmpegExists = InArchive || (singleSelected && !InMovie && !singleMovie) || MovieThumbnailLoader.ffmpegExists(); // ffmpeg の存在が要求されない場合はチェックしない

            var singleImage = allSelectionFile && singleSelected && ImageLoader.SupportsImageAtLeastThumbnailReading(singlePath, ffmpegExists);

            setThumbnailManuallyToolStripMenuItem.Visible = !singleImage && !InMovie;
            setCoverToThisToolStripMenuItem.Visible = InMovie;

            var singleDir = !string.IsNullOrEmpty(singleName) && singleName.Last() == Path.DirectorySeparatorChar;
            if (InMovie || (!(InSmartDirectory || InVirtualDirectory) && (allSelectionFile &&
                (singleImage ||
                //PackedImageLoader.Supports(singlePath) ||
                (singleSelected && atLeast1SelectionArchive) ||
                (ffmpegExists && MovieThumbnailLoader.Supports(singlePath))) || singleDir)))
            {
                setCoverOfParentFolderToThisToolStripMenuItem.Visible = true;
                if (isNoneRootItem(singlePath))
                {
                    if (InMovie)
                    {
                        setCoverOfParentFolderToThisToolStripMenuItem.Enabled = true;
                        setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                    }
                    else if (isZipPlaCoverImageFile(singlePath))
                    {
                        setCoverOfParentFolderToThisToolStripMenuItem.Enabled = false;
                        setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                    }
                    else
                    {
                        // 既に親フォルダの表紙が設定されているかどうかで表示内容を変更する場合
                        /*
                        try
                        {
                            if (File.Exists(Path.Combine(Path.GetDirectoryName(singlePath), ZipPlaCoverImageFileWithExtension)))
                            {

                                setCoverOfParentFolderToThisToolStripMenuItem.Enabled = false;
                                setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis; !
                            }
                            else
                            {
                                setCoverOfParentFolderToThisToolStripMenuItem.Enabled = false;
                                setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                            }
                        }
                        catch
                        {
                            setCoverOfParentFolderToThisToolStripMenuItem.Enabled = false;
                            setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                        }
                        */

                        // 変更しない場合
                        if (singleDir)
                        {
                            // Enabled はサムネイルの存在チェック後
                            //setCoverOfParentFolderToThisToolStripMenuItem.Enabled = true;
                        }
                        else
                        {
                            setCoverOfParentFolderToThisToolStripMenuItem.Enabled = true;
                        }
                        setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                    }
                }
                else
                {
                    setCoverOfParentFolderToThisToolStripMenuItem.Enabled = false;
                    setCoverOfParentFolderToThisToolStripMenuItem.Text = Message.SetCoverOfParentFolderToThis;
                }

            }
            else
            {
                setCoverOfParentFolderToThisToolStripMenuItem.Visible = false;
            }

            /*
            if(setCoverOfParentFolderToThisToolStripMenuItem.Visible)
            {
            }*/

            //copyToolStripMenuItem.Enabled = InDirectoryVirtualDirectoryOrSmartDirectory && allSelectionEntity;
            copyToolStripMenuItem.Enabled = (InDirectoryVirtualDirectoryOrSmartDirectory && allSelectionEntity) || InArchive || (InMovie && singleSelected);
            if (InMovie && singleSelected)
            {
                copyToolStripMenuItem.Text = Message.CopyCapturedImage;
            }
            else
            {
                copyToolStripMenuItem.Text = Message.Copy;
            }
            pasteToolStripMenuItem.Enabled = (InRealDirectory || InVirtualDirectory) && selectedIndices.Length <= 1 && clipBoardHasFile(InRealDirectory);

            var thumbnailCanBeSet = false;

            var renamable = false;
            var renamableByCmsTextBox = false; // イベント呼び出し前に書き換えられる
            if (zipPlaInfos != null)
            //if (zipPlaInfos != null && (allSelectionLoaded))
            //if(zipPlaInfos != null && (singleSelected || allSelectionLoaded)) // ユーザーが有効になるパターンを理解できない恐れ
            {
                cmsRightClickPrepareAndShow_ZipPlaInfoReady = true;

                var singleArchive = singleSelected && atLeast1SelectionArchive;// (singleName.EndsWith(Path.DirectorySeparatorChar.ToString()) || PackedImageLoader.SupportedArchivesPath.IsMatch(singlePath));
                var singleMovieOrSingleInMovie = singleMovie || singleSelected && InMovie; // ffmpeg が無くても削除のために表示する
                var singleInArchive = singleSelected && InArchive;
                //if (allSelectionLoaded)
                {
                    renamable = InDirectoryVirtualDirectoryOrSmartDirectory && allSelectionEntity;// !singlePath.Contains(Path.AltDirectorySeparatorChar);
                    ratingToolStripMenuItem.Enabled = renamable;
                    cutToolStripMenuItem.Enabled = InRealDirectory && allSelectionEntity;

                    // ページ方向はフォルダにも設定する
                    pageSequenceToolStripMenuItem.Visible = pageSequenceToolStripMenuItem.Enabled = allSelectionArchiveOrDirectoryOrEmptyDirectory;// allSelectionArchive;

                    // 表紙を番号で指定するためフォルダに適応するのは適切ではない
                    // 表紙をファイル名のハッシュ値で指定すればよいが、ファイル名が長くなってしまう。ハッシュ値の計算時間はランダムソートで使っているくらいなので問題にはならない
                    //thumbnailToolStripMenuItem.Visible = thumbnailToolStripMenuItem.Enabled = ( singleArchive && allSelectionFile) || singleMovieOrSingleInMovie || singleInArchive || singleImage;

                    // ↓ 削除はいつでも行えるように

                    thumbnailCanBeSet = (singleArchive && allSelectionFile) || singleMovieOrSingleInMovie || singleInArchive || singleImage;
                    thumbnailToolStripMenuItem.Visible = thumbnailToolStripMenuItem.Enabled = true;

                    if (!thumbnailCanBeSet)
                    {
                        if (!singleDir) setCoverOfParentFolderToThisToolStripMenuItem.Visible = false;
                        setThumbnailManuallyToolStripMenuItem.Visible = false;
                    }
                    setThumbnailManuallyToolStripMenuItem.Enabled = thumbnailCanBeSet && !singleImage && ((ffmpegExists || !singleMovie) && singleName?.EndsWith(Path.DirectorySeparatorChar.ToString()) != true); // フォルダに対する表紙設定は表紙を番号で指定する仕様上意味がなく、内蔵ビューアでも実装していない
                    tagToolStripMenuItem.Enabled = renamable;

                    renameToolStripMenuItem.Enabled = singleSelected && renamable;
                }
                /*
                else
                {
                    ratingToolStripMenuItem.Enabled = false;
                    cutToolStripMenuItem.Enabled = false;
                    pageSequenceToolStripMenuItem.Visible = allSelectionArchive;
                    pageSequenceToolStripMenuItem.Enabled = false;
                    thumbnailToolStripMenuItem.Enabled = false || singleMovieOrSingleInMovie || singleInArchive;
                    thumbnailToolStripMenuItem.Visible = singleArchive || singleMovieOrSingleInMovie || singleInArchive;
                    setThumbnailManuallyToolStripMenuItem.Enabled = false;
                    tagToolStripMenuItem.Enabled = false;
                }
                */

                var ratingHistogram = new int[6];
                var pageSequenceHistogram = new int[4];
                var thumbnailHistogram = 0;
                if (zipPlaInfos != null && selectedNameArray != null && selectedPathArray != null &&
                    zipPlaInfos.Length == selectedNameArray.Length && zipPlaInfos.Length == selectedPathArray.Length)
                {
                    for (var i = 0; i < selectedNameArray.Length; i++)
                    {
                        var name = selectedNameArray[i];
                        if (string.IsNullOrEmpty(name)) continue;
                        if (name.Last() == Path.DirectorySeparatorChar)
                        {
                            try
                            {
                                if (File.Exists(Path.Combine(selectedPathArray[i], ZipPlaCoverImageFileWithExtension)))
                                {
                                    thumbnailHistogram++;
                                }
                            }
                            catch { }
                        }
                        else
                        {
                            var info = zipPlaInfos[i];
                            var r = info.Rating;
                            if (r == null) ratingHistogram[0]++;
                            else if (0 < r && r <= 5) ratingHistogram[(int)r]++;

                            var p = info.BindingModeForSet;
                            if (p == null) pageSequenceHistogram[0]++;
                            else if (p == BindingMode.LeftToRight) pageSequenceHistogram[1]++;
                            else if (p == BindingMode.RightToLeft) pageSequenceHistogram[2]++;
                            else pageSequenceHistogram[3]++;

                            var t = info.ThumbnailInfo;
                            if (t != null) thumbnailHistogram++;
                        }
                    }
                }

                var zipPlaInfosCount = zipPlaInfos.Length;

                noneToolStripMenuItem.CheckState = ratingHistogram[0] == 0 ? CheckState.Unchecked : ratingHistogram[0] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                star1toolStripMenuItem.CheckState = ratingHistogram[1] == 0 ? CheckState.Unchecked : ratingHistogram[1] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                star2toolStripMenuItem.CheckState = ratingHistogram[2] == 0 ? CheckState.Unchecked : ratingHistogram[2] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                star3toolStripMenuItem.CheckState = ratingHistogram[3] == 0 ? CheckState.Unchecked : ratingHistogram[3] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                star4toolStripMenuItem.CheckState = ratingHistogram[4] == 0 ? CheckState.Unchecked : ratingHistogram[4] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                star5toolStripMenuItem.CheckState = ratingHistogram[5] == 0 ? CheckState.Unchecked : ratingHistogram[5] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;

                defaultToolStripMenuItem.CheckState = pageSequenceHistogram[0] == 0 ? CheckState.Unchecked : pageSequenceHistogram[0] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                leftToRightToolStripMenuItem.CheckState = pageSequenceHistogram[1] == 0 ? CheckState.Unchecked : pageSequenceHistogram[1] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                rightToLeftToolStripMenuItem.CheckState = pageSequenceHistogram[2] == 0 ? CheckState.Unchecked : pageSequenceHistogram[2] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;
                singlePageToolStripMenuItem.CheckState = pageSequenceHistogram[3] == 0 ? CheckState.Unchecked : pageSequenceHistogram[3] < zipPlaInfosCount ? CheckState.Indeterminate : CheckState.Checked;

                /*
                ZipPlaInfo locationZipPlaInfo = null;
                if(InMovie)
                {
                    locationZipPlaInfo = new ZipPlaInfo(currentLocation);
                }
                */

                if (singleDir)
                {
                    setCoverOfParentFolderToThisToolStripMenuItem.Enabled = thumbnailHistogram > 0;
                }

                if (singleImage)
                {
                    //clearThumbnailSettingToolStripMenuItem.Visible = false; // 一貫性のため表紙の削除は常に表示する
                    clearThumbnailSettingToolStripMenuItem.Visible = true;
                    clearThumbnailSettingToolStripMenuItem.Enabled = !(InMovie || InArchive) && thumbnailHistogram > 0;
                }
                else
                {
                    clearThumbnailSettingToolStripMenuItem.Visible = true;
                    if (InDirectoryVirtualDirectoryOrSmartDirectory)
                    {
                        clearThumbnailSettingToolStripMenuItem.Enabled = thumbnailHistogram > 0;
                    }
                    else if ((InMovie || InArchive) && LocationZipPlaInfo != null)
                    {
                        var hasThumbnailInfo = LocationZipPlaInfo.ThumbnailInfo != null;
                        clearThumbnailSettingToolStripMenuItem.Enabled = hasThumbnailInfo;
                        if (InMovie) // 違えば Visible でないので設定不要
                        {
                            setCoverToThisToolStripMenuItem.Enabled = thumbnailCanBeSet && singleSelected && (!hasThumbnailInfo || !LocationZipPlaInfo.ThumbnailInfo.Equals(getMoviePostionTuple(singleName)));
                        }
                    }
                    else
                    {
                        clearThumbnailSettingToolStripMenuItem.Enabled = false;
                    }
                }

                //tagToolStripMenuItem.Enabled = true;
                tagToolStripMenuItem.DropDownItems.Clear();



                ToolStripMenuItem[] items;
                CheckState[] initialCheckStates;
                var tags = Tags;
                if (tags == null) tags = new ZipTag[0];
                Program.SetTagsToToolStripMenuItems(tagToolStripMenuItem, out items, out initialCheckStates, 0, tags, zipPlaInfos);

                cmsRightClickPrepareAndShow_TagInitialCheckState = initialCheckStates;
                //cmsRightClickPrepareAndShow_TagNames = (from tag in tags select tag.Name).ToArray();

                if (items.Length > 0)
                {
                    tagToolStripMenuItem.DropDownItems.Add(new ToolStripSeparator());
                    items[0].ShortcutKeyDisplayString = Message.RightClickNotToClose;
                    if (items.Length > 1)
                    {
                        items[1].ShortcutKeyDisplayString = Message.RightFlickIsAlsoOk;
                        if (items.Length > 2)
                        {
                            items[2].ShortcutKeyDisplayString = Message.SameAsAbove;
                        }
                    }

                    /*
                    if(onlyTag)
                    {
                        for (var i = 0; i < items.Length; i++)
                        {
                            var item = items[i];
                            var initState = initialCheckStates[i];
                            item.MouseUp += (sender2, e2) =>
                            {
                                if (e2.Button == MouseButtons.Middle)
                                {
                                    switch (item.CheckState)
                                    {
                                        case CheckState.Unchecked:
                                            item.CheckState = CheckState.Checked;
                                            break;
                                        case CheckState.Indeterminate:
                                            item.CheckState = CheckState.Unchecked;
                                            break;
                                        default:
                                            item.CheckState = initState == CheckState.Indeterminate ? CheckState.Indeterminate : CheckState.Unchecked;
                                            break;
                                    }
                                    cmsRightClick.Invalidate();
                                }
                            };
                        }
                    }
                    */
                }

                var uncheckAll = new ToolStripMenuItem(Message.UncheckAll);
                uncheckAll.Enabled = initialCheckStates.Any(item => item != CheckState.Unchecked);
                //uncheckAll.ShortcutKeyDisplayString = Message.RightClickNotToClose;
                /*
                uncheckAll.Click += (sender2, e2) =>
                {
                    foreach (var item in items)
                    {
                        item.Checked = false;
                    }
                    uncheckAll.Enabled = false;
                };*/
                var checkedChangedByUncheckAll = false;
                foreach (var item in items)
                {
                    item.CheckStateChanged += (sender2, e2) =>
                    {
                        if (checkedChangedByUncheckAll) return;
                        uncheckAll.Enabled = items.Any(i => i.CheckState != CheckState.Unchecked);
                        //if (renamableByCmsTextBox)
                        {
                            for (var i = 0; i < initialCheckStates.Length; i++)
                            {
                                if (items[i].CheckState != initialCheckStates[i])
                                {
                                    rightClickFileNameToolStripTextBox.ReadOnly = true;
                                    SetAppInContextMenuEnabled(false);
                                    return;
                                }
                            }
                            if (renamableByCmsTextBox) rightClickFileNameToolStripTextBox.ReadOnly = false;
                            SetAppInContextMenuEnabled(true);
                        }
                    };
                }
                uncheckAll.MouseDown += (sender2, e2) =>
                {
                    if (e2.Button == MouseButtons.Right)
                    {
                        cmsRightClick.AutoClose = false;
                        tagToolStripMenuItem.DropDown.AutoClose = false;
                        //uncheckAll.Enabled = false; // ここで無効化すると MouseUp や MouseLeave が発生しない
                    }

                    if (e2.Button == MouseButtons.Right || e2.Button == MouseButtons.Left)
                    {
                        checkedChangedByUncheckAll = true;
                        foreach (var item in items)
                        {
                            item.Checked = false;
                        }
                        checkedChangedByUncheckAll = false;
                        //if (renamableByCmsTextBox)
                        {
                            for (var i = 0; i < initialCheckStates.Length; i++)
                            {
                                if (items[i].CheckState != initialCheckStates[i])
                                {
                                    rightClickFileNameToolStripTextBox.ReadOnly = true;
                                    SetAppInContextMenuEnabled(false);
                                    return;
                                }
                            }
                            if (renamableByCmsTextBox) rightClickFileNameToolStripTextBox.ReadOnly = false;
                            SetAppInContextMenuEnabled(true);
                        }
                    }
                };
                uncheckAll.MouseUp += (sender2, e2) =>
                {
                    if (e2.Button == MouseButtons.Right)
                    {
                        cmsRightClick.AutoClose = true;
                        tagToolStripMenuItem.DropDown.AutoClose = true;
                        if (uncheckAll.Enabled && !items.Any(i => i.CheckState != CheckState.Unchecked)) uncheckAll.Enabled = false;
                    }
                };
                uncheckAll.MouseLeave += (sender2, e2) =>
                {
                    cmsRightClick.AutoClose = true;
                    tagToolStripMenuItem.DropDown.AutoClose = true;
                    if (uncheckAll.Enabled && !items.Any(i => i.CheckState != CheckState.Unchecked)) uncheckAll.Enabled = false;
                };
                tagToolStripMenuItem.DropDownItems.Insert(0, uncheckAll);
                tagToolStripMenuItem.DropDownItems.Insert(1, new ToolStripSeparator());

                var tagEditor = new ToolStripMenuItem(Message.EditTags + "...");
                tagEditor.Click += tagEditorToolStripMenuItem_Click;
                tagToolStripMenuItem.DropDownItems.Add(tagEditor);

                var addTagsFromFileName = new ToolStripMenuItem(Message.AddTagsFromName + "...");
                var newTagsSet = new HashSet<string>();
                var tagNames = (from tag in tags select tag.Name).ToArray();
                foreach (var info in zipPlaInfos) if (info.TagArray != null) foreach (var tag in info.TagArray) if (!tagNames.Contains(tag)) newTagsSet.Add(tag);
                if (newTagsSet.Count > 0)
                {
                    var newTags = newTagsSet.ToArray();
                    addTagsFromFileName.Click += (sender2, e2) =>
                    {
                        showTagEditor(newTags);
                    };
                }
                else
                {
                    addTagsFromFileName.Enabled = false;
                }
                tagToolStripMenuItem.DropDownItems.Add(addTagsFromFileName);
            }
            else
            {
                cmsRightClickPrepareAndShow_ZipPlaInfoReady = false;

                ratingToolStripMenuItem.Enabled = false;
                cutToolStripMenuItem.Enabled = false;
                pageSequenceToolStripMenuItem.Enabled = false;
                pageSequenceToolStripMenuItem.Visible = false;
                thumbnailToolStripMenuItem.Enabled = false;
                thumbnailToolStripMenuItem.Visible = false;

                tagToolStripMenuItem.DropDownItems.Clear();
                tagToolStripMenuItem.DropDownItems.Add("");
                tagToolStripMenuItem.Enabled = false;
                cmsRightClickPrepareAndShow_TagInitialCheckState = null;
                cmsRightClickPrepareAndShow_SelectedPathList = null;
                //cmsRightClickPrepareAndShow_TagNames = null;

                //tagToolStripMenuItem.Enabled = false;

                //clearThumbnailSettingToolStripMenuIteaaam.Enabled = false;
            }

            RightClickFileNameToolStripTextBox_TextChanged_SetDefaultValues = false;

            rightClickFileNameToolStripTextBox_SelectedText = "";
            renamableByCmsTextBox = allowRenameByCmsRightClick && singleSelected && renamable;
            //selectionToFilterToolStripMenuItem.Enabled = false;
            //selectionToFilterToolStripMenuItem.Text = Message.FilterWithSelectedText;
            /*
            if (selectedNameArray == null || selectedNameArray.Length == 0)
            {
                rightClickFileNameToolStripTextBox.Visible = false;
            }
            else
            */
            {
                //rightClickFileNameToolStripTextBox.Visible = true;
                var text = renamableByCmsTextBox ? getBaseName(singleName) : TextAnalyzer.TextToWildcard(selectedNameArray);
                cmsRightClickPrepareAndShow_InitialTextBoxText = text;
                SizeF sizeF;
                using (var g = CreateGraphics())
                {
                    sizeF = g.MeasureString(text, rightClickFileNameToolStripTextBox.Font);
                }
                var size = rightClickFileNameToolStripTextBox.Size;
                size.Width = (int)Math.Ceiling(sizeF.Width);
                rightClickFileNameToolStripTextBox.Size = size;
                RightClickFileNameToolStripTextBox_TextChanged_CheckFileNameChar = false;
                rightClickFileNameToolStripTextBox.Text = text;
                RightClickFileNameToolStripTextBox_TextChanged_CheckFileNameChar = true;
                var selected = TextAnalyzer.GetImportantRange(text);
                rightClickFileNameToolStripTextBox.Select(selected.Index, selected.Length);
                rightClickFileNameToolStripTextBox_SelectedText = selected.Value;
                foreach (var dss in getCurrentDynamicStringSelectionToolStripMenuItems()) dss.SelectedText = rightClickFileNameToolStripTextBox_SelectedText;
                //if (!string.IsNullOrEmpty(rightClickFileNameToolStripTextBox_SelectedText))
                //{
                //    selectionToFilterToolStripMenuItem.Enabled = true;
                //    selectionToFilterToolStripMenuItem.Text = Message.FilterWith1.Replace("$1", rightClickFileNameToolStripTextBox_SelectedText);
                //}
            }
            rightClickFileNameToolStripTextBox.ReadOnly = !renamableByCmsTextBox;

            setRightClickMenuShortcutKeys(true);

            if (onlyTag && !tagToolStripMenuItem.Enabled)
            {
                cmsRightClickPrepareAndShow_ZipPlaInfoReady = false;
                AllowFullpower = true;
                return;
            }

            cmsRightClickPrepareAndShow_tagToolStripMenuItemDropDownItems = (from ToolStripItem item in tagToolStripMenuItem.DropDownItems select item).ToArray();

            if (onlyTag)
            {
                var items = cmsRightClick.Items;
                var tempItems = (from ToolStripItem item in items select item).ToArray();
                items.Clear();
                items.AddRange(cmsRightClickPrepareAndShow_tagToolStripMenuItemDropDownItems);

                ToolStripDropDownClosedEventHandler eh = null;
                eh += (sender, e) =>
                {
                    items.Clear();
                    items.AddRange(tempItems);
                    cmsRightClick.Closed -= eh;
                    tempItems = null;
                };
                cmsRightClick.Closed += eh;

                ToolStripDropDownScroller.EnscrollableOneTime(cmsRightClick, gestureListenergCmsRightRoot, enterFocus: true);
            }

            ratingChangeQue = -1;
            pageSequenceChangeQue = PageSequence.NotClicked;
            clearThumbnailSettingQue = false;

            //MessageBox.Show($"{cmsRightClick.ImageScalingSize}");

            //if (openedInFileList) dgvFileList.Update();
            if (this != ActiveForm) Activate();
            AllowFullpower = false;
            cmsRightClick.Show(point);

        }

        public void mctgCatalogForm_TouchGestureStarting(object sender, MiniControlTouchGestureStartingEventArgs e)
        {
            if (e.Control == tvCatalog)
            {
                e.Cancel = true;

                if (!showRating) return;
                if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;
                if (CreatingZipPathArray) return;
                if (drawRating_Bound.IsEmpty) return;
                var clientStartPosition = tvCatalog.PointToClient(e.Location);
                var dataIndex = mgCatalog.InGesturing || cmsRightClick.Visible ? -1 : tvCatalog.PointToIndex(clientStartPosition);
                if (dataIndex < 0) return;

                var imageRectangle = tvCatalog.PointToContainerImageRectangle(clientStartPosition);
                var backRectangle = drawRating_Bound;
                backRectangle.X += imageRectangle.X;
                backRectangle.Y += imageRectangle.Y;
                if (backRectangle.Contains(clientStartPosition))
                {
                    e.Cancel = false;
                }
            }
            else if (e.Control == dgvFileList)
            {
                e.Cancel = true;

                if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;
                if (CreatingZipPathArray) return;

                var clientStartPosition = dgvFileList.PointToClient(e.Location);
                var hit = dgvFileList.HitTest(clientStartPosition.X, clientStartPosition.Y);
                if (hit.RowIndex >= 0 && hit.ColumnIndex == tbcRating.Index)
                {
                    e.Cancel = false;
                }
            }
        }

        public void mctgCatalogForm_TouchGestureCompleted(object sender, MiniControlTouchGestureCompletedEventArgs e)
        {
            var ud = e.UserDirections; if (ud.Length < 1 || ud.Length > 2) return;
            if (e.StartingControl == cbFilter)
            {
                if (ud.Length != 1) return;
                if (ud[0] == MouseGestureDirection.Left)
                {
                    cbFilter.Text = "";
                }
                else if (ud[0] == MouseGestureDirection.Right)
                {
                    var s = GetClipBoardShortString();
                    if (!string.IsNullOrEmpty(s))
                    {
                        cbFilter.Text = s;
                        cbFilter.SelectAll();
                    }
                }
            }
            else if (e.StartingControl == btnGoToBack || e.StartingControl == btnGoToForward)
            {
                if (ud.Length == 1 && ud[0] == MouseGestureDirection.Down)
                {
                    showUndoBufferList(0, undoBuffer.Count);
                }
            }
            else if (e.StartingControl == tvCatalog)
            {
                if (ud.Length == 1 && ud[0] == MouseGestureDirection.Left)
                {
                    var orbit = e.MouseOrbit;
                    if (orbit == null || orbit.Length <= 0) return;
                    var onStars = !drawRating_Bound.IsEmpty && showRating && InDirectoryVirtualDirectoryOrSmartDirectory;
                    Rectangle imageRectangle = Rectangle.Empty, backRectangle = Rectangle.Empty;
                    if (onStars)
                    {
                        var clientPoint = orbit[0];
                        imageRectangle = tvCatalog.PointToContainerImageRectangle(clientPoint);
                        backRectangle = drawRating_Bound;
                        backRectangle.X += imageRectangle.X;
                        backRectangle.Y += imageRectangle.Y;
                        onStars = backRectangle.Contains(clientPoint);
                    }
                    if (onStars)
                    {
                        // カーソルの位置によっては星が期待通りに表示されない
                        Cursor.Position = tvCatalog.PointToScreen(new Point(backRectangle.Left - 1, (backRectangle.Top + backRectangle.Bottom) / 2));

                        SetRating(null, tvCatalog.PointToIndex(e.Location));
                    }
                }
            }
            else if (e.StartingControl == dgvFileList)
            {
                if (ud.Length == 1 && ud[0] == MouseGestureDirection.Left)
                {
                    var orbit = e.MouseOrbit;
                    if (orbit == null || orbit.Length <= 0) return;
                    var clientPoint = orbit[0];
                    var hit = dgvFileList.HitTest(clientPoint.X, clientPoint.Y);
                    if (hit.RowIndex >= 0 && hit.ColumnIndex == tbcRating.Index)
                    {
                        // カーソルの位置によっては星が期待通りに表示されない
                        var bound = dgvFileList.GetCellDisplayRectangle(hit.ColumnIndex, hit.RowIndex, cutOverflow: true);
                        Cursor.Position = dgvFileList.PointToScreen(new Point(bound.Left - 1, (bound.Top + bound.Bottom) / 2));

                        // 別の方法
                        //Cursor.Position = PointToScreen(e.Location);

                        var e2 = new RatingClickEventArgs();
                        e2.NewRating = 0;
                        e2.RowIndex = hit.RowIndex;
                        RatingGridViewTextBoxCell_RatingClick(null, e2);
                    }
                }
            }
            else
            {
                var menuStrip = e.StartingControl as MenuStrip; if (menuStrip == null) return;
                var orbit = e.MouseOrbit;
                if (orbit == null || orbit.Length <= 0) return;
                var toolStripItem = MiniControlTouchGesture.GetItem(menuStrip, orbit[0]) as ToolStripMenuItem;
                if (toolStripItem == null) return;

                if (ud.Length == 1 && ud[0] == MouseGestureDirection.Down)
                {
                    if (toolStripItem == addToolStripMenuItem)
                    {
                        PerformMouseDown(menuStrip, new MouseEventArgs(MouseButtons.Right, 1, orbit[0].X, orbit[0].Y, 0));
                        PerformMouseUp(menuStrip, new MouseEventArgs(MouseButtons.Right, 1, orbit[0].X, orbit[0].Y, 0));
                    }
                    else if (menuStrip == menuStripForTagFilter)
                    {
                        if (toolStripItem == ratingFilterToolStripMenuItem)
                        {
                            OpenRateButtonDropdown(byTouch: true);
                        }
                        else
                        {
                            OpenTagButtonDropdown(toolStripItem, byTouch: true);
                        }
                    }

                }
                else if (menuStrip == menuStripForTagFilter)
                {
                    if (toolStripItem == ratingFilterToolStripMenuItem)
                    {
                        if (ud.Length == 1)
                        {
                            if (ud[0] == MouseGestureDirection.Right)
                            {
                                andGreaterThanOrEqualToXToolStripMenuItem_Click(ratingFilterToolStripMenuItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Left)
                            {
                                greaterThanOrEqualToXToolStripMenuItem_Click(ratingFilterToolStripMenuItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Up)
                            {
                                andEqualToXToolStripMenuItem_Click(ratingFilterToolStripMenuItem, null);
                            }
                        }
                        else
                        {

                            if (ud[0] == MouseGestureDirection.Right && ud[1] == MouseGestureDirection.Up)
                            {
                                orEqualToXToolStripMenuItem_Click(ratingFilterToolStripMenuItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Left)
                            {
                                equalToXToolStripMenuItem_Click(ratingFilterToolStripMenuItem, null);
                            }
                        }
                    }
                    else
                    {
                        if (ud.Length == 1)
                        {
                            if (ud[0] == MouseGestureDirection.Right)
                            {
                                tagOrInclude1_Click(toolStripItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Left)
                            {
                                tagInclude1_Click(toolStripItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Up)
                            {
                                tagAndExclude1_Click(toolStripItem, null);
                            }
                        }
                        else
                        {

                            if (ud[0] == MouseGestureDirection.Right && ud[1] == MouseGestureDirection.Up)
                            {
                                tagOrExclide1_Click(toolStripItem, null);
                            }
                            else if (ud[0] == MouseGestureDirection.Left)
                            {
                                tagExclude1_Click(toolStripItem, null);
                            }
                        }
                    }
                }
            }
        }

        public static void TouchGestureStartingForTagMenu(object sender, MiniControlTouchGestureStartingEventArgs e)
        {
            var dropDown = e.Control as ToolStripDropDown;
            if (dropDown == null)
            {
                e.Cancel = true;
                return;
            }
            var fullItems = dropDown.Items;
            var count = fullItems.Count;
            if (!(MiniControlTouchGesture.GetItem(dropDown, dropDown.PointToClient(e.Location)) is PrefixEscapedToolStripMenuItem))
            {
                e.Cancel = true;
            }
        }

        public static void TouchGestureCompletedForTagMenu(object sender, MiniControlTouchGestureCompletedEventArgs e)
        {
            if (!e.UserDirections.SequenceEqual(new MouseGestureDirection[] { MouseGestureDirection.Right })) return;
            var dropDown = e.StartingControl as ToolStripDropDown;
            if (dropDown == null) return;
            var fullItems = dropDown.Items;
            var count = fullItems.Count;
            var tags = (from ToolStripItem item in fullItems let p = item as PrefixEscapedToolStripMenuItem where p != null select p).ToArray();
            if (tags.Length == 0) return;
            var orbit = e.MouseOrbit;
            if (orbit == null || orbit.Length <= 0) return;
            var toolStripItem = MiniControlTouchGesture.GetItem(dropDown, orbit[0]) as ToolStripMenuItem;
            if (toolStripItem == null) return;
            var isTarget = tags.Contains(toolStripItem);
            if (!isTarget)
            {
                var index = fullItems.IndexOf(tags[0]);

                if (index < 0) return;
                if (index + 1 >= count) return;
                if (fullItems[index + 1] is PrefixEscapedToolStripMenuItem)
                {
                    isTarget = true;
                }
                else
                {
                    if (index + 2 >= count) return;
                    if (!(fullItems[index + 1] is ToolStripMenuItem) && fullItems[index + 2] is PrefixEscapedToolStripMenuItem)
                    {
                        isTarget = true;
                    }
                    else return;

                }
            }
            if (isTarget)
            {
                PerformMouseDown(dropDown, new MouseEventArgs(MouseButtons.Right, 1, orbit[0].X, orbit[0].Y, 0));
                PerformMouseUp(dropDown, new MouseEventArgs(MouseButtons.Right, 1, orbit[0].X, orbit[0].Y, 0));
            }
        }

        private static bool isNoneRootItem(string path)
        {
            if (path == null || path.Length <= 3) return false;

            var p = path.IndexOf(Path.DirectorySeparatorChar, 3);
            if (p < 0) return false;
            return path.IndexOf(Path.DirectorySeparatorChar, p + 2) >= 0;
        }

        private static bool clipBoardHasFile(bool allowVirtualFile)
        {
            try
            {
                var data = Clipboard.GetDataObject();
                if (data == null) return false;

                if (data.GetDataPresent(DataFormats.FileDrop))
                {
                    var obj = data.GetData(DataFormats.FileDrop);
                    var files = obj as string[];
                    if (files != null) return files.Length > 0;
                }

                if (!allowVirtualFile) return false;

                if (data.GetDataPresent(NativeMethods.ZIPPLA_FILECONTENTS))
                {
                    return true;
                }

                //var iobj = obj as System.Runtime.InteropServices.ComTypes.IDataObject;
                //if (iobj != null) return true;
                return false;
            }
            catch
            {
                return false;
            }
        }

        ToolStripDropDownCloseReason cmsRightClick_Closing_CloseReason;
        private void cmsRightClick_Closing(object sender, ToolStripDropDownClosingEventArgs e)
        {
            cmsRightClickPrepareAndShow_ZipPlaInfoReady = false;

            msSortBy.Stop = msFilter.Stop = msCatalog.Stop = msFileList.Stop = false; // 直後の Opening と逆転することがあるので Closing で
            AllowFullpower = true; // 直後の Opening と逆転することがあるので Closing で

            cmsRightClick_Closing_CloseReason = e.CloseReason;

            // キーの処理
            /*
            if (cmsRightClick_Closing_CloseReason == ToolStripDropDownCloseReason.)

            ratingChangeQue =
                noneToolStripMenuItem.Selected ? 0 :
                star1toolStripMenuItem.Selected ? 1 :
                star2toolStripMenuItem.Selected ? 2 :
                star3toolStripMenuItem.Selected ? 3 :
                star4toolStripMenuItem.Selected ? 4 :
                star5toolStripMenuItem.Selected ? 5 : -1;!
                */
        }

        private void setNewDynamicStringSelectionToolStripMenuItems(bool enabled, DynamicStringSelectionInfo[] infos)
        {
            var currents = getCurrentDynamicStringSelectionToolStripMenuItems().ToArray();
            foreach (var current in currents)
            {
                current.Dispose();
            }

            rightClickFileNameToolStripTextBox.Visible = enabled;
            appStartSeparator.Visible = enabled;
            if (enabled)
            {
                var cmsItems = cmsRightClick.Items;
                var index = 1;
                foreach (var info in infos)
                {
#if SCREENCAPTCHA
                    if (info.DisplayName != null && Message.CurrentLanguage.ToString() == "en-US")
                    {
                        var m = Regex.Match(info.DisplayName, @"^""\$1"" を (.*) で検索$");
                        if (m.Success)
                        {
                            info.DisplayName = "Search \"$1\" on " + m.Groups[1].Value;
                        }
                    }
#endif
                    cmsItems.Insert(index++, info.GetDynamicStringSelectionToolStripMenuItem(this));
                }
            }
        }

        private IEnumerable<DynamicStringSelectionToolStripMenuItem> getCurrentDynamicStringSelectionToolStripMenuItems()
        {
            var items = cmsRightClick.Items;
            for (var i = 1; true; i++)
            {
                var result = items[i] as DynamicStringSelectionToolStripMenuItem;
                if (result != null) yield return result;
                else yield break;
            }
        }

        private void SetSelectedArchiveRating(int? rating)
        {
            if (tvCatalog.SelectedIndicesCount == 0) return;

            var indices = new List<int>();
            var oldNames = new List<string>();
            var newNames = new List<string>();

            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && ZipNameArray != null)
                {
                    var count = ZipPathArray.Length;
                    if (ZipNameArray.Length != count) return;

                    foreach (var selectedIndex in tvCatalog.SelectedIndices)
                    {
                        if (selectedIndex >= 0 && selectedIndex < count) // 耐仕様変更
                        {
                            var path = ZipPathArray[selectedIndex];
                            var name = ZipNameArray[selectedIndex];
                            if (!string.IsNullOrEmpty(path) && !string.IsNullOrEmpty(name))
                            {
                                var zipPlaInfo = new ZipPlaInfo(path);
                                zipPlaInfo.Rating = rating;
                                var newPath = zipPlaInfo.GetPathOfCurrentInfo(name.Last() == Path.DirectorySeparatorChar);

                                if (path != newPath)
                                {
                                    indices.Add(selectedIndex);
                                    oldNames.Add(path);
                                    newNames.Add(newPath);
                                }
                            }
                        }
                    }
                }
            }

            if (indices.Count > 0) RenameShownArchive(indices.ToArray(), oldNames.ToArray(), newNames.ToArray(), atFirstArrayChange: true);
        }

        private void SetRating(int? rating, int index)
        {
            if (index < 0) return;
            if (CreatingZipPathArray) return;
            if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;

            var apa = ZipPathArray;
            var zna = ZipNameArray;
            if (apa == null || zna == null) return;
            var count = apa.Length;
            if (zna.Length != count || count <= index) return;
            var path = apa[index];
            var name = zna[index];
            if (string.IsNullOrEmpty(path) || string.IsNullOrEmpty(name)) return;
            var zipPlaInfo = new ZipPlaInfo(path);
            zipPlaInfo.Rating = rating;
            var newPath = zipPlaInfo.GetPathOfCurrentInfo(name.Last() == Path.DirectorySeparatorChar);

            RenameShownArchive(index, path, newPath);
        }

        private void SetSelectedArchivePageSequence(BindingMode? bindingMode)
        {
            if (tvCatalog.SelectedIndicesCount == 0) return;

            var indices = new List<int>();
            var oldNames = new List<string>();
            var newNames = new List<string>();

            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && ZipNameArray != null)
                {
                    var count = ZipPathArray.Length;
                    if (ZipNameArray.Length != count) return;

                    foreach (var selectedIndex in tvCatalog.SelectedIndices)
                    {
                        if (selectedIndex >= 0 && selectedIndex < count) // 耐仕様変更
                        {
                            var path = ZipPathArray[selectedIndex];
                            var name = ZipNameArray[selectedIndex];
                            if (!string.IsNullOrEmpty(path) && !string.IsNullOrEmpty(name))
                            {
                                var zipPlaInfo = new ZipPlaInfo(path);
                                zipPlaInfo.BindingModeForSet = bindingMode;
                                var newPath = zipPlaInfo.GetPathOfCurrentInfo(name.Last() == Path.DirectorySeparatorChar);

                                if (path != newPath)
                                {
                                    indices.Add(selectedIndex);
                                    oldNames.Add(path);
                                    newNames.Add(newPath);
                                }
                            }
                        }
                    }
                }
            }

            if (indices.Count > 0) RenameShownArchive(indices.ToArray(), oldNames.ToArray(), newNames.ToArray(), atFirstArrayChange: true);
        }

        private void ClearSelectedArchiveThumbnailSetting()
        {

            if (tvCatalog.SelectedIndicesCount == 0) return;

            var indices = new List<int>();
            var oldNames = new List<string>();
            var newNames = new List<string>();

            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && ZipNameArray != null)
                {
                    var count = ZipPathArray.Length;
                    if (ZipNameArray.Length != count) return;
                    foreach (var selectedIndex in tvCatalog.SelectedIndices)
                    {
                        if (selectedIndex >= 0 && selectedIndex < count) // 耐仕様変更
                        {
                            var path = ZipPathArray[selectedIndex];
                            var name = ZipNameArray[selectedIndex];
                            if (!string.IsNullOrEmpty(path) && !string.IsNullOrEmpty(name))
                            {
                                var zipPlaInfo = new ZipPlaInfo(path);
                                zipPlaInfo.ThumbnailInfo = null;
                                var newPath = zipPlaInfo.GetPathOfCurrentInfo(name.Last() == Path.DirectorySeparatorChar);

                                if (path != newPath)
                                {
                                    indices.Add(selectedIndex);
                                    oldNames.Add(path);
                                    newNames.Add(newPath);
                                }
                            }
                        }
                    }
                }
            }

            if (indices.Count > 0) RenameShownArchive(indices.ToArray(), oldNames.ToArray(), newNames.ToArray(), atFirstArrayChange: true);
        }


        enum PageSequence { NotClicked, Cleared, LeftToRight, RightToLeft, SinglePage }
        PageSequence pageSequenceChangeQue = PageSequence.NotClicked;
        private void defaultToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { pageSequenceChangeQue = PageSequence.Cleared; }
        private void leftToRightToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { pageSequenceChangeQue = PageSequence.LeftToRight; }
        private void rightToLeftToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { pageSequenceChangeQue = PageSequence.RightToLeft; }
        private void singlePageToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { pageSequenceChangeQue = PageSequence.SinglePage; }

        private void defaultToolStripMenuItem_MouseLeave(object sender, EventArgs e) { pageSequenceChangeQue = PageSequence.NotClicked; }
        private void leftToRightToolStripMenuItem_MouseLeave(object sender, EventArgs e) { pageSequenceChangeQue = PageSequence.NotClicked; }
        private void rightToLeftToolStripMenuItem_MouseLeave(object sender, EventArgs e) { pageSequenceChangeQue = PageSequence.NotClicked; }
        private void singlePageToolStripMenuItem_MouseLeave(object sender, EventArgs e) { pageSequenceChangeQue = PageSequence.NotClicked; }

        // クリックイベントに動画内でのリネームが割り当ててある
        bool clearThumbnailSettingQue = false;
        private void clearThumbnailSettingToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { if (InDirectoryVirtualDirectoryOrSmartDirectory) clearThumbnailSettingQue = true; }

        private int ratingChangeQue = -1;
        private void noneToolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 0; }
        private void star1toolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 1; }
        private void star2toolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 2; }
        private void star3toolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 3; }
        private void star4toolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 4; }
        private void star5toolStripMenuItem_MouseDown(object sender, MouseEventArgs e) { ratingChangeQue = 5; }

        private void noneToolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }
        private void star1toolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }
        private void star2toolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }
        private void star3toolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }
        private void star4toolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }
        private void star5toolStripMenuItem_MouseLeave(object sender, EventArgs e) { ratingChangeQue = -1; }

        /*
        private void ratingToolStripMenuItem_DropDown_KeyDown(object sender, KeyEventArgs e)
        {
            ratingChangeQue =
                noneToolStripMenuItem.Selected ? 0 :
                star1toolStripMenuItem.Selected ? 1 :
                star2toolStripMenuItem.Selected ? 2 :
                star3toolStripMenuItem.Selected ? 3 :
                star4toolStripMenuItem.Selected ? 4 :
                star5toolStripMenuItem.Selected ? 5 : -1;
        }
        */



        private PrefixEscapedToolStripMenuItem[] getTagNameToolStripMenuItems()
        {
            var tagNameToolStripMenuItems = new List<PrefixEscapedToolStripMenuItem>();
            bool inTags = false;
            //foreach (var item in tagToolStripMenuItem.DropDownItems)
            foreach (var item in cmsRightClickPrepareAndShow_tagToolStripMenuItemDropDownItems)
            {
                if (!inTags)
                {
                    if (item is ToolStripSeparator)
                    {
                        inTags = true;
                    }
                }
                else
                {
                    if (item is PrefixEscapedToolStripMenuItem)
                    {
                        tagNameToolStripMenuItems.Add(item as PrefixEscapedToolStripMenuItem);
                    }
                    else break;
                }
            }
            return tagNameToolStripMenuItems.ToArray();
        }

        private void renameForTextBoxRatingTagPageSequence(bool noop)
        {
            if (!noop)
            {
                var text = rightClickFileNameToolStripTextBox.Text;
                if (cmsRightClickPrepareAndShow_InitialTextBoxText != text)
                {
                    var selectedIndex = tvCatalog.SelectedIndex;
                    var zna = ZipNameArray;
                    var zpa = ZipPathArray;
                    if (zna != null && zpa != null && selectedIndex >= 0 && selectedIndex < zna.Length && zpa.Length == zna.Length)
                    {
                        var oldName = zna[selectedIndex];
                        var oldPath = zpa[selectedIndex];
                        if (!string.IsNullOrEmpty(oldName) && !string.IsNullOrEmpty(oldPath))
                        {
                            var oldBase = getBaseName(oldName);
                            if (oldBase == cmsRightClickPrepareAndShow_InitialTextBoxText)
                            {
                                var newInfo = new ZipPlaInfo(text);
                                var oldInfo = new ZipPlaInfo(oldName);
                                var changedThumbnail = newInfo.ThumbnailInfo != newInfo.ThumbnailInfo;
                                var changedEffectivePageSequence = false;
                                var isDir = oldName.Last() == Path.DirectorySeparatorChar;
                                var newPath = isDir ? oldPath.Substring(0, oldPath.Length - oldName.Length + 1) + text :
                                    oldPath.Substring(0, oldPath.Length - oldName.Length) + text + oldName.Substring(oldBase.Length);
                                var needToCheck = !changedThumbnail && InDirectoryVirtualDirectoryOrSmartDirectory && currentClipMode == ClipMode.PlaClip && (isDir || PackedImageLoader.Supports(oldPath));
                                if (needToCheck)
                                {
                                    var oldBind = ZipPlaInfo.GetOnlyBindingModeFromFullName(oldPath);
                                    var newBind = ZipPlaInfo.GetOnlyBindingModeFromFullName(newPath);
                                    var oldEffective = oldBind == null ? currentBindingMode : (BindingMode)oldBind;
                                    var newEffective = newBind == null ? currentBindingMode : (BindingMode)newBind;
                                    changedEffectivePageSequence = oldEffective != newEffective;
                                    //MessageBox.Show($"{oldPath}\n{newPath}\n{changedThumbnail}\n{changedEffectivePageSequence}");
                                }
                                RenameShownArchive(selectedIndex, oldPath, newPath, atFirstArrayChange: true, needToReload: changedThumbnail || changedEffectivePageSequence);
                            }
                        }
                    }

                }
                else if (cmsRightClickPrepareAndShow_TagInitialCheckState != null && cmsRightClickPrepareAndShow_SelectedPathList != null)
                {
                    var changedTags = false;
                    var tagNameToolStripMenuItems = getTagNameToolStripMenuItems();

                    var states = (from item in tagNameToolStripMenuItems select item.CheckState).ToArray();
                    for (var i = 0; i < cmsRightClickPrepareAndShow_TagInitialCheckState.Length; i++)
                    {
                        if (states.Length <= i) return;
                        changedTags = changedTags || states[i] != cmsRightClickPrepareAndShow_TagInitialCheckState[i];
                    }
                    var changedRating = ratingChangeQue >= 0;
                    var changePageSequence = pageSequenceChangeQue != PageSequence.NotClicked;
                    var clearThumbnail = clearThumbnailSettingQue;

                    var changeEffectivePageSequence = false;

                    if (changedTags || changedRating || changePageSequence || clearThumbnail)
                    {
                        var selectedIndices = tvCatalog.SelectedIndices;
                        if (selectedIndices != null && selectedIndices.Length == cmsRightClickPrepareAndShow_SelectedPathList.Length)
                        {
                            var oldNames = new string[selectedIndices.Length];
                            var newNames = new string[selectedIndices.Length];
                            var needToRenameEvenIfFileNameIsNotChanged = new bool[selectedIndices.Length];

                            var tagNames = !changedTags ? null : (from item in tagNameToolStripMenuItems select item.PlainText).ToArray();
                            var tagCount = !changedTags ? 0 : tagNames.Length;

                            // フォルダかどうかの取得用
                            var zna = ZipNameArray;
                            var zpa = ZipPathArray;
                            if (zna != null && zpa != null && zna.Length == zpa.Length)
                            {
                                var count = zpa.Length;

                                // selectedIndices + ZipPathArray からパスを取得することも可能だが、
                                // path が意図しないものになるとフォルダ構成の破壊に繋がるため安全策をとる
                                for (var i = 0; i < cmsRightClickPrepareAndShow_SelectedPathList.Length; i++)
                                {
                                    var index = selectedIndices[i];
                                    if (index >= count) continue;
                                    var path = cmsRightClickPrepareAndShow_SelectedPathList[i];
                                    var name = zna[index];
                                    if (string.IsNullOrEmpty(name) || path != zpa[index]) continue;

                                    var zipPlaInfo = new ZipPlaInfo(path);

                                    if (changedTags)
                                    {
                                        var tags = zipPlaInfo.TagArray?.ToList();
                                        if (tags == null) tags = new List<string>();
                                        var newTags = new List<string>();
                                        for (var j = 0; j < tagCount; j++)
                                        {
                                            var state = states[j];
                                            var tagName = tagNames[j];
                                            if (state == CheckState.Indeterminate)
                                            {
                                                if (tags.Contains(tagName))
                                                {
                                                    newTags.Add(tagName);
                                                    tags.Remove(tagName);
                                                }
                                            }
                                            else
                                            {
                                                if (state == CheckState.Checked)
                                                {
                                                    newTags.Add(tagName);
                                                }
                                                tags.Remove(tagName);
                                            }
                                        }
                                        newTags.AddRange(tags);
                                        zipPlaInfo.TagArray = newTags.Count == 0 ? null : newTags.ToArray();
                                    }

                                    if (changedRating)
                                    {
                                        zipPlaInfo.Rating = ratingChangeQue;
                                    }

                                    if (changePageSequence)
                                    {
                                        var needToCheck = InDirectoryVirtualDirectoryOrSmartDirectory && currentClipMode == ClipMode.PlaClip;

                                        var old = needToCheck ? ZipPlaInfo.GetOnlyBindingModeFromFullName(path) : null;
                                        var oldEffective = old == null ? currentBindingMode : (BindingMode)old;
                                        BindingMode newEffeective;

                                        switch (pageSequenceChangeQue)
                                        {
                                            case PageSequence.Cleared:
                                                zipPlaInfo.BindingModeForSet = null;
                                                var parent = needToCheck ?
                                                    ZipPlaInfo.GetOnlyBindingModeFromFullName(currentLocation) : null;
                                                if (parent != null)
                                                {
                                                    newEffeective = (BindingMode)parent;
                                                }
                                                else
                                                {
                                                    newEffeective = currentBindingMode;
                                                }
                                                break;
                                            case PageSequence.LeftToRight:
                                                zipPlaInfo.BindingModeForSet = BindingMode.LeftToRight;
                                                newEffeective = BindingMode.LeftToRight;
                                                break;
                                            case PageSequence.RightToLeft:
                                                zipPlaInfo.BindingModeForSet = BindingMode.RightToLeft;
                                                newEffeective = BindingMode.RightToLeft;
                                                break;
                                            case PageSequence.SinglePage:
                                                zipPlaInfo.BindingModeForSet = BindingMode.SinglePage;
                                                newEffeective = BindingMode.SinglePage;
                                                break;
                                            default:
                                                newEffeective = oldEffective;
                                                break;
                                        }

                                        changeEffectivePageSequence = needToCheck && oldEffective != newEffeective;
                                    }

                                    if (clearThumbnail)
                                    {
                                        zipPlaInfo.ThumbnailInfo = null;
                                    }

                                    var isDir = name.Last() == Path.DirectorySeparatorChar;

                                    oldNames[i] = path;
                                    newNames[i] = zipPlaInfo.GetPathOfCurrentInfo(isDir);

                                    // 先に消しておく
                                    if (isDir && clearThumbnail)
                                    {
                                        try
                                        {
                                            var coverPath = Path.Combine(path, ZipPlaCoverImageFileWithExtension);
                                            if (File.Exists(coverPath))
                                            {
                                                File.Delete(coverPath);
                                            }
                                            needToRenameEvenIfFileNameIsNotChanged[i] = true;
                                        }
                                        catch { }
                                    }
                                }

                                /*
                                if (ZipPathArray != null && selectedIndex < ZipPathArray.Length)
                                {
                                    var zipPlaInfo = new ZipPlaInfo(path);
                                    zipPlaInfo.ThumbnailInfo = null;
                                    var newPath = 
                                    RenameShownArchive(selectedIndex, path, newPath);
                                }
                                */

                                RenameShownArchive(selectedIndices, oldNames, newNames, atFirstArrayChange: true,
                                    needToReload: clearThumbnail || changeEffectivePageSequence,
                                    needToReloadEvenIfFileNameIsNotChanged: needToRenameEvenIfFileNameIsNotChanged);
                            }
                        }
                    }
                }
            }

            cmsRightClickPrepareAndShow_TagInitialCheckState = null;
            cmsRightClickPrepareAndShow_SelectedPathList = null;
            ratingChangeQue = -1;
            pageSequenceChangeQue = PageSequence.NotClicked;
            clearThumbnailSettingQue = false;
            cmsRightClickPrepareAndShow_InitialTextBoxText = null;
        }

        private void RightClickFileNameToolStripTextBox_MouseMove(object sender, MouseEventArgs e)
        {
            rightClickFileNameToolStripTextBox_SelectedTextChanged();
        }

        private void RightClickFileNameToolStripTextBox_KeyUp(object sender, KeyEventArgs e)
        {
            rightClickFileNameToolStripTextBox_SelectedTextChanged();
        }

        private void RightClickFileNameToolStripTextBox_KeyDown(object sender, KeyEventArgs e)
        {
            rightClickFileNameToolStripTextBox_SelectedTextChanged();

            if (e.KeyCode == Keys.Enter)
            {
                e.SuppressKeyPress = true;
                cmsRightClick.Close();
            }
            else if (e.KeyCode == Keys.Down)
            {
                cmsRightClick.Focus();
                cmsRightClick.Items[1].Select();
                e.Handled = true;
            }
            else if (e.KeyCode == Keys.Up)
            {
                cmsRightClick.Focus();
                cmsRightClick.Items[cmsRightClick.Items.Count - 1].Select();
                e.Handled = true;
            }
            else if (e.KeyCode == Keys.A && e.Control && !e.Alt && !e.Shift)
            {
                if (rightClickFileNameToolStripTextBox != null &&
                    rightClickFileNameToolStripTextBox.Visible &&
                    rightClickFileNameToolStripTextBox.Focused &&
                    rightClickFileNameToolStripTextBox.Selected &&
                    !string.IsNullOrEmpty(rightClickFileNameToolStripTextBox.Text))
                {
                    rightClickFileNameToolStripTextBox.SelectAll();
                }
            }
        }

        private string rightClickFileNameToolStripTextBox_SelectedText;
        private void rightClickFileNameToolStripTextBox_SelectedTextChanged()
        {
            var selectedText = rightClickFileNameToolStripTextBox.SelectedText;
            if (selectedText == rightClickFileNameToolStripTextBox_SelectedText) return;
            rightClickFileNameToolStripTextBox_SelectedText = selectedText;

            foreach (var dss in getCurrentDynamicStringSelectionToolStripMenuItems()) dss.SelectedText = selectedText;

            /*
            if (string.IsNullOrEmpty(selectedText))
            {
                selectionToFilterToolStripMenuItem.Enabled = false;
                selectionToFilterToolStripMenuItem.Text = Message.FilterWithSelectedText;
            }
            else
            {
                selectionToFilterToolStripMenuItem.Enabled = true;
                selectionToFilterToolStripMenuItem.Text = Message.FilterWith1.Replace("$1", selectedText);
            }
            */
        }

        private void RightClickFileNameToolStripTextBox_MouseLeave(object sender, EventArgs e)
        {
            if (cmsRightClick.Visible && (rightClickFileNameToolStripTextBox.ReadOnly || !string.IsNullOrEmpty(rightClickFileNameToolStripTextBox.SelectedText))) cmsRightClick.Focus();
        }

        private void RightClickFileNameToolStripTextBox_MouseEnter(object sender, EventArgs e)
        {
            rightClickFileNameToolStripTextBox.Focus();
        }

        //private void selectionToFilterToolStripMenuItem_Click(object sender, EventArgs e)
        //{
        //    if (string.IsNullOrEmpty(rightClickFileNameToolStripTextBox_SelectedText)) return;

        //    cbFilter.Text = rightClickFileNameToolStripTextBox_SelectedText;
        //    setCurrentFilterToHistory(true);
        //}

        public void StringToFilterForDynamicStringSelection(string str)
        {
            if (string.IsNullOrEmpty(str)) return;

            cbFilter.Text = SearchManager.TrimAndPutQuotationIfNeeded(str, aliasesToFilteringStrings?.Keys);
            setCurrentFilterToHistory(true);
            cbFilter.SelectAll();
        }


        private static readonly Regex getVirtualFoldersInBookmarks_Regex = new Regex(@"\.sor$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private IEnumerable<ColoredBookmark> getVirtualFoldersInBookmarks()
        {
            return getSpecialFoldersInBookmarks(getVirtualFoldersInBookmarks_Regex, mustBeExistingFile: true);
            /*
            var tbcDirectoryNameINdex = tbcDirectoryName.Index;
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var coloredProfile = row.Cells[tbcDirectoryNameINdex].Value as ColoredBookmark;
                var ok = false;
                try
                {
                    ok = Path.GetExtension(coloredProfile.SimpleBookmark.Location).ToUpper() == ".SOR"; // Virtual の中でも特に SOR のみ
                }
                catch { } // 設定ファイルの破壊耐性
                if (ok)
                {
                    yield return coloredProfile; // yield は try の外
                }
            }
            */
        }

        private static readonly Regex getSmartFolderInBookmarks_Regex = new Regex($"\\.{SmartFolder.ExtensionWithoutPeriodInLower}$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
        private IEnumerable<ColoredBookmark> getSmartFolderInBookmarks()
        {
            return getSpecialFoldersInBookmarks(getSmartFolderInBookmarks_Regex, mustBeExistingFile: true);
        }

        private IEnumerable<ColoredBookmark> getSpecialFoldersInBookmarks(Regex locationRegex, bool mustBeExistingFile)
        {
            var tbcDirectoryNameINdex = tbcDirectoryName.Index;
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var coloredProfile = row.Cells[tbcDirectoryNameINdex].Value as ColoredBookmark;
                // セパレーターなら無視される
                if (coloredProfile == null || coloredProfile.SimpleBookmark.SpecialRole != SimpleBookmarkSpecialRole.None) continue;
                var target = coloredProfile?.SimpleBookmark?.Location;
                if (mustBeExistingFile && !FileExistsWithoutException(target)) continue;
                if (target != null && locationRegex.IsMatch(target))
                {
                    yield return coloredProfile; // yield は try の外
                }
            }
        }

        private bool CanReloadSelectedItem()
        {
            var selectedIndex = tvCatalog.SelectedIndex;
            return selectedIndex >= 0 && FileCountArray != null && selectedIndex < FileCountArray.Length;
        }

        /*
        private string GetExternalViewer(bool throwFileNotFoundException = false)
        {
            try
            {
                string externalViewr = (new GeneralConfig()).ExternalViewer;
                if (string.IsNullOrEmpty(externalViewr))
                {
                    return null;
                }
                else if (!File.Exists(externalViewr))
                {
                    if (throwFileNotFoundException)
                    {
                        throw new FileNotFoundException(null, externalViewr);
                    }
                    else
                    {
                        return null;
                    }
                }
                else
                {
                    return externalViewr;
                }
            }
            catch
            {
                return null;
            }
        }
        */

        /*
        private bool BuiltInViewerIsDefault()
        {
            try
            {
                DefaultViewer defaultViewer = (new GeneralConfig()).DefaultViewer;
                return defaultViewer == DefaultViewer.BuiltIn;
            }
            catch
            {
                return true;
            }
        }
        */

        /*
    private void openInExplorerToolStripMenuItem_Click(object sender, EventArgs e)
    {
        var selectedIndex = tvCatalog.SelectedIndex;
        if (selectedIndex >= 0 && selectedIndex < ZipPathArray.Length)
        {
            var path = ZipPathArray[selectedIndex];
            Program.OpenWithExplorer(path);
        }
    }
    */

        class filePathComparator : IComparer<string>
        {
            public int Compare(string x, string y)
            {
                if (x == null)
                {
                    if (y == null) return 0;
                    else return -1;
                }
                else
                {
                    if (y == null) return 1;
                    else return LogicalStringComparer.StrCmpLogicalW(x, y);
                }
            }
        }

        private string[] GetSeparatorReplacedArray(string[] nameArray)
        {
            // セパレーターなし
            if (InMovie || InArchive && currentLocation?.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase) == true ||
                InDirectoryVirtualDirectoryOrSmartDirectory && SubfolderMode == SubfolderMode.Ignore) return nameArray;

            var count = nameArray.Length;
            var result = new string[count];

            // / のみ
            if (InArchive)
            {
                var s = Path.AltDirectorySeparatorChar;
                var r = Convert.ToChar(2);
                for (var i = 0; i < count; i++)
                {
                    var name = nameArray[i];
                    if (name != null && name.Contains(s))
                    {
                        result[i] = name.Replace(s, r);
                    }
                    else
                    {
                        result[i] = name;
                    }
                }
                return result;
            }

            // 末尾に \ のみ
            if (InDirectoryVirtualDirectoryOrSmartDirectory && !InRealDirectory || InRealDirectory && !SubfolderIsSearched())// SubfolderMode != SubfolderMode.Search)
            {
                var s = Path.DirectorySeparatorChar;
                var r = Convert.ToChar(1);
                for (var i = 0; i < count; i++)
                {
                    var name = nameArray[i];
                    if (name != null && name.Any() && name.Last() == s)
                    {
                        result[i] = name.Replace(s, r);
                    }
                    else
                    {
                        result[i] = name;
                    }
                }
                return result;
            }

            // \ のみ
            if (InRealDirectory)
            {
                var s = Path.DirectorySeparatorChar;
                var r = Convert.ToChar(1);
                for (var i = 0; i < count; i++)
                {
                    var name = nameArray[i];
                    if (name != null && name.Contains(s))
                    {
                        result[i] = name.Replace(s, r);
                    }
                    else
                    {
                        result[i] = name;
                    }
                }
                return result;
            }

            // 将来別のパターンを追加したとき用

            var s1 = Path.DirectorySeparatorChar;
            var r1 = Convert.ToChar(1);
            var s2 = Path.AltDirectorySeparatorChar;
            var r2 = Convert.ToChar(2);
            for (var i = 0; i < count; i++)
            {
                var name = nameArray[i];
                if (name != null && name.Any(c => c == s1 || c == s2))
                {
                    result[i] = name.Replace(s1, r1).Replace(s2, r2);
                }
                else
                {
                    result[i] = name;
                }
            }
            return result;
        }

        //int[] GetSortArray_RandomOrder = null;
        string GetSortArray_RandomSeed;
        //bool GetSortArray_RandomSeed_Set = false;
        public static readonly LogicalStringComparer GetSortArray_NaturalSort = new LogicalStringComparer();
        private static readonly filePathComparator GetSortArray_FilePathComparator = new filePathComparator();
        //private readonly Random randomForPermutation = new Random();
        private int[] GetSortArray(int[] preSortArray, bool careTvCatalog = true, SortMode? sortMode = null, bool recursiveCall = false)
        {
            var count = ZipPathArray.Length;
            if (careTvCatalog && (tvCatalog.Count != count || CreatingZipPathArray)) return new int[0];

            int[] order;
            // this.sortMode が名前ソートなどの場合も安定ソートは不要に思えるが、スマートフォルダ等を考慮すると実際にはそうではない
            if (preSortArray == null && sortMode == null && prevSortMode != SortMode.Random && this.sortMode != SortMode.Random && prevSortMode != this.sortMode)
            {
                order = GetSortArray(null, careTvCatalog, prevSortMode, recursiveCall: true);
            }
            else
            {
                var orderList = new List<int>();
                var invalid = InArchive || InMovie || cbFilter_SearchManager == null;
                for (var i = 0; i < count; i++)
                {
                    if (!ZipMaskArray[i]) continue;

                    string name;
                    if (invalid || (name = ZipNameArray[i]) != null && cbFilter_SearchManager.Match(ZipNameArray[i]))
                    {
                        orderList.Add(i);
                    }
                }

                if (preSortArray != null)
                {
                    var preCount = preSortArray.Length;
                    var prePosition = new int[count];
                    for (var i = 0; i < count; i++)
                    {
                        prePosition[i] = int.MaxValue;
                    }
                    for (var i = 0; i < preCount; i++)
                    {
                        prePosition[preSortArray[i]] = i;
                    }

                    order = orderList.OrderBy(dataIndex => prePosition[dataIndex]).ToArray();
                }
                else
                {
                    order = orderList.ToArray();
                }
            }

            var localSortMode = sortMode == null ? this.sortMode : (SortMode)sortMode;
            int[] result;
            switch (localSortMode)
            {
                case SortMode.TypeInAsc:
                    {
                        var typeArray = GetTypeNameArray(ZipNameArray);
                        result = order.OrderBy(x => typeArray[x], GetSortArray_FilePathComparator).ToArray();
                        break;
                    }
                case SortMode.TypeInDesc:
                    {
                        var typeArray = GetTypeNameArray(ZipNameArray);
                        result = order.OrderByDescending(x => typeArray[x], GetSortArray_FilePathComparator).ToArray();
                        break;
                    }
                case SortMode.NameInAsc:
                    {
                        var replaced = GetSeparatorReplacedArray(ZipNameArray);
                        // ZipPathArray でソートすると明らかに表示との不整合が生じる
                        result = order.OrderBy(x => replaced[x], GetSortArray_NaturalSort).ToArray();
                        break;
                    }
                case SortMode.NameInDesc:
                    {
                        var replaced = GetSeparatorReplacedArray(ZipNameArray);
                        result = order.OrderByDescending(x => replaced[x], GetSortArray_NaturalSort).ToArray();
                        break;
                    }
                case SortMode.RatingInAsc:
                case SortMode.RatingInDesc:
                    var ratingArray = (from name in ZipNameArray select name == null ? 0 : ZipPlaInfo.GetOnlyRating(name)).ToArray();
                    if (localSortMode == SortMode.RatingInAsc)
                    {
                        var sortCount = ratingArray.Length;
                        for (var i = 0; i < sortCount; i++)
                        {
                            if (ratingArray[i] < 0) ratingArray[i] = int.MaxValue;
                        }
                        result = order.OrderBy(x => ratingArray[x]).ToArray();
                        break;
                    }
                    else
                    {
                        result = order.OrderByDescending(x => ratingArray[x]).ToArray();
                        break;
                    }
                case SortMode.CreatedInAsc:
                    result = order.OrderBy(x => CreateTimeArray[x]).ToArray();
                    break;
                case SortMode.CreatedInDesc:
                    result = order.OrderByDescending(x => CreateTimeArray[x]).ToArray();
                    break;
                case SortMode.AccessedInAsc:
                    result = order.OrderBy(x => LastAccessTimeArray[x]).ToArray();
                    break;
                case SortMode.AccessedInDesc:
                    result = order.OrderByDescending(x => LastAccessTimeArray[x]).ToArray();
                    break;
                case SortMode.ModifiedInAsc:
                    result = order.OrderBy(x => ModifiedTimeArray[x]).ToArray();
                    break;
                case SortMode.ModifiedInDesc:
                    result = order.OrderByDescending(x => ModifiedTimeArray[x]).ToArray();
                    break;
                case SortMode.SizeInAsc:
                    {
                        var sizeArray = new long[count];
                        for (var i = 0; i < count; i++)
                        {
                            var s = ZipSizeArray[i];
                            if (s >= 0)
                            {
                                var name = ZipNameArray[i];
                                if (!string.IsNullOrEmpty(name))
                                {
                                    var c = name[name.Length - 1];
                                    if (c != Path.DirectorySeparatorChar && c != Path.DirectorySeparatorChar)
                                    {
                                        sizeArray[i] = s;
                                    }
                                    else
                                    {
                                        sizeArray[i] = long.MaxValue;
                                    }
                                }
                            }
                            else
                            {
                                sizeArray[i] = long.MaxValue;
                            }
                        }
                        result = order.OrderBy(x => sizeArray[x]).ToArray();
                        break;
                    }
                case SortMode.SizeInDesc:
                    {
                        var sizeArray = new long[count];
                        for (var i = 0; i < count; i++)
                        {
                            var s = ZipSizeArray[i];
                            if (s >= 0)
                            {
                                var name = ZipNameArray[i];
                                if (!string.IsNullOrEmpty(name))
                                {
                                    var c = name[name.Length - 1];
                                    if (c != Path.DirectorySeparatorChar && c != Path.DirectorySeparatorChar)
                                    {
                                        sizeArray[i] = s;
                                    }
                                    else
                                    {
                                        sizeArray[i] = -1;
                                    }
                                }
                            }
                        }
                        result = order.OrderByDescending(x => sizeArray[x]).ToArray();
                        break;
                    }
                case SortMode.VPageInAsc:
                    {
                        var pageArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            var p = FileCountArray[i];
                            if (p >= 0)
                            {
                                pageArray[i] = p;
                            }
                            else
                            {
                                pageArray[i] = int.MaxValue - 100 - p;
                            }
                        }
                        result = order.OrderBy(x => pageArray[x]).ToArray();
                        break;
                    }
                case SortMode.VPageInDesc:
                    {
                        var pageArray = new int[count];
                        Array.Copy(FileCountArray, pageArray, count);
                        result = order.OrderByDescending(x => pageArray[x]).ToArray();
                        break;
                    }
                case SortMode.VResolutionInAsc:
                    {
                        var resoArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    resoArray[i] = unchecked(size.Width * size.Height); continue;
                                case 1: resoArray[i] = int.MaxValue - 1; continue;
                                case 2: resoArray[i] = int.MaxValue; continue;
                            }

                        }
                        result = order.OrderBy(x => resoArray[x]).ToArray();
                        break;
                    }
                case SortMode.VResolutionInDesc:
                    {
                        var resoArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    resoArray[i] = unchecked(size.Width * size.Height); continue;
                                case 1: resoArray[i] = -1; continue;
                                case 2: resoArray[i] = -2; continue;
                            }
                        }
                        result = order.OrderByDescending(x => resoArray[x]).ToArray();
                        break;
                    }
                case SortMode.VRatioInAsc:
                    {
                        var ratioArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    ratioArray[i] = size.Height > 0 ? (double)size.Width / size.Height : double.MaxValue * 0.998; continue;
                                case 1: ratioArray[i] = double.MaxValue * 0.999; continue;
                                case 2: ratioArray[i] = double.MaxValue; continue;
                            }

                        }
                        result = order.OrderBy(x => ratioArray[x]).ToArray();
                        break;
                    }
                case SortMode.VRatioInDesc:
                    {
                        var ratioArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    ratioArray[i] = size.Height > 0 ? (double)size.Width / size.Height : double.MaxValue * 0.998; continue;
                                case 1: ratioArray[i] = -1; continue;
                                case 2: ratioArray[i] = -2; continue;
                            }

                        }
                        result = order.OrderByDescending(x => ratioArray[x]).ToArray();
                        break;
                    }
                case SortMode.VWidthInAsc:
                    {
                        var widthArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    widthArray[i] = size.Width; continue;
                                case 1: widthArray[i] = int.MaxValue - 1; continue;
                                case 2: widthArray[i] = int.MaxValue; continue;
                            }
                        }
                        result = order.OrderBy(x => widthArray[x]).ToArray();
                        break;
                    }
                case SortMode.VWidthInDesc:
                    {
                        var widthArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    widthArray[i] = size.Width; continue;
                                case 1: widthArray[i] = -1; continue;
                                case 2: widthArray[i] = -2; continue;
                            }
                        }
                        result = order.OrderByDescending(x => widthArray[x]).ToArray();
                        break;
                    }
                case SortMode.VHeightInAsc:
                    {
                        var heightArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    heightArray[i] = size.Height; continue;
                                case 1: heightArray[i] = int.MaxValue - 1; continue;
                                case 2: heightArray[i] = int.MaxValue; continue;
                            }
                        }
                        result = order.OrderBy(x => heightArray[x]).ToArray();
                        break;
                    }
                case SortMode.VHeightInDesc:
                    {
                        var heightArray = new int[count];
                        for (var i = 0; i < count; i++)
                        {
                            Size size;
                            switch (getSizeInLock(i, out size))
                            {
                                case 0:
                                    heightArray[i] = size.Height; continue;
                                case 1: heightArray[i] = -1; continue;
                                case 2: heightArray[i] = -2; continue;
                            }
                        }
                        result = order.OrderByDescending(x => heightArray[x]).ToArray();
                        break;
                    }
                case SortMode.VLengthInAsc:
                    {
                        var timeArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            var m = MovieInfoArray[i];
                            if (m != null)
                            {
                                var t = m.Duration;
                                if (t != default(TimeSpan))
                                {
                                    timeArray[i] = t.TotalSeconds;
                                }
                                else
                                {
                                    timeArray[i] = double.MaxValue * 0.999;
                                }
                            }
                            else if (MovieThumbnailLoader.Supports(ZipNameArray[i]))
                            {
                                timeArray[i] = double.MaxValue * 0.999;
                            }
                            else
                            {
                                timeArray[i] = double.MaxValue;
                            }
                        }
                        result = order.OrderBy(x => timeArray[x]).ToArray();
                        break;
                    }
                case SortMode.VLengthInDesc:
                    {
                        var timeArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            var m = MovieInfoArray[i];
                            if (m != null)
                            {
                                var t = m.Duration;
                                if (t != default(TimeSpan))
                                {
                                    timeArray[i] = t.TotalSeconds;
                                }
                                else
                                {
                                    timeArray[i] = -1;
                                }
                            }
                            else if (MovieThumbnailLoader.Supports(ZipNameArray[i]))
                            {
                                timeArray[i] = -1;
                            }
                            else
                            {
                                timeArray[i] = -2;
                            }
                        }
                        result = order.OrderByDescending(x => timeArray[x]).ToArray();
                        break;
                    }
                case SortMode.VFPSInAsc:
                    {
                        var fpsArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            var m = MovieInfoArray[i];
                            if (m != null)
                            {
                                var t = m.FPS;
                                if (t >= 0)
                                {
                                    fpsArray[i] = t;
                                }
                                else
                                {
                                    fpsArray[i] = double.MaxValue * 0.999;
                                }
                            }
                            else if (MovieThumbnailLoader.Supports(ZipNameArray[i]))
                            {
                                fpsArray[i] = double.MaxValue * 0.999;
                            }
                            else
                            {
                                fpsArray[i] = double.MaxValue;
                            }
                        }
                        result = order.OrderBy(x => fpsArray[x]).ToArray();
                        break;
                    }
                case SortMode.VFPSInDesc:
                    {
                        var fpsArray = new double[count];
                        for (var i = 0; i < count; i++)
                        {
                            var m = MovieInfoArray[i];
                            if (m != null)
                            {
                                var t = m.FPS;
                                if (t >= 0)
                                {
                                    fpsArray[i] = t;
                                }
                                else
                                {
                                    fpsArray[i] = -1;
                                }
                            }
                            else
                            {
                                var name = ZipNameArray[i];
                                if (!string.IsNullOrEmpty(name) && MovieThumbnailLoader.Supports(name))
                                {
                                    fpsArray[i] = -1;
                                }
                                else
                                {
                                    fpsArray[i] = -2;
                                }
                            }
                        }
                        result = order.OrderByDescending(x => fpsArray[x]).ToArray();
                        break;
                    }
                default:
                    {
                        /*
                        if (GetSortArray_RandomOrder == null || GetSortArray_RandomOrder.Length != count)
                        {
                            GetSortArray_RandomOrder = DarumaOtoshi.RandomPermutation(count, randomForPermutation);
                        }
                        var result2 = order.OrderBy(x => GetSortArray_RandomOrder[x]).ToArray();
                        */
                        if (GetSortArray_RandomSeed == null)
                        {
                            var now = DateTime.Now;
                            GetSortArray_RandomSeed = now.Ticks.ToString();
                            //GetSortArray_RandomSeed_Set = true;
                        }
                        //var sw2 = new Stopwatch();
                        //var s = "";
                        //sw2.Start();

                        // ZipPathArray を使った場合：
                        // フォルダごと移動すると Seed が変わらなくても順番が変わる
                        // Seed を変えなくても PDF 内のソート順が同じということにならない
                        var table = (from key in ZipPathArray select GetRandomIndex(key, GetSortArray_RandomSeed)).ToArray(); // 10 万程度であれば処理時間はこちらが主要

                        //sw2.Stop();
                        //s += sw2.Elapsed + "\n";
                        //sw2.Restart();

                        var result2 = order.OrderBy(x => table[x]).ToArray(); // 係数の問題で現実的な範囲ではこちらの計算時間は無視できる


                        //sw2.Stop();
                        //s += sw2.Elapsed + "\n";
                        //MessageBox.Show(s);
                        result = result2;
                        break;
                    }
            }

            if (!recursiveCall)
            {
                var resolved = ResolveFitToDirectionOfSort(FolderSortMode, localSortMode);
                var dsc = Path.DirectorySeparatorChar;
                if (resolved != FolderSortMode.None)
                {
                    var folderIndentity = result.Select(i =>
                    {
                        var name = ZipNameArray[i];
                        return !string.IsNullOrEmpty(name) && name.Last() == dsc;
                    }).ToArray();
                    var folderCount = folderIndentity.Count(isFolder => isFolder);
                    int file, folder;
                    if (resolved == FolderSortMode.Ahead)
                    {
                        folder = 0;
                        file = folderCount;
                    }
                    else
                    {
                        file = 0;
                        folder = result.Length - folderCount;
                    }
                    var newResult = new int[result.Length];
                    for (var i = 0; i < result.Length; i++)
                    {
                        if (folderIndentity[i])
                        {
                            newResult[folder++] = result[i];
                        }
                        else
                        {
                            newResult[file++] = result[i];
                        }
                    }
                    result = newResult;
                }
            }

            return result;
        }

        public static string[] GetTypeNameArray(IReadOnlyList<string> names)
        {
            var count = names.Count;
            var typeArray = new string[count];
            var typeNameDictionary = new Dictionary<string, string>();
            for (var i = 0; i < count; i++)
            {
                var name = names[i];
                if (!string.IsNullOrEmpty(name))
                {
                    var nameLength = name.Length;
                    if (nameLength == 0)
                    {
                        typeArray[i] = "";
                        continue;
                    }
                    if (name[name.Length - 1] != Path.DirectorySeparatorChar)
                    {
                        try
                        {
                            var ext = Path.GetExtension(name).ToLower();
                            string typeName;
                            if (!typeNameDictionary.TryGetValue(ext, out typeName))
                            {
                                // 描画用としては十分高速だが、ソート用としては少し遅いので辞書を使う
                                typeName = FileTypeManager.GetTypeName(name, useFileAttrinutes: true);
                                typeNameDictionary[ext] = typeName;
                            }
                            typeArray[i] = typeName;
                        }
                        catch
                        {
                            typeArray[i] = "";
                        }
                    }
                }
            }
            return typeArray;
        }

        public static UBigInteger GetRandomIndex(string fullPath, string randomSeed)
        {
            var basePath = ZipPlaInfo.GetBasePathRoughly(fullPath); // タグの書き換えで順序が変わらないように
            return new UBigInteger(getHash_SHA1.ComputeHash(Encoding.UTF8.GetBytes(basePath + "\t" + randomSeed)));
        }

        //private static System.Security.Cryptography.MD5CryptoServiceProvider getHash64_MD5 = new System.Security.Cryptography.MD5CryptoServiceProvider();

        // 計算速度は早い順で SHA256Managed > SHA256Cng > SHA256CryptoServiceProvider
        // 対応範囲の広さは SHA256Managed > SHA256Cng = SHA256CryptoServiceProvider
        // Managed が高速なのは近年の最適化技術と CPU の進化によるものと考えられる
        //private static readonly System.Security.Cryptography.SHA256 getHash_SHA256 = new System.Security.Cryptography.SHA256Managed();

        // SHA256 より 2 倍弱高速なので SHA1 を採用（1 万個のファイルの場合で計算時間がおよそ 2 フレーム → 1 フレーム に改善）
        // セキュリティが目的ではないのでその点のデメリットはない
        // 値域は狭くなるがそれでも 160bit あるので、1 京個のファイルがあっても衝突する確率は 1 京分の 1 未満
        // 1 万個のファイルの場合衝突の確率は 1正（ 10 の 40 乗）分の 1 未満
        // さらに、衝突が起こっても実害はないので、値域の狭さのデメリットも皆無
        private static readonly System.Security.Cryptography.SHA1 getHash_SHA1 = new System.Security.Cryptography.SHA1Managed();

        // Managed が使えず遅い
        //private static readonly System.Security.Cryptography.MD5 getHash_MD5 = new System.Security.Cryptography.MD5Cng();


        private int getSizeInLock(int index, out Size size)
        {
            var name = ZipNameArray[index];
            if (string.IsNullOrEmpty(name))
            {
                size = Size.Empty;
                return -1;
            }
            Size? sizeN;
            ImageInfo ii;
            /*
            if (ImageLoader.SupportsAtLeastThumbnailReading(name))
            {
                sizeN = ImageInfoArray[index]?.Size;
            }
            else*/
            if (MovieThumbnailLoader.Supports(name))
            {
                sizeN = MovieInfoArray[index]?.SizeByPixel;
            }
            else if ((ii = ImageInfoArray[index]) != null)
            {
                sizeN = ii.Size;
            }
            else
            {
                size = Size.Empty;
                return 2;
            }
            if (sizeN == null)
            {
                size = Size.Empty;
                return 1;
            }
            else
            {
                size = (Size)sizeN;
                return size.IsEmpty ? 1 : 0;
            }
        }

        bool cbSortBy_SelectedValueChanged_Stop = false;
        SortMode cbSortBy_SelectedValueChanged_prevSortByIndex = 0;
        private void cbSortBy_SelectedValueChanged(object sender, EventArgs e)
        {
            if (cbSortBy_SelectedValueChanged_Stop) return;
            var sortModeIndex = cbSortBy.SelectedIndex;
            if (sortModeIndex < 0 || sortModeIndex > (int)SortMode.Random) return;

            if (cbSortBy_SelectedValueChanged_prevSortByIndex == SortMode.Random)
            {
                prevSortMode = 0;
            }
            else if (cbSortBy_SelectedValueChanged_prevSortByIndex != SortMode.RatingInAsc && cbSortBy_SelectedValueChanged_prevSortByIndex != SortMode.RatingInDesc)
            {
                prevSortMode = cbSortBy_SelectedValueChanged_prevSortByIndex;
            }
            cbSortBy_SelectedValueChanged_prevSortByIndex = sortMode = (SortMode)sortModeIndex;

            // ここで先にファイルリストのソート矢印の向きを変更することもできるがエクスプローラーに合わせてそれは行わない
            var success = false;
            if (sortMode != SortMode.Random)
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null)
                    {
                        tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex);
                        success = true;
                    }
                }
                if (success)
                {
                    setFileListFromThumbnailViewer();
                    var si = tvCatalog.SelectedIndex;
                    if (si >= 0)
                    {
                        //tvCatalog.ScrollBarToIndex(si);
                        tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[si]);
                    }
                    else
                    {
                        var s2d = tvCatalog.ShowIndexToDataIndex;
                        if (s2d.Length > 0)
                        {
                            tvCatalog.ScrollBarToIndex(s2d[0]);
                        }
                    }
                }
            }
            else// if (!cbSortBy_DropDownClosed_Resorted)
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null)
                    {
                        tvCatalog.SelectedIndex = -1; // プロパティの set の処理において冗長な描画が入るが、影響の小ささから可読性を優先。
                        GetSortArray_RandomSeed = null;
                        //GetSortArray_RandomOrder = null;
                        tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: null); // ランダムは安定ソート不要
                        success = true;
                    }
                }
                if (success)
                {
                    setFileListFromThumbnailViewer();
                    var s2d = tvCatalog.ShowIndexToDataIndex;
                    if (s2d.Length > 0)
                    {
                        tvCatalog.ScrollBarToIndex(s2d[0]);
                    }
                }
            }
            //cbSortBy_DropDownClosed_Resorted = false;
        }

        private bool notNeedToIgnoreMouseMoveOnRating() { return !mgFileList.InGesturing; }// 右クリックメニュー対応はクラス内で && (MouseButtons & MouseButtons.Right) != MouseButtons.Right && !cmsRightClick.Visible; }

        private readonly List<DataGridViewRow> setFileListFromThumbnailViewer_Recycle = new List<DataGridViewRow>();
        private void setFileListFromThumbnailViewer(bool tryToKeepScroll = false, bool volatilitySort = false)
        {
            //var sw = new Stopwatch();
            //var ss = ""; sw.Start();

            var temp = selectionSynchronizing;
            selectionSynchronizing = true;
            var showIndexToDataIndex = tvCatalog.ShowIndexToDataIndex;
            var tbcFileNameIndex = tbcFileName.Index;
            var tbcRatingIndex = tbcRating.Index;
            var tbcIconIndex = tbcIcon.Index;
            var culture = Message.CurrentLanguage;
            //sw.Stop(); ss += $"roopStart:\t{sw.Elapsed}\n"; sw.Restart();
            var recycleRowsCount = setFileListFromThumbnailViewer_Recycle.Count;
            var recycleIndex = 0;
            var itemsCount = showIndexToDataIndex.Length;
            var lastItemsCount = dgvFileList.Rows.Count;
            var needToClear = itemsCount < lastItemsCount;
            var needToAdd = itemsCount != lastItemsCount;
            var addedRows = needToAdd ? new DataGridViewRow[needToClear ? itemsCount : itemsCount - lastItemsCount] : null;
            var addedRowsIndex = 0;
            var addedStartIndex = needToClear ? 0 : lastItemsCount;
            foreach (var index in showIndexToDataIndex)
            {
                //sw.Stop();
                DataGridViewRow row;
                if (recycleIndex < recycleRowsCount)
                {
                    row = setFileListFromThumbnailViewer_Recycle[recycleIndex++];
                    (row.Cells[tbcFileNameIndex] as RainbowDataGridViewTextBoxCell).Tags = Tags;
                    (row.Cells[tbcRatingIndex] as RatingGridViewTextBoxCell).activeStars = InDirectoryVirtualDirectoryOrSmartDirectory;

                    setFileListRowInLock(row, index, dynamicOnly: false, localOnly: false, cultureForOnlyStatic: culture, volatilitySortCancelIfChanged: !volatilitySort);
                    if (recycleIndex > addedStartIndex) addedRows[addedRowsIndex++] = row;
                }
                else
                {
                    recycleIndex++;
                    row = new DataGridViewRow(); // ループ内の 4 割
                    row.CreateCells(dgvFileList); // ループ内の 3 割
                    setFileListFromThumbnailViewer_Recycle.Add(row);
                    row.Cells[tbcFileNameIndex] = new RainbowDataGridViewTextBoxCell(Tags);
                    var ratingGridViewTextBoxCell = new RatingGridViewTextBoxCell(activeStars: InDirectoryVirtualDirectoryOrSmartDirectory,
                        activeStarsFunc: notNeedToIgnoreMouseMoveOnRating);
                    ratingGridViewTextBoxCell.RatingClick += RatingGridViewTextBoxCell_RatingClick;
                    row.Cells[tbcRatingIndex] = ratingGridViewTextBoxCell;
                    var iconCell = new DataGridViewIconCell();
                    iconCell.GetMaskAlpha = GetMaskAlpha;
                    row.Cells[tbcIconIndex] = iconCell;

                    setFileListRowInLock(row, index, dynamicOnly: false, localOnly: false, cultureForOnlyStatic: culture, volatilitySortCancelIfChanged: !volatilitySort);
                    if (recycleIndex > addedStartIndex) addedRows[addedRowsIndex++] = row;
                }
            }
            int val = -1;
            //if (tryToKeepScroll)
            {
                val = dgvFileList.FirstDisplayedScrollingRowIndex;
            }
            if (needToClear)
            {
                dgvFileList.Rows.Clear();
            }
            //sw.Stop(); ss += $"clEnd:\t{sw.Elapsed}\n"; sw.Restart();
            if (needToAdd) dgvFileList.Rows.AddRange(addedRows);
            //sw.Stop(); ss += $"addEnd:\t{sw.Elapsed}\n"; sw.Restart();

            //if (tryToKeepScroll)
            {
                //if (val >= 0 && val < rowsList.Count)
                if (val >= 0 && val < itemsCount)
                {
                    dgvFileList.FirstDisplayedScrollingRowIndex = val;
                }
            }
            if (!volatilitySort)
            {
                setNonVolatilitySort();
            }

            selectionSynchronizing = temp;

            //sw.Stop(); ss += $"sSncStart:\t{sw.Elapsed}\n"; sw.Restart();
            selectionSynchronizingFromThumbnailToFileList(changeScroll: !tryToKeepScroll);

            // サムネイル非表示の場合にヘッダ読み込みが終わるまで表示が更新されない問題の解消
            dgvFileList.Update();

            //sw.Stop(); ss += $"fin:\t{sw.Elapsed}";
            //MessageBox.Show(ss);
        }

        private bool setFileListRowInLock(int index, bool dynamicOnly, bool localOnly, CultureInfo cultureForOnlyStatic, bool volatilitySortCancelIfChanged)
        {
            if (index < 0) return false;
            if (CreatingZipPathArray) return false;
            var d2s = tvCatalog.DataIndexToShowIndex;
            if (index >= d2s.Length) return false;
            var showIndex = d2s[index];
            if (showIndex < 0 || showIndex >= dgvFileList.Rows.Count) return false;
            var row = dgvFileList.Rows[showIndex];
            return setFileListRowInLock(row, index, dynamicOnly, localOnly, cultureForOnlyStatic, volatilitySortCancelIfChanged);
        }

        private bool setFileListRowInLock(DataGridViewRow row, int index, bool dynamicOnly, bool localOnly, CultureInfo cultureForOnlyStatic, bool volatilitySortCancelIfChanged)
        {
            var name = ZipNameArray[index];
            var lwt = ModifiedTimeArray[index];
            var result = false;
            if (!dynamicOnly)
            {
                if (!localOnly)
                {
                    var path = ZipPathArray[index];
                    if (setFileListRowStaticGlobalPart(row, path, name, lwt))
                    {
                        result = true;
                    }
                }
                if (setFileListRowStaticLocalPart(row, name, ZipSizeArray[index], CreateTimeArray[index], LastAccessTimeArray[index], ModifiedTimeArray[index], cultureForOnlyStatic))
                {
                    result = true;
                }
            }

            if (!localOnly)
            {

                if (setFileListRoDynamicPart(row, name, ZipPageArray[index], FileCountArray[index], ImageInfoArray[index], MovieInfoArray[index], volatilitySortCancelIfChanged))
                {
                    result = true;
                }
            }
            return result;
        }

        private bool setFileListRowStaticGlobalPart(DataGridViewRow row, string path, string name, DateTime lastWriteTime)
        {
            // var changed = false;

            var iconCell = row.Cells[tbcIcon.Index] as DataGridViewIconCell;
            iconCell.IsDir = name != null && name.Length > 0 && name.Last() == Path.DirectorySeparatorChar;
            iconCell.lastWriteTime = lastWriteTime;
            iconCell.ResetValue(path, staticImageDisposed: true);
            //iconCell.Value = path;

            var nameCell = row.Cells[tbcFileName.Index];
            //if(nameCell.Value?.ToString() != name)
            {
                nameCell.Value = name;
                // changed = true;
            }
            var rateCell = row.Cells[tbcRating.Index] as RatingGridViewTextBoxCell;
            var rate = ZipPlaInfo.GetOnlyRating(name);
            //if(rateCell.Rating != rate)
            {
                rateCell.Rating = rate;
                // changed = true;
            }

            //return changed;
            return false;
        }

        private bool setFileListRowStaticLocalPart(DataGridViewRow row, string name, long size, DateTime cTime, DateTime aTime, DateTime mTime, CultureInfo culture) // size ソートを揮発性にしたくないので static 扱い
        {
            //var changed = false;
            DataGridViewCell cell;
            string s;

            cell = row.Cells[tbcCreateTime.Index];
            s = getShortTimeString(cTime, culture);
            // if(cell.Value?.ToString() != s)
            {
                // changed = true;
                cell.Value = s;
            }

            cell = row.Cells[tbcAccessTime.Index];
            s = getShortTimeString(aTime, culture);
            // if(cell.Value?.ToString() != s)
            {
                // changed = true;
                cell.Value = s;
            }

            cell = row.Cells[tbcWriteTime.Index];
            s = getShortTimeString(mTime, culture);
            // if (cell.Value?.ToString() != s)
            {
                // changed = true;
                cell.Value = s;
            }

            cell = row.Cells[tbcSize.Index];
            s = getFileSizeStringInFileListLocal(name, size);
            // if (cell.Value?.ToString() != s)
            {
                //changed = true;
                cell.Value = s;
            }

            // return changed;
            return false;
        }

        private string getFileSizeStringInFileListLocal(string name, long size)
        {
            if (name[name.Length - 1] != Path.DirectorySeparatorChar && size >= 0)
            // 一つ目の条件がないとフォルダサイズ取得後に言語設定を変更するとサイズが表示されてしまう
            {
                return Program.GetFormatSizeString(size, Message.Bytes, simpleForm: true);
            }
            else
            {
                return EmptyPageString;
            }
        }

        /*
        private string getFileSizeStringInFileListGlobal(string name, long size)
        {
            if (name[name.Length - 1] != Path.DirectorySeparatorChar)
            {
                return Program.GetFormatSizeString(size, null, simpleForm: true);
            }
            else
            {
                return EmptyPageString;
            }
        }
        */

        private const string setFileListRoDynamicPart_LengthFormat = @"h\:mm\:ss";
        private delegate void setFileListRoDynamicPart_SetterDelegate(ref bool changed, DataGridViewCell dst, string src);
        private bool setFileListRoDynamicPart(DataGridViewRow row, string name, int cPage, int tPage, ImageInfo iInfo, MovieInfo mInfo, bool volatilitySortCancelIfChanged)
        {
            var changed = false;

            var setter = volatilitySortCancelIfChanged ? (setFileListRoDynamicPart_SetterDelegate)substitutionWithCheckForCellAndRemoveSortGlyphDirection : substitutionWithCheckForCell;

            setter(ref changed, row.Cells[tbcPage.Index], getPageString(cPage, tPage));
            //if(InArchive || ImageLoader.SupportsAtLeastThumbnailReading(name))
            var ffmpegExists = null as bool?;
            var extensionWithPeriodInLower = null as string;
            if (InArchive || ImageLoader.SupportsGetImageInfoByExtensionWithPeriodInLower(extensionWithPeriodInLower = ImageLoader.GetExtensionWithPeriodInLowerSafety(name), ref ffmpegExists))
            {
                Size size;
                if (iInfo != null && !(size = iInfo.Size).IsEmpty)
                {
                    setter(ref changed, row.Cells[tbcResolution.Index], size.Width + "x" + size.Height);
                    setter(ref changed, row.Cells[tbcRatio.Index], getRatioString(size));
                    setter(ref changed, row.Cells[tbcWidth.Index], size.Width.ToString());
                    setter(ref changed, row.Cells[tbcHeight.Index], size.Height.ToString());
                }
                else if (InArchive || ImageLoader.SupportsImageAtLeastThumbnailReadingByExtension(
                    extensionWithPeriodInLower ?? ImageLoader.GetExtensionWithPeriodInLowerSafety(name), ref ffmpegExists))
                {
                    setter(ref changed, row.Cells[tbcResolution.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcRatio.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcWidth.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcHeight.Index], QuestionPageString);
                }
                else
                {
                    setter(ref changed, row.Cells[tbcResolution.Index], EmptyPageString);
                    setter(ref changed, row.Cells[tbcRatio.Index], EmptyPageString);
                    setter(ref changed, row.Cells[tbcWidth.Index], EmptyPageString);
                    setter(ref changed, row.Cells[tbcHeight.Index], EmptyPageString);
                }
                setter(ref changed, row.Cells[tbcLength.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcFPS.Index], EmptyPageString);
            }
            else if (InMovie || MovieThumbnailLoader.SupportsByExtension(extensionWithPeriodInLower ?? ImageLoader.GetExtensionWithPeriodInLowerSafety(name)))
            {
                if (mInfo != null)
                {
                    var size = mInfo.SizeByPixel;
                    if (!size.IsEmpty)
                    {
                        setter(ref changed, row.Cells[tbcResolution.Index], size.Width + "x" + size.Height);
                        setter(ref changed, row.Cells[tbcRatio.Index], getRatioString(size, mInfo.SAR));
                        setter(ref changed, row.Cells[tbcWidth.Index], size.Width.ToString());
                        setter(ref changed, row.Cells[tbcHeight.Index], size.Height.ToString());
                    }
                    else
                    {
                        setter(ref changed, row.Cells[tbcResolution.Index], QuestionPageString);
                        setter(ref changed, row.Cells[tbcRatio.Index], QuestionPageString);
                        setter(ref changed, row.Cells[tbcWidth.Index], QuestionPageString);
                        setter(ref changed, row.Cells[tbcHeight.Index], QuestionPageString);
                    }
                    var length = mInfo.Duration;
                    if (length != default(TimeSpan))
                    {
                        setter(ref changed, row.Cells[tbcLength.Index], length.ToString(setFileListRoDynamicPart_LengthFormat));
                    }
                    else
                    {
                        setter(ref changed, row.Cells[tbcLength.Index], QuestionPageString);
                    }
                    var fps = mInfo.FPSString;
                    if (!string.IsNullOrEmpty(fps))
                    {
                        setter(ref changed, row.Cells[tbcFPS.Index], fps);
                    }
                    else
                    {
                        setter(ref changed, row.Cells[tbcFPS.Index], QuestionPageString);
                    }
                }
                else
                {
                    setter(ref changed, row.Cells[tbcResolution.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcRatio.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcWidth.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcHeight.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcLength.Index], QuestionPageString);
                    setter(ref changed, row.Cells[tbcFPS.Index], QuestionPageString);
                }
            }
            else
            {
                setter(ref changed, row.Cells[tbcResolution.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcRatio.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcWidth.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcHeight.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcLength.Index], EmptyPageString);
                setter(ref changed, row.Cells[tbcFPS.Index], EmptyPageString);
            }
            if (ffmpegExists != null) RecentFfmpegExists = (bool)ffmpegExists;
            return changed;
        }

        private void substitutionWithCheckForCellAndRemoveSortGlyphDirection(ref bool changed, DataGridViewCell dst, string src)
        {
            var dstString = dst.Value as string;
            if (dstString == null) dstString = "";
            if (src == null) src = "";
            if (dstString != src)
            {
                var column = dst.OwningColumn;
                if (column != null)
                {
                    var header = column.HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.None)
                    {
                        header.SortGlyphDirection = SortOrder.None;
                    }
                }

                changed = true;
                dst.Value = src;
            }
        }

        private void substitutionWithCheckForCell(ref bool changed, DataGridViewCell dst, string src)
        {
            var dstString = dst.Value as string;
            if (dstString == null) dstString = "";
            if (src == null) src = "";
            if (dstString != src)
            {
                changed = true;
                dst.Value = src;
            }
        }

        private const string getRatioString_MaxWidthTemplate = "1.11:1"; // 比が 1000:1 以上になるとこの範疇では収まらないが無視する
        private string getRatioString(Size size)
        {
            var w = Math.Max(0, size.Width);
            var h = Math.Max(0, size.Height);
            if (w == 0 && h == 0) return "0:0";
            if (h == 0) return "1:0";
            if (w == 0) return "0:1";
            if (w == h) return "1:1";
            if (w > h)
            {
                return toFourChars(Math.Max((double)w / h, 1.01)) + ":1";
            }
            else
            {
                return $"1:" + toFourChars(Math.Max((double)h / w, 1.01));
            }
        }

        private string toFourChars(double x)
        {
            // 小数点記号の利用を避ける
            if (x < 100)
            {
                return x.ToString("F2").Substring(0, 4);
            }
            else
            {
                return ((int)Math.Round(x)).ToString();
            }
        }

        private string getRatioString(Size size, Fraction SAR)
        {
            if (SAR == 0)
            {
                return getRatioString(size);
            }
            if (size.Height != 0)
            {
                return getRatioString((Fraction)size * SAR);
            }
            else if (size.Width != 0)
            {
                return "1:0";
            }
            else
            {
                return "0:0";
            }
        }


        /*
        private string getRatioString(Fraction f)
        {
            return f.Numerator + ":" + f.Denominator;
        }

        private string getRatioString(Size size)
        {
            if(size.Height != 0)
            {
                return getRatioString((Fraction)size);
            }
            else
            {
                return "1:0";
            }
        }

        */

        private const string EmptyPageString = "-";
        private const string QuestionPageString = "?";
        private string getPageString(int page, int total)
        {
            if (total == MetaPageCount_NotBook)
            {
                return EmptyPageString;
            }
            else if (total == MetaPageCount_NotLoaded)
            {
                return QuestionPageString;
            }
            else if (page >= 0 && total >= 0)
            {
                return $"{page + 1}/{total}";
            }
            else if (page >= 0)
            {
                return $"{page + 1}/{QuestionPageString}";
            }
            else if (total >= 0)
            {
                return total.ToString();
            }
            else
            {
                return QuestionPageString;
            }
        }

        private void RatingGridViewTextBoxCell_RatingClick(RatingGridViewTextBoxCell sender, RatingClickEventArgs e)
        {
            var index = e.RowIndex;
            if (index < 0) return;
            var s2d = tvCatalog.ShowIndexToDataIndex;
            if (index >= s2d.Length) return;
            index = s2d[index];
            if (1 <= e.NewRating && e.NewRating <= 5)
            {
                SetRating(e.NewRating, index);
            }
            else
            {
                SetRating(null, index);
            }
        }

        class DataGridViewIconCell : DataGridViewTextBoxCell
        {
            private bool valueEmpty = false;
            private Bitmap iconImage = null;
            public Func<string, int> GetMaskAlpha;


            public DataGridViewIconCell()
            {
                ToolTipText = "";
            }


            // これは OnValueChanged ではない
            /*
            protected override bool SetValue(int rowIndex, object value)
            {
                var prevValue = Value;
                if (value == null ? prevValue != null : value.Equals(prevValue))
                {
                    if (iconImage != null) iconImage.Dispose();
                    iconImage = null;
                    valueEmpty = false;
                    ToolTipText = "";
                }

                return base.SetValue(rowIndex, value);
            }
            */

            // OnValueChanged の代わり
            public void ResetValue(object value, bool staticImageDisposed)
            {
                //base.Value = value;
                //return;
                var prevValue = base.Value;
                if (staticImageDisposed || (value == null ? prevValue != null : (prevValue == null || !value.Equals(prevValue))))
                {
                    //if (iconImage != null) iconImage.Dispose(); アイコンは全て使いまわす
                    iconImage = null;
                    valueEmpty = false;
                    ToolTipText = "";
                    base.Value = value;
                    //DataGridView?.InvalidateCell(this);
                    //DataGridView?.Refresh();
                }
            }

            // OnValueChanged の代わり（誤り）
            /*
            new object Value
            {
                get
                {
                    return base.Value;
                }
                set
                {
                    var prevValue = base.Value;
                    if (value == null ? prevValue != null : value.Equals(prevValue))
                    {
                        if (iconImage != null) iconImage.Dispose();
                        iconImage = null;
                        valueEmpty = false;
                        ToolTipText = "";
                        base.Value = value;
                        //DataGridView?.InvalidateCell(this);
                        //DataGridView?.Refresh();
                    }

                }
            }
            */


            public bool IsDir;
            public DateTime lastWriteTime;

            private static string fileFolderString = null;
            private static string GetFileFolderString()
            {
                if (fileFolderString == null)
                {
                    try
                    {
                        fileFolderString = FileTypeManager.GetTypeName(SmartStaticIconProvider.DefaultDirectoryPath, useFileAttrinutes: false);
                    }
                    catch
                    {
                        fileFolderString = "";
                    }
                }
                return fileFolderString;
            }

            protected override void Paint(Graphics graphics, Rectangle clipBounds, Rectangle cellBounds, int rowIndex, DataGridViewElementStates elementState, object value, object formattedValue, string errorText, DataGridViewCellStyle cellStyle, DataGridViewAdvancedBorderStyle advancedBorderStyle, DataGridViewPaintParts paintParts)
            {
                var path = base.Value as string;
                if (iconImage == null && !valueEmpty)
                {
                    if (path == null)
                    {
                        valueEmpty = true;
                    }
                    else
                    {
                        try
                        {
                            string typeName;
                            if (IsDir)
                            {
                                typeName = GetFileFolderString();
                            }
                            else
                            {
                                typeName = FileTypeManager.GetTypeName(path, useFileAttrinutes: true);
                            }
                            if (typeName == null) ToolTipText = "";
                            else ToolTipText = typeName;

                            iconImage = SmartStaticIconProvider.GetSmall(path, lastWriteTime, IsDir);

                            /*
                            var tuple = FileTypeManager.GetTypeNameAndSmallIconBitmap(path, useFileAttrinutes: path.Contains(Path.AltDirectorySeparatorChar));

                            if (tuple.Item1 == null) ToolTipText = "";
                            else ToolTipText = tuple.Item1;

                            iconImage = tuple.Item2;
                            */
                        }
                        catch { }
                    }
                }

                base.Paint(graphics, clipBounds, cellBounds, rowIndex, elementState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts & ~DataGridViewPaintParts.ContentForeground);

                if (iconImage != null)
                {
                    DrawImageUnscaledCenteringAndCliped(graphics, iconImage, cellBounds);

                    var maskAlpha = path == null ? 0 : GetMaskAlpha(path);
                    if (maskAlpha > 0)
                    {
                        if ((elementState & DataGridViewElementStates.Selected) == DataGridViewElementStates.Selected)
                        {
                            graphics.FillRectangle(getColorMask(maskAlpha, cellStyle.SelectionBackColor), cellBounds);
                        }
                        else
                        {
                            graphics.FillRectangle(getWhiteMask(maskAlpha, cellStyle.BackColor), cellBounds);
                        }
                    }
                }
            }

            /*
            private static unsafe bool isBlankBitmap(Bitmap bitmap)
            {
                var w = bitmap.Width;
                var h = bitmap.Height;
                var pixelFormat = bitmap.PixelFormat;
                var data = bitmap.LockBits(new Rectangle(0, 0, w, h), ImageLockMode.ReadOnly, pixelFormat);
                try
                {
                    var adr0 = (byte*)data.Scan0;
                    var stride = data.Stride;
                    var bytePerLine = Image.GetPixelFormatSize(pixelFormat) / 8 * w;
                    for(var y = 0; y < h; y++)
                    {
                        var adr = adr0 + y * stride;
                        for (var x = 0; x < bytePerLine; x++)
                        {
                            if (adr[x] != 255) return false;
                        }
                    }
                    return true;
                }
                finally
                {
                    bitmap.UnlockBits(data);
                }
            }
            */

            private static Brush WhiteMask;
            private static Brush getWhiteMask(int alpha, Color color)
            {
                if (WhiteMask == null)
                {
                    WhiteMask = new SolidBrush(Color.FromArgb(alpha, color));
                }
                return WhiteMask;
            }

            private static Brush ColorMask;
            private static Brush getColorMask(int alpha, Color color)
            {
                if (ColorMask == null)
                {
                    ColorMask = new SolidBrush(Color.FromArgb(alpha, color));
                }
                return ColorMask;
            }

            private static void DrawImageUnscaledCenteringAndCliped(Graphics g, Bitmap src, Rectangle dstRect)
            {
                var innerRect = new Rectangle(
                        dstRect.X + (int)Math.Floor((dstRect.Width - src.Width + 1) / 2.0),
                        dstRect.Y + (int)Math.Floor((dstRect.Height - src.Height + 1) / 2.0),
                        src.Width, src.Height);
                if (dstRect.Contains(innerRect))
                {
                    g.DrawImageUnscaled(src, innerRect);
                }
                else
                {
                    var temp = g.InterpolationMode;
                    var notNearestNeighbor = temp != System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;
                    if (notNearestNeighbor)
                    {
                        g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;
                    }

                    var width = Math.Min(src.Width, dstRect.Width);
                    var height = Math.Min(src.Height, dstRect.Height);

                    var srcRect = new Rectangle(
                        (src.Width - width + 1) / 2,
                        (src.Height - height + 1) / 2,
                        width, height);

                    dstRect.Intersect(innerRect);

                    g.DrawImage(src, dstRect, srcRect, GraphicsUnit.Pixel);

                    if (notNearestNeighbor)
                    {
                        g.InterpolationMode = temp;
                    }
                }

            }

            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    // 管理（managed）リソースの破棄処理をここに記述します。
                    if (iconImage != null)
                    {
                        //iconImage.Dispose(); // SmartStaticIconProvider を使っているので Dispose してはいけない
                        iconImage = null;
                    }
                }

                // 非管理（unmanaged）リソースの破棄処理をここに記述します。

                // 元の Dispose
                base.Dispose(disposing);
            }
        }


        class RatingClickEventArgs : EventArgs { public int NewRating; public int RowIndex; }
        delegate void RatingClickEventHandler(RatingGridViewTextBoxCell sender, RatingClickEventArgs e);

        class RatingGridViewTextBoxCell : DataGridViewTextBoxCell
        {
            public event RatingClickEventHandler RatingClick;

            public bool activeStars;
            private Func<bool> activeStarsFunc;
            private int rating;
            private int temporaryRating = -1;
            private Rectangle starsRectangle = Rectangle.Empty;
            public int Rating
            {
                set
                {
                    var newRating = Math.Max(0, Math.Min(5, value));
                    if (newRating != rating)
                    {
                        rating = newRating;
                        DataGridView?.InvalidateCell(this);
                    }
                }
            }

            /*
            protected override void OnMouseClick(DataGridViewCellMouseEventArgs e)
            {
                if (activeStars && (activeStarsFunc == null || activeStarsFunc()))
                {
                    var newRating = e.Button == MouseButtons.Left ? temporaryRating : e.Button == MouseButtons.Middle ? 0 : -1;
                    if (DataGridView != null && newRating >= 0 && newRating != rating)
                    {

                        RatingClick?.Invoke(this, new RatingClickEventArgs { NewRating = newRating, RowIndex = e.RowIndex });
                    }
                }

                base.OnMouseClick(e);
            }
*/

            protected override void OnMouseMove(DataGridViewCellMouseEventArgs e)
            {
                if (activeStars)
                {
                    if ((activeStarsFunc == null || activeStarsFunc()))
                    {
                        if (!starsRectangle.IsEmpty)
                        {
                            var s = e.X - starsRectangle.Left;
                            var r = Math.Max(1, Math.Min(5, (5 * s / starsRectangle.Width) + 1));
                            //MessageBox.Show($"{e.X} {starsRectangle.Left} {starsRectangle.Width} {r}");
                            if (temporaryRating < 0 && r != rating || temporaryRating >= 0 && r != temporaryRating)
                            {
                                temporaryRating = r;
                                DataGridView?.InvalidateCell(this);
                            }
                            else
                            {
                                temporaryRating = r;
                            }
                        }
                    }
                    else if (temporaryRating != -1)
                    {
                        temporaryRating = -1;
                        DataGridView?.InvalidateCell(this);
                    }
                }

                base.OnMouseMove(e);
            }

            protected override void OnMouseDown(DataGridViewCellMouseEventArgs e)
            {
                if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Middle)
                {
                    if (activeStars && (activeStarsFunc == null || activeStarsFunc()))
                    {
                        var newRating = e.Button == MouseButtons.Left ? temporaryRating : e.Button == MouseButtons.Middle ? 0 : -1;
                        if (DataGridView != null && newRating >= 0 && newRating != rating)
                        {
                            /*
                            var clickedRow = DataGridView.Rows[e.RowIndex];
                            if (!clickedRow.Selected)
                            {
                                //var temp = selectionSynchronizing;
                                //selectionSynchronizing = true;
                                foreach (DataGridViewRow row in (from DataGridViewRow r in DataGridView.SelectedRows select r).ToArray())
                                {
                                    row.Selected = row == clickedRow;
                                }
                                //selectionSynchronizing = temp;
                                //clickedRow.Selected = true;
                            }
                            */

                            RatingClick?.Invoke(this, new RatingClickEventArgs { NewRating = newRating, RowIndex = e.RowIndex });
                        }
                    }

                    //base.OnMouseClick(e);
                }
                else if ((e.Button & MouseButtons.Right) == MouseButtons.Right)
                {
                    temporaryRating = -1;
                    DataGridView?.InvalidateCell(this);
                }
                base.OnMouseDown(e);
            }

            protected override void OnMouseLeave(int rowIndex)
            {
                if (activeStars)
                {
                    if ((activeStarsFunc == null || activeStarsFunc()))
                    {
                        if (rating != temporaryRating)
                        {
                            temporaryRating = -1;
                            DataGridView?.InvalidateCell(this);
                        }
                        else
                        {
                            temporaryRating = -1;
                        }
                    }
                    else if (temporaryRating != -1)
                    {
                        temporaryRating = -1;
                        DataGridView?.InvalidateCell(this);
                    }
                }
                closeToolTip(onlyIfMouseLeave: true);
                base.OnMouseLeave(rowIndex);
            }

            public RatingGridViewTextBoxCell(bool activeStars, Func<bool> activeStarsFunc)
            {
                Value = "★★★★★";
                this.activeStars = activeStars;
                this.activeStarsFunc = activeStarsFunc;
            }

            bool toolTipMaking = false;
            protected override async void OnMouseEnter(int rowIndex)
            {
                base.OnMouseEnter(rowIndex);

                if (!toolTipMaking)
                {
                    var dataGridView = DataGridView;
                    if (dataGridView != null)
                    {
                        toolTipMaking = true;
                        var cf = dataGridView.FindForm() as CatalogForm;
                        var toolTip = cf.toolTip;
                        await Task.Delay(toolTip.InitialDelay);
                        if (toolTipMaking)
                        {
                            // DataGridView は toolTip を表示できない
                            // https://social.msdn.microsoft.com/Forums/ja-JP/25938714-cae3-4610-8a99-094b91de7b49/datagridviewtooltip?forum=vsgeneralja
                            var CursorPosition = Cursor.Position;
                            var target = cf.pnlRight;
                            var rectangle = target.RectangleToClient(dataGridView.RectangleToScreen(dataGridView.GetCellDisplayRectangle(ColumnIndex, RowIndex, cutOverflow: true)));
                            var point = target.PointToClient(CursorPosition);
                            // if (DataGridView?.Cursor is Cursor cursor) // HotSpot が正しく取得できない
                            if (Cursor.Current is Cursor cursor)
                            {
                                point.Y += cursor.Size.Height - cursor.HotSpot.Y; // 予め縦方向にずらす
                            }
                            if (rectangle.Contains(point))
                            {
                                // 右（右の列を隠す）
                                //point.X = rectangle.Right;

                                // 下（次の行を隠す、予め縦方向にずらしてないとマウスカーソルで先頭のほうが見えにくい）
                                point.Y = rectangle.Bottom;
                            }
                            toolTip.Show(Message.MiddleClickLeftFlickToResetRating, target, point);
                            await Task.Delay(toolTip.AutoPopDelay);
                            closeToolTip(onlyIfMouseLeave: false);
                        }
                    }
                }
            }
            protected override void Dispose(bool disposing)
            {
                if (disposing)
                {
                    closeToolTip(onlyIfMouseLeave: false);
                }
                base.Dispose(disposing);
            }


            // MouseLeave がツールチップとカーソルが重なったときに発生することから
            // ツールチップが点滅する問題を回避する
            // ツールチップが領域を回避するなら不要だが
            // 画面サイズの関係で必ず回避できるとは限らないので必要になる
            private void closeToolTip(bool onlyIfMouseLeave)
            {
                DataGridView dataGridView = null;
                if (onlyIfMouseLeave)
                {
                    dataGridView = DataGridView;
                    if (dataGridView == null)
                    {
                        toolTipMaking = false;
                        return;
                    }
                    else
                    {
                        onlyIfMouseLeave = dataGridView.GetCellDisplayRectangle(ColumnIndex, RowIndex, cutOverflow: true).Contains(dataGridView.PointToClient(Cursor.Position));
                        //var dgvPoint = dataGridView.PointToClient(Cursor.Position);
                        //var hit = dataGridView.HitTest(dgvPoint.X, dgvPoint.Y);
                        //onlyIfMouseLeave = hit.RowIndex == RowIndex && hit.ColumnIndex == ColumnIndex;
                    }
                }
                if (!onlyIfMouseLeave)
                {
                    if (toolTipMaking)
                    {
                        toolTipMaking = false;
                        if (dataGridView == null) dataGridView = DataGridView;
                        if (dataGridView != null)
                        {
                            var cf = dataGridView.FindForm() as CatalogForm;
                            cf.toolTip.Hide(cf.pnlRight);
                        }
                    }
                }
            }

            protected override void Paint(Graphics graphics, Rectangle clipBounds, Rectangle cellBounds, int rowIndex, DataGridViewElementStates cellState, object value, object formattedValue, string errorText, DataGridViewCellStyle cellStyle, DataGridViewAdvancedBorderStyle advancedBorderStyle, DataGridViewPaintParts paintParts)
            {
                var r = temporaryRating >= 0 ? temporaryRating : rating;
                if (r < 0) r = 0;


                //境界線の内側に範囲を取得する
                Rectangle borderRect = this.BorderWidths(advancedBorderStyle);
                Rectangle paintRect = new Rectangle(
                    cellBounds.Left + borderRect.Left,
                    cellBounds.Top + borderRect.Top,
                    cellBounds.Width - borderRect.Right,
                    cellBounds.Height - borderRect.Bottom);

                //Paddingを差し引く
                paintRect.Offset(cellStyle.Padding.Right, cellStyle.Padding.Top);
                paintRect.Width -= cellStyle.Padding.Horizontal;
                paintRect.Height -= cellStyle.Padding.Vertical;

                /*
                //背景色を決定する
                //選択されている時とされていない時で色を変える
                bool isSelected =
                    (cellState & DataGridViewElementStates.Selected) ==
                    DataGridViewElementStates.Selected;
                Color bkColor;
                if (isSelected &&
                    (paintParts & DataGridViewPaintParts.SelectionBackground) ==
                        DataGridViewPaintParts.SelectionBackground)
                {
                    bkColor = cellStyle.SelectionBackColor;
                }
                else
                {
                    bkColor = cellStyle.BackColor;
                }
                //背景を描画する
                if ((paintParts & DataGridViewPaintParts.Background) ==
                    DataGridViewPaintParts.Background)
                {
                    using (SolidBrush backBrush = new SolidBrush(bkColor))
                    {
                        graphics.FillRectangle(backBrush, paintRect);
                    }
                }
                */

                base.Paint(graphics, clipBounds, cellBounds, rowIndex, cellState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts & ~DataGridViewPaintParts.ContentForeground);

                /*
                //背景を描画する
                if ((paintParts & DataGridViewPaintParts.Background) ==
                    DataGridViewPaintParts.Background)
                {
                    graphics.FillRectangle(Brushes.Black, paintRect);
                }
                */

                //テキストを表示する
                if ((paintParts & DataGridViewPaintParts.ContentForeground) ==
                    DataGridViewPaintParts.ContentForeground)
                {
                    bool isSelected =
                       (cellState & DataGridViewElementStates.Selected) ==
                       DataGridViewElementStates.Selected;
                    Color fColor = isSelected ? cellStyle.SelectionForeColor : cellStyle.ForeColor;
                    var isDarkFore = fColor.G < 128;
                    var gold = isDarkFore ? Color.DarkGoldenrod : Color.Gold;
                    var gray = isDarkFore ? Color.LightGray : Color.LightSlateGray;

                    if (sizeNotSet)
                    {
                        sizeNotSet = false;
                        periodSize = TextRenderer.MeasureText(graphics, ".", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);
                        fullWidth = TextRenderer.MeasureText(graphics, "★★★★★", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                    }

                    var periodWidth = periodSize.Width;// TextRenderer.MeasureText(graphics, ".", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                    //var fullSize = TextRenderer.MeasureText(graphics, "★★★★★", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);
                    var preStr = "★★★★★".Substring(0, r);
                    var sufStr = "★★★★★".Substring(r);
                    //var height = paintRect.Height;
                    //paintRect.Inflate(-2, -2);
                    paintRect.X += (paintRect.Width - fullWidth) / 2;
                    paintRect.Y += (paintRect.Height - periodSize.Height + 1) / 2;
                    starsRectangle = paintRect;
                    starsRectangle.X += periodWidth - cellBounds.X;
                    starsRectangle.Width = fullWidth;
                    TextRenderer.DrawText(graphics, preStr, cellStyle.Font, paintRect, gold, TextFormatFlags.NoPadding);
                    paintRect.X += TextRenderer.MeasureText(graphics, preStr, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                    TextRenderer.DrawText(graphics, sufStr, cellStyle.Font, paintRect, gray, TextFormatFlags.NoPadding);
                }

                //base.Paint(graphics, clipBounds, cellBounds, rowIndex, cellState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts);
            }

            private bool sizeNotSet = true;
            private Size periodSize;
            private int fullWidth;
        }

        class RainbowDataGridViewTextBoxCell : DataGridViewTextBoxCell
        {
            string name;
            public ZipTag[] Tags;
            private Tuple<int, int, string>[] indexLengthTagTorios = null;
            public RainbowDataGridViewTextBoxCell(ZipTag[] tags)
            {
                this.Tags = tags;
            }

            protected override void Paint(Graphics graphics, Rectangle clipBounds, Rectangle cellBounds, int rowIndex, DataGridViewElementStates cellState, object value, object formattedValue, string errorText, DataGridViewCellStyle cellStyle, DataGridViewAdvancedBorderStyle advancedBorderStyle, DataGridViewPaintParts paintParts)
            {
                //base.Paint(graphics, clipBounds, cellBounds, rowIndex, cellState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts); return;

                string newName;
                if (Value == null) newName = "";
                else newName = Value.ToString();
                if (newName != name)
                {
                    name = newName;
                    if (Tags != null)
                    {
                        indexLengthTagTorios = (new ZipPlaInfo(name)).GetIndexLengthTagTorios();
                    }
                }

                //境界線の内側に範囲を取得する
                Rectangle borderRect = this.BorderWidths(advancedBorderStyle);
                Rectangle paintRect = new Rectangle(
                    cellBounds.Left + borderRect.Left,
                    cellBounds.Top + borderRect.Top,
                    cellBounds.Width - borderRect.Right,
                    cellBounds.Height - borderRect.Bottom);

                //Paddingを差し引く
                paintRect.Offset(cellStyle.Padding.Right, cellStyle.Padding.Top);
                paintRect.Width -= cellStyle.Padding.Horizontal;
                paintRect.Height -= cellStyle.Padding.Vertical;

                base.Paint(graphics, clipBounds, cellBounds, rowIndex, cellState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts & ~DataGridViewPaintParts.ContentForeground);
                //return;

                //テキストを表示する
                if ((paintParts & DataGridViewPaintParts.ContentForeground) ==
                    DataGridViewPaintParts.ContentForeground)
                {
                    //本来は、cellStyleによりTextFormatFlagsを決定すべき
                    //TextFormatFlags flags = TextFormatFlags.HorizontalCenter |
                    //  TextFormatFlags.VerticalCenter;
                    TextFormatFlags flags = 0 | TextFormatFlags.NoPrefix;//  TextFormatFlags.EndEllipsis;// | TextFormatFlags.VerticalCenter
                                                                         //色を決定
                    bool isSelected =
                        (cellState & DataGridViewElementStates.Selected) ==
                        DataGridViewElementStates.Selected;
                    Color fColor = isSelected ? cellStyle.SelectionForeColor : cellStyle.ForeColor;

                    var periodSize = TextRenderer.MeasureText(graphics, ".", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    //var periodWidth = 0 * periodSize.Width;// TextRenderer.MeasureText(graphics, ".", cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;

                    //var charHeight = periodSize.Height;
                    //var hShift = 1;
                    var charHeight = getCharHeight(cellStyle.Font, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    //charHeight = periodSize.Height;

                    var vPadding = Math.Max(0, (paintRect.Height - charHeight) / 4);

                    var paintRectYForBG = paintRect.Y + vPadding;
                    var height = paintRect.Height - vPadding * 2;
                    paintRect.Y += (paintRect.Height - charHeight + 1) / 2;

                    var nameTrimed = ThumbViewer.GetTextBaseNameEndEllipsis(name, cellStyle.Font, paintRect.Width, noPadding: false);
                    if (nameTrimed == name)
                    {
                        ToolTipText = null;
                    }
                    else
                    {
                        ToolTipText = name;
                    }
                    var tLen = nameTrimed.Length;
                    var tLen0 = Math.Min(nameTrimed.Length, tLen); // 文字幅が均一でないので逆転もありうる
                    var tLen2 = 0;
                    while (tLen2 < tLen0 && name[tLen2] == nameTrimed[tLen2]) tLen2++;
                    if (Tags == null || indexLengthTagTorios == null)
                    {
                        //TextRenderer.DrawText(graphics, name, cellStyle.Font, paintRect, fColor, flags);
                        TextRenderer.DrawText(graphics, nameTrimed, cellStyle.Font, paintRect, fColor, flags);

                    }
                    else
                    {
                        var index = 0;
                        var rectangles = new Rectangle[indexLengthTagTorios.Length * 2];
                        var strs = new string[indexLengthTagTorios.Length * 2];
                        var colors = new Color[indexLengthTagTorios.Length];
                        var i = 0;
                        foreach (var torio in indexLengthTagTorios)
                        {
                            var tagName = torio.Item3;
                            var tag = Tags.FirstOrDefault(t => t.Name == tagName);
                            if (tag == default(ZipTag)) continue;
                            // if( そのタグが描画対象でなければコンティニュー)


                            //var str = name.Substring(index, torio.Item1 - index);
                            var str = nameTrimed.Substring(Math.Min(tLen, index), Math.Max(0, Math.Min(tLen, torio.Item1) - index));
                            var width = TextRenderer.MeasureText(graphics, str, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;
                            //TextRenderer.DrawText(graphics, str, cellStyle.Font, paintRect, fColor, flags);
                            strs[2 * i] = str;
                            rectangles[2 * i] = paintRect;
                            paintRect.X += width;
                            paintRect.Width -= width;
                            //str = name.Substring(torio.Item1, torio.Item2);
                            //str = nameTrimed.Substring(Math.Min(tLen, torio.Item1), Math.Max(0, Math.Min(tLen - torio.Item1, torio.Item2)));
                            str = nameTrimed.Substring(Math.Min(tLen2, torio.Item1), Math.Max(0, Math.Min(tLen2 - torio.Item1, torio.Item2)));
                            width = TextRenderer.MeasureText(graphics, str, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;
                            //var tagWidth = TextRenderer.MeasureText(graphics, tagPart, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                            using (var b = new SolidBrush(tag.BackColor))
                            {
                                //graphics.FillRectangle(b, new Rectangle(paintRect.X + hShift, paintRectYForBG, tagWidth, height));

                                var baseRect = new Rectangle(paintRect.X, paintRectYForBG, width, height);
                                var drawRect = GetHShift(baseRect, str, cellStyle.Font, flags);
                                if (!drawRect.IsEmpty) graphics.FillRectangle(b, drawRect);
                            }
                            //TextRenderer.DrawText(graphics, str, cellStyle.Font, paintRect, tag.ForeColor, flags);
                            colors[i] = tag.ForeColor;
                            strs[2 * i + 1] = str;
                            rectangles[2 * i + 1] = paintRect;
                            paintRect.X += width;
                            paintRect.Width -= width;
                            index = torio.Item1 + str.Length;

                            i++;
                        }
                        for (var j = 0; j < i; j++)
                        {
                            TextRenderer.DrawText(graphics, strs[2 * j], cellStyle.Font, rectangles[2 * j], fColor, flags);
                            TextRenderer.DrawText(graphics, strs[2 * j + 1], cellStyle.Font, rectangles[2 * j + 1], colors[j], flags);
                        }
                        //TextRenderer.DrawText(graphics, name.Substring(index), cellStyle.Font, paintRect, fColor, flags);
                        TextRenderer.DrawText(graphics, nameTrimed.Substring(Math.Min(tLen, index)), cellStyle.Font, paintRect, fColor, flags);

                        /*
                        var index = 0;
                        var rectangles = new Rectangle[indexLengthTagTorios.Length * 2];
                        var strs = new string[indexLengthTagTorios.Length * 2];
                        var colors = new Color[indexLengthTagTorios.Length];
                        var i = 0;
                        foreach (var torio in indexLengthTagTorios)
                        {
                            var tagName = torio.Item3;
                            var tag = tags.FirstOrDefault(t => t.Name == tagName);
                            if (tag == default(ZipTag)) continue;
                            // if( そのタグが描画対象でなければコンティニュー)


                            //var str = name.Substring(index, torio.Item1 - index);
                            var str = nameTrimed.Substring(Math.Min(tLen, index), Math.Max(0, Math.Min(tLen, torio.Item1) - index));
                            var width = TextRenderer.MeasureText(graphics, str, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                            //TextRenderer.DrawText(graphics, str, cellStyle.Font, paintRect, fColor, flags);
                            strs[2 * i] = str;
                            rectangles[2 * i] = paintRect;
                            paintRect.X += width;
                            paintRect.Width -= width;
                            //str = name.Substring(torio.Item1, torio.Item2);
                            str = nameTrimed.Substring(Math.Min(tLen, torio.Item1), Math.Max(0, Math.Min(tLen - torio.Item1, torio.Item2)));
                            var tagPart = nameTrimed.Substring(Math.Min(tLen2, torio.Item1), Math.Max(0, Math.Min(tLen2 - torio.Item1, torio.Item2)));
                            width = TextRenderer.MeasureText(graphics, str, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                            var tagWidth = str == tagPart ? width : TextRenderer.MeasureText(graphics, tagPart, cellStyle.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
                            using (var b = new SolidBrush(tag.BackColor))
                            {
                                //graphics.FillRectangle(b, new Rectangle(paintRect.X + hShift, paintRectYForBG, tagWidth, height));

                                var baseRect = new Rectangle(paintRect.X, paintRectYForBG, tagWidth, height);
                                var drawRect = GetHShift(baseRect, tagPart, cellStyle.Font, flags);
                                if (!drawRect.IsEmpty) graphics.FillRectangle(b, drawRect);
                            }
                            //TextRenderer.DrawText(graphics, str, cellStyle.Font, paintRect, tag.ForeColor, flags);
                            colors[i] = tag.ForeColor;
                            strs[2 * i + 1] = str;
                            rectangles[2 * i + 1] = paintRect;
                            paintRect.X += width;
                            paintRect.Width -= width;
                            index = torio.Item1 + torio.Item2;

                            i++;
                        }
                        for (var j = 0; j < i; j++)
                        {
                            TextRenderer.DrawText(graphics, strs[2 * j], cellStyle.Font, rectangles[2 * j], fColor, flags);
                            TextRenderer.DrawText(graphics, strs[2 * j + 1], cellStyle.Font, rectangles[2 * j + 1], colors[j], flags);
                        }
                        //TextRenderer.DrawText(graphics, name.Substring(index), cellStyle.Font, paintRect, fColor, flags);
                        TextRenderer.DrawText(graphics, nameTrimed.Substring(Math.Min(tLen, index)), cellStyle.Font, paintRect, fColor, flags);
                        */
                    }
                }
                //base.Paint(graphics, clipBounds, cellBounds, rowIndex, cellState, value, formattedValue, errorText, cellStyle, advancedBorderStyle, paintParts);
            }

            static int getCharHeight_charHeight = -1;
            static int getCharHeight(Font font,
                TextFormatFlags flags)
            {
                if (getCharHeight_charHeight < 0)
                {
                    //getDrawRainbowParams_hShift = GetHShift("A", font, flagsForShift);

                    getCharHeight_charHeight = TextRenderer.MeasureText("A", font, new Size(int.MaxValue, int.MinValue), flags).Height;
                }
                return getCharHeight_charHeight;
            }

            // 与えられた長方形を横にシフトし、必要最小限だけ横に伸ばし返す
            static readonly Dictionary<string, Rectangle> GetHShift_CharRectangle = new Dictionary<string, Rectangle>();
            static Rectangle GetHShift(Rectangle baseRect, string testStr, Font font, TextFormatFlags flags)
            {
                Rectangle charRectangle;
                if (!GetHShift_CharRectangle.TryGetValue(testStr, out charRectangle))
                {
                    charRectangle = GetCharRectangle(testStr, font, flags, onlyHorizontal: true);
                }

                if (charRectangle.IsEmpty) return Rectangle.Empty;

                var resultShift2 = charRectangle.Left + charRectangle.Right - baseRect.Width;
                if ((resultShift2 & 1) == 1)
                {
                    baseRect.Width++;
                }

                baseRect.X += resultShift2 / 2;

                return baseRect;

            }

            public static Rectangle GetCharRectangle(string text, Font font, TextFormatFlags flags, bool onlyHorizontal)
            {
                if (string.IsNullOrEmpty(text)) return Rectangle.Empty;

                var mesuredSize = TextRenderer.MeasureText(text, font, new Size(int.MaxValue, int.MinValue), flags);

                if (mesuredSize.Width <= 0 || mesuredSize.Height <= 0) return Rectangle.Empty;

                var hOffset = (mesuredSize.Width + 1) / 2;
                var vOffset = (mesuredSize.Height + 1) / 2;

                var canvasWidth = mesuredSize.Width + 2 * hOffset;
                var canvasHeight = mesuredSize.Height + 2 * vOffset;

                using (var canvas = new Bitmap(canvasWidth, canvasHeight))
                {
                    var canvasRect = new Rectangle(0, 0, canvasWidth, canvasHeight);
                    using (var g = Graphics.FromImage(canvas))
                    {
                        g.FillRectangle(Brushes.White, canvasRect);
                        TextRenderer.DrawText(g, text, font, new Point(hOffset, vOffset), Color.Black, flags);
                    }

                    var img = canvas.LockBits(canvasRect, ImageLockMode.ReadOnly, canvas.PixelFormat);
                    try
                    {
                        var stride = img.Stride;
                        var bytesPerPixel = Image.GetPixelFormatSize(canvas.PixelFormat) / 8;
                        unsafe
                        {
                            var adr = (byte*)img.Scan0;

                            var top = 0;
                            if (!onlyHorizontal)
                            {
                                while (top < canvasHeight)
                                {
                                    var white = true;
                                    var localAdr = adr + (top * stride);
                                    for (var x = 0; x < canvasWidth; x++)
                                    {
                                        if (localAdr[bytesPerPixel * x] < 255)
                                        {
                                            white = false;
                                            break;
                                        }
                                    }
                                    if (!white) break;
                                    top++;
                                }
                                if (top == canvasHeight) return Rectangle.Empty;
                            }

                            var buttomMinus1 = canvasHeight - 1;
                            if (!onlyHorizontal)
                            {
                                while (buttomMinus1 > top)
                                {
                                    var white = true;
                                    var localAdr = adr + (buttomMinus1 * stride);
                                    for (var x = 0; x < canvasWidth; x++)
                                    {
                                        if (localAdr[bytesPerPixel * x] < 255)
                                        {
                                            white = false;
                                            break;
                                        }
                                    }
                                    if (!white) break;
                                    buttomMinus1--;
                                }
                            }

                            var left = 0;
                            while (left < canvasWidth)
                            {
                                var white = true;
                                var localAdr = adr + left * bytesPerPixel;
                                for (var y = 0; y < canvasHeight; y++)
                                {
                                    if (localAdr[y * stride] < 255)
                                    {
                                        white = false;
                                        break;
                                    }
                                }
                                if (!white) break;

                                left++;
                            }
                            if (left == canvasWidth) return Rectangle.Empty;


                            var rightMinus1 = canvasWidth - 1;
                            while (rightMinus1 > left)
                            {
                                var white = true;
                                var localAdr = adr + rightMinus1 * bytesPerPixel;
                                for (var y = 0; y < canvasHeight; y++)
                                {
                                    if (localAdr[y * stride] < 255)
                                    {
                                        white = false;
                                        break;
                                    }
                                }
                                if (!white) break;
                                rightMinus1--;
                            }

                            return new Rectangle(left - hOffset, top - vOffset, rightMinus1 + 1 - left, buttomMinus1 + 1 - top);
                        }
                    }
                    finally
                    {
                        canvas.UnlockBits(img);
                    }
                }
            }
        }

        /*
        private string getShortRatingString(string path)
        {
            var r = ZipPlaInfo.GetOnlyRating(path);
            if (r >= 0) return "★×" + r;
            else return "";
        }
        */
        
        private string getShortTimeString(DateTime dateTime, CultureInfo culture)
        {
            try
            {
                return dateTime > DateTime.MinValue ? dateTime.ToString("g", culture) : EmptyPageString;
            }
            catch (ArgumentOutOfRangeException)
            {
                try
                {
                    return dateTime > DateTime.MinValue ? dateTime.ToString("s") : EmptyPageString;
                }
                catch
                {
                    return "<ERROR>";
                }
            }
            catch
            {
                return "<ERROR>";
            }
        }

        private readonly Dictionary<DataGridViewColumn, int> dgvFileList_ColumnHeaderMouseClick_LastClickedTime = new Dictionary<DataGridViewColumn, int>();
        private void dgvFileList_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                if (e.ColumnIndex == tbcIcon.Index)
                {
                    var header = dgvFileList.Columns[tbcIcon.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Ascending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.TypeInAsc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.TypeInDesc;
                    }
                }
                else if (e.ColumnIndex == tbcFileName.Index)
                {
                    var header = dgvFileList.Columns[tbcFileName.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Ascending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.NameInAsc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.NameInDesc;
                    }
                }
                else if (e.ColumnIndex == tbcRating.Index)
                {
                    var header = dgvFileList.Columns[tbcRating.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Descending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.RatingInDesc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.RatingInAsc;
                    }
                }
                else if (e.ColumnIndex == tbcCreateTime.Index)
                {
                    var header = dgvFileList.Columns[tbcCreateTime.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Descending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.CreatedInDesc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.CreatedInAsc;
                    }
                }
                else if (e.ColumnIndex == tbcAccessTime.Index)
                {
                    var header = dgvFileList.Columns[tbcAccessTime.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Descending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.AccessedInDesc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.AccessedInAsc;
                    }
                }
                else if (e.ColumnIndex == tbcWriteTime.Index)
                {
                    var header = dgvFileList.Columns[tbcWriteTime.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Descending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.ModifiedInDesc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.ModifiedInAsc;
                    }
                }
                else if (e.ColumnIndex == tbcSize.Index)
                {
                    var header = dgvFileList.Columns[tbcSize.Index].HeaderCell;
                    if (header.SortGlyphDirection != SortOrder.Descending)
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.SizeInDesc;
                    }
                    else
                    {
                        cbSortBy.SelectedIndex = (int)SortMode.SizeInAsc;
                    }
                }
                else if (e.ColumnIndex >= 0)
                {
                    var tbc = dgvFileList.Columns[e.ColumnIndex];
                    if (tbc.SortMode == DataGridViewColumnSortMode.Programmatic)
                    {
                        var dir = tbc.HeaderCell.SortGlyphDirection;
                        if (dir == SortOrder.Ascending) dir = SortOrder.Descending;
                        else if (dir == SortOrder.Descending) dir = SortOrder.Ascending;
                        else
                        {
                            if (dgvFileList_ColumnHeaderMouseClick_LastClickedTime.TryGetValue(tbc, out var lastClick))
                            {
                                var now = Environment.TickCount;
                                if (InDoubleClickTime(now, lastClick))
                                {
                                    dir = SortOrder.Ascending;
                                }
                                else
                                {
                                    dir = SortOrder.Descending;
                                }
                            }
                            else
                            {
                                dir = SortOrder.Descending;
                            }
                        }

                        var dirString = dir == SortOrder.Ascending ? "InAsc" : "InDesc";
                        SortMode sortMode;
                        if (Enum.TryParse("V" + tbc.Name.Substring(3) + dirString, out sortMode))
                        {
                            //if (cbSortBy_SelectedValueChanged_Stop) return;
                            var success = false;
                            lock (ZipPathArrayLocker)
                            {
                                if (ZipPathArray != null)
                                {
                                    success = true;
                                    foreach (DataGridViewColumn c in dgvFileList.Columns) c.HeaderCell.SortGlyphDirection = c != tbc ? SortOrder.None : dir;
                                    tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex, sortMode: sortMode);
                                }
                            }
                            if (success)
                            {
                                var temp = cbSortBy_SelectedValueChanged_Stop;
                                cbSortBy_SelectedValueChanged_Stop = true;
                                cbSortBy.SelectedIndex = -1;
                                cbSortBy_SelectedValueChanged_Stop = temp;
                                setFileListFromThumbnailViewer(volatilitySort: true);
                                var si = tvCatalog.SelectedIndex;
                                if (si >= 0)
                                {
                                    //tvCatalog.ScrollBarToIndex(si);
                                    tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[si]);
                                }
                                else
                                {
                                    var s2d = tvCatalog.ShowIndexToDataIndex;
                                    if (s2d.Length > 0)
                                    {
                                        tvCatalog.ScrollBarToIndex(s2d[0]);
                                    }
                                }
                            }
                        }
                        if (dir == SortOrder.Descending) dgvFileList_ColumnHeaderMouseClick_LastClickedTime[tbc] = Environment.TickCount;
                    }
                }
            }
            else if (e.Button == MouseButtons.Right)
            {
                iconToolStripMenuItem.Checked = tbcIcon.Visible;
                pageToolStripMenuItem.Checked = tbcPage.Visible;
                ratingHeaderRightClickToolStripMenuItem.Checked = tbcRating.Visible;
                dateCreatedToolStripMenuItem.Checked = tbcCreateTime.Visible;
                accessTimeToolStripMenuItem.Checked = tbcAccessTime.Visible;
                writeTimeToolStripMenuItem.Checked = tbcWriteTime.Visible;
                sizeToolStripMenuItem.Checked = tbcSize.Visible;
                resolutionToolStripMenuItem.Checked = tbcResolution.Visible;
                ratioToolStripMenuItem.Checked = tbcRatio.Visible;
                widthToolStripMenuItem.Checked = tbcWidth.Visible;
                heightToolStripMenuItem.Checked = tbcHeight.Visible;
                lengthToolStripMenuItem.Checked = tbcLength.Visible;

                fPSToolStripMenuItem.Checked = tbcFPS.Visible;

                setFont(iconToolStripMenuItem, bold: e.ColumnIndex == tbcIcon.Index);
                setFont(fileNameToolStripMenuItem, bold: e.ColumnIndex == tbcFileName.Index);
                setFont(pageToolStripMenuItem, bold: e.ColumnIndex == tbcPage.Index);
                setFont(ratingHeaderRightClickToolStripMenuItem, bold: e.ColumnIndex == tbcRating.Index);
                setFont(dateCreatedToolStripMenuItem, bold: e.ColumnIndex == tbcCreateTime.Index);
                setFont(accessTimeToolStripMenuItem, bold: e.ColumnIndex == tbcAccessTime.Index);
                setFont(writeTimeToolStripMenuItem, bold: e.ColumnIndex == tbcWriteTime.Index);
                setFont(sizeToolStripMenuItem, bold: e.ColumnIndex == tbcSize.Index);
                setFont(resolutionToolStripMenuItem, bold: e.ColumnIndex == tbcResolution.Index);
                setFont(ratioToolStripMenuItem, bold: e.ColumnIndex == tbcRatio.Index);
                setFont(widthToolStripMenuItem, bold: e.ColumnIndex == tbcWidth.Index);
                setFont(heightToolStripMenuItem, bold: e.ColumnIndex == tbcHeight.Index);
                setFont(lengthToolStripMenuItem, bold: e.ColumnIndex == tbcLength.Index);
                setFont(fPSToolStripMenuItem, bold: e.ColumnIndex == tbcFPS.Index);


                var count = cmsFileListHeader.Items.Count;
                var tsmiArray = new ToolStripMenuItem[count];
                foreach (DataGridViewColumn column in dgvFileList.Columns)
                {
                    ToolStripMenuItem tsmi;
                    if (column == tbcIcon) tsmi = iconToolStripMenuItem;
                    else if (column == tbcFileName) tsmi = fileNameToolStripMenuItem;
                    else if (column == tbcPage) tsmi = pageToolStripMenuItem;
                    else if (column == tbcRating) tsmi = ratingHeaderRightClickToolStripMenuItem;
                    else if (column == tbcCreateTime) tsmi = dateCreatedToolStripMenuItem;
                    else if (column == tbcAccessTime) tsmi = accessTimeToolStripMenuItem;
                    else if (column == tbcWriteTime) tsmi = writeTimeToolStripMenuItem;
                    else if (column == tbcSize) tsmi = sizeToolStripMenuItem;
                    else if (column == tbcResolution) tsmi = resolutionToolStripMenuItem;
                    else if (column == tbcRatio) tsmi = ratioToolStripMenuItem;
                    else if (column == tbcWidth) tsmi = widthToolStripMenuItem;
                    else if (column == tbcHeight) tsmi = heightToolStripMenuItem;
                    else if (column == tbcLength) tsmi = lengthToolStripMenuItem;
                    else tsmi = fPSToolStripMenuItem;

                    tsmiArray[column.DisplayIndex] = tsmi;
                }
                cmsFileListHeader.Items.Clear();
                cmsFileListHeader.Items.AddRange(tsmiArray);

                if (this != ActiveForm) Activate();
                cmsFileListHeader.Show(Cursor.Position);
            }
        }

        private void setFont(ToolStripItem tsi, bool? bold = null)
        {
            if (bold != null)
            {
                var current = tsi.Font;
                if ((bool)bold)
                {
                    tsi.Font = new Font(current, current.Style | FontStyle.Bold);
                }
                else
                {
                    tsi.Font = new Font(current, current.Style & ~FontStyle.Bold);
                }
            }
        }

        /*
        bool cbSortBy_DropDownClosed_Resorted = false;
        private void cbSortBy_DropDownClosed(object sender, EventArgs e)
        {
            var cb = (ComboBox)sender;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && cb.SelectedIndex == 4 && cb.RectangleToScreen(new Rectangle(0, 0, cb.DropDownWidth, cb.DropDownHeight)).Contains(Cursor.Position))
                {
                    tvCatalog.SelectedIndex = -1; // プロパティの set の処理において冗長な描画が入るが、影響の小ささから可読性を優先。
                    GetSortArray_RandomOrder = null;
                    tvCatalog.ShowIndexToDataIndex = GetSortArray();
                    setFileListFromThumbnailViewer();
                    var s2d = tvCatalog.ShowIndexToDataIndex;
                    if (s2d.Length > 0)
                    {
                        tvCatalog.ScrollBarToIndex(s2d[0]);
                    }
                    cbSortBy_DropDownClosed_Resorted = true;
                }
            }
        }
        */

        Graphics cbFilter_Graphic = null;
        private int cbLocationMinimumWidth;
        private void setCbFilterWidth()
        {
            // 縮小中にフィルタが書き換わる実装に備えて
            if (WindowState == FormWindowState.Minimized) return;

            // 長さの調整
            if (cbFilter_Graphic == null) cbFilter_Graphic = cbFilter.CreateGraphics();

            var text = cbFilter.Text;
            var start = cbFilter.SelectionStart;
            var length = cbFilter.SelectionLength;

            var textWidth = TextRenderer.MeasureText(cbFilter_Graphic, text, cbFilter.Font, new Size(int.MaxValue, int.MinValue),
                TextFormatFlags.NoPrefix).Width + cbFilter.Height * 3 / 2;
            //cbFilter_Graphic.MeasureString(cbFilter.Text, cbFilter.Font).Width + cbFilter.Height

            var widthFromText = Math.Min(cbFilter.Width + cbLocation.Width - cbLocationMinimumWidth, Math.Max(cbFilter.MinimumSize.Width, textWidth));
            var delta = widthFromText - cbFilter.Width;
            if (delta != 0)
            {
                // サイズ変更時にオートコンプリートが働いて意図しない動作をするのを回避
                // AutoCompleteMode を None にするのでは効果がない
                var cbFilterItems = (from object item in cbFilter.Items select item).ToArray();
                var cbLocationItems = (from object item in cbLocation.Items select item).ToArray();
                cbFilter.Items.Clear();
                cbLocation.Items.Clear();

                cbLocation.Width -= delta;
                btnLocationCommands.Left -= delta;
                cbSortBy.Left -= delta;
                //pbSearch.Left -= delta;
                cbFilter.Left -= delta;
                cbFilter.Width = widthFromText;

                // クリアした Items の復元
                cbFilter.Items.AddRange(cbFilterItems);
                cbLocation.Items.AddRange(cbLocationItems);

                // 連続実行時に一部のcontrolの表示が遅れて不格好になるのを回避
                cbLocation.Update();
                btnLocationCommands.Update();
                cbSortBy.Update(); ;
                cbFilter.Update();
                //Refresh();

                if (cbFilter.SelectionStart != start) cbFilter.SelectionStart = start;
                if (cbFilter.SelectionLength != length) cbFilter.SelectionLength = length;

                // オートコンプリート問題の旧対策法 
                //cbFilter.AutoCompleteMode = cbFilterACM;
                //cbLocation.AutoCompleteMode = cbLocationACM;
                /*
                if (cbFilter.Text != text || cbFilter.SelectionStart != start || cbFilter.SelectionLength != length)
                {
                    cbFilter.Text = text;
                    cbFilter.SelectionStart = start;
                    cbFilter.SelectionLength = length;
                }
                */
            }
        }

        private SearchManager cbFilter_SearchManager;
        private static readonly Color WindowColor = SystemColors.Window;// Color.FromKnownColor(KnownColor.Window);
        private static readonly Color InvalidColor = SystemColorsWindowIsNearToWhite ? Color.LightGray : Color.Gray;
        private static readonly Color ErrorColor = SystemColorsWindowIsNearToWhite ? Color.Pink : Color.DarkRed;
        private static readonly Color AliasColor = SystemColorsWindowIsNearToWhite ? Color.FromArgb(192, 255, 255) : Color.FromArgb(0, 64, 64);
        private bool cbFilter_TextChanged_StopResort = false;
        private string cbFilter_TextChanged_PrevText = null;
        private bool cbFilter_Valid = true;
        private void cbFilter_TextChanged(object sender, EventArgs e)
        {
            var text = cbFilter.Text;

            // TextChanged は過剰に呼び出される事がある
            if (cbFilter_TextChanged_PrevText == text) return;
            cbFilter_TextChanged_PrevText = text;

            //cbFilter_PasteMode = false;

            setCbFilterWidth();

            if (!cbFilter_Refresh(text)) return;

            if (cbFilter_TextChanged_StopResort) return; // ブックマーク読み込み用

            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && ZipPathArray.Length > 0)
                {
                    //using (var tm = new TimeMeasure())
                    {
                        tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex);
                    }

                    setFileListFromThumbnailViewer();
                    var si = tvCatalog.SelectedIndex;
                    if (si >= 0)
                    {
                        // スクロール量の変化を伴う（誤：伴ない）ので MinimalMove は使わない
                        tvCatalog.ScrollBarToIndex(si);
                        //tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[si]);
                    }
                }
            }
        }

        private bool cbFilter_Refresh(string filter)
        {
            var invalid = InArchive || InMovie; // フィルタが無効の場合でもエラーの有無はチェックする
            if (aliasesToFilteringStrings != null && aliasesToFilteringStrings.ContainsKey(filter))
            {
                try
                {
                    cbFilter_SearchManager = new SearchManager(aliasesToFilteringStrings[filter]);
                }
                catch
                {
                    cbFilter_SearchManager = null;
                    cbFilter.BackColor = invalid ? InvalidColor : ErrorColor;
                    cbFilter_Valid = false;
                    return false;
                }
                cbFilter.BackColor = invalid ? InvalidColor : AliasColor;
                cbFilter_Valid = true;
                return true;
            }
            else
            {
                try
                {
                    cbFilter_SearchManager = new SearchManager(filter);
                }
                catch
                {
                    cbFilter_SearchManager = null;
                    cbFilter.BackColor = invalid ? InvalidColor : ErrorColor;
                    cbFilter_Valid = false;
                    return false;
                }
                cbFilter.BackColor = invalid ? InvalidColor : WindowColor;
                cbFilter_Valid = true;
                return true;
            }
        }

        private void cbFilter_Leave(object sender, EventArgs e)
        {
            SetBackgroundMode(false, 0);
            setCurrentFilterToHistory(bringToTop: true);
        }

        private void setCurrentFilterToHistory(bool bringToTop)
        {
            if (invariantFilteringList) return;
            var text = cbFilter.Text;
            if (!string.IsNullOrEmpty(text) && filterValid())
            {
                if (cbFilter.Items.Contains(text))
                {
                    if (!bringToTop) return;
                    cbFilter.Items.Remove(text);
                    cbFilter.Text = text;
                }
                cbFilter.Items.Insert(1, text);
            }
        }

        private void btnLocationCommands_Click(object sender, EventArgs e)
        {
            clearAllHistoryOfLocationsToolStripMenuItem.Enabled = cbLocation.Items.Count > 0;
            deleteCurrentPathFromHistoryToolStripMenuItem.Enabled = zabLocation.Text != null && cbLocation.Items.Contains(zabLocation.Text);
            cmsLocationCommands.Show(Cursor.Position);
        }

        private void btnLocationCommands_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                btnLocationCommands_Click(null, null);
            }
        }

        private void deleteCurrentPathFromHistoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cbLocation.Items.Remove(zabLocation.Text);
            zabLocation.Text = "";
        }

        private void clearAllHistoryOfLocationsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (MessageBox.Show(Message.DoYouClearLocationHistory, Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK)
            {
                cbLocation.Items.Clear();
            }
        }

        private string cbLocation_DropDown_TextBeforeDropDown = null;
        private bool cbLocation_DropDowning = false;
        private void cbLocation_DropDown(object sender, EventArgs e)
        {
            cbLocation_DropDown_TextBeforeDropDown = zabLocation.Text;
            cbLocation_DropDowning = true;
        }

        private void cbLocation_DropDownClosed(object sender, EventArgs e)
        {
            cbLocation_DropDowning = false;
            var cb = (ComboBox)sender;

            // この時点で cb.Text を明示的に変更しないと、cb.Text の値の変更のタイミングがこれに続く if 文よりも後になってしまうばかりか、
            // これに続くイベントハンドラで行われる読み込みパスの決定よりも後にさえなってしまう。
            var si = cb.SelectedIndex;
            if (si < 0)
            {
                // → KeyDown 側で対処
                /*
                // ComboBox には設計ミスがあり、これをしないと空白になってしまう。
                var text = cb.Text;
                if (!string.IsNullOrEmpty(text) && !cb.Items.Contains(text))
                {
                    // ただしこれを行うとこの時点でテキストが追加されるのでファイルかフォルダが存在する

                    cb.Items.Add(text);
                    cb.SelectedIndex = cb.Items.Count - 1;
                }
                */
                return;
            }

            zabLocation.Text = cb.Items[si].ToString();

            if (zabLocation.Text != cbLocation_DropDown_TextBeforeDropDown)
            {
                MakePreview();
            }
            /*
            cb.Text = cb.Items[si].ToString();

            if (cb.Text != cbLocation_DropDown_TextBeforeDropDown)
            {
                MakePreview();
            }
            */
        }



        private void btnFilterCommands_Click(object sender, EventArgs e)
        {
            clearAllHistoryOfFiltersToolStripMenuItem.Enabled = !invariantFilteringList && cbFilter.Items.Count > 1;
            deleteCurrentFilterFromHistoryToolStripMenuItem.Enabled = !invariantFilteringList && !string.IsNullOrEmpty(cbFilter.Text) && cbFilter.Items.Contains(cbFilter.Text);
            cmsFilterCommands.Show(Cursor.Position);
        }

        private void btnFilterCommands_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                btnFilterCommands_Click(null, null);
            }
            else if (e.Button == MouseButtons.Middle)
            {
                // enabled でないと使えない
                //deleteCurrentFilterFromHistoryToolStripMenuItem.PerformClick();

                deleteCurrentFilterFromHistoryToolStripMenuItem_Click(null, null);
            }
        }

        private void deleteCurrentFilterFromHistoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (invariantFilteringList) return;
            if (!string.IsNullOrEmpty(cbFilter.Text))
            {
                cbFilter.Items.Remove(cbFilter.Text);
                cbFilter.Text = "";
            }
        }

        private void clearAllHistoryOfFiltersToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (invariantFilteringList) return;
            if (MessageBox.Show(Message.DoYouClearFilterHistory, Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK)
            {
                cbFilter.Items.Clear();
                cbFilter.Items.Add("");
            }
        }

        private bool CursolIsOnControll()
        {
            return CursorIsOnControllField;
            //return UnderCursorSet.Count > 0;
            /*
            foreach (var isUnderCorsor in IsUnderCursor.Values)
            {
                if (isUnderCorsor) return true;
            }
            return false;
            */
        }

        // 復元する場合 RunWorkerStarting 内のコメントアウトを外すこと
        /*
        private void InitCursorIsOnControllField()
        {
            var position = PointToClient(Cursor.Position);
            var rect = ClientRectangle;
            CursorIsOnControllField = rect.Contains(position);
        }
        */

        #region ポインタ位置処理

        bool CursorIsOnControllField = false;
        private void GeneralMouseLeave(object something)
        {
            /*
#if !AUTOBUILD
            if (something == null) throw new ArgumentNullException();
#endif
            
            CursorIsOnControllField = false;
            

            if (!RenameShownArchive_MakePreviewSleepRequest && (!ClientRectangle.Contains(PointToClient(MousePosition))))
            {
                if (!CursolIsOnControll())
                {
                    if (!(((MouseButtons & MouseButtons.Left) == MouseButtons.Left || cbFilter.Focused) && Form.ActiveForm == this) && AllowFullpower)
                        bmwMakePreview.ThreadCount = Math.Max(2, Environment.ProcessorCount - 1);
                }
            }
            else
            {
               // ComeFromControl = true;
            }
            */
        }
        private void GeneralMouseEnter(object something)
        {
#if !AUTOBUILD
            //if (something == null) throw new ArgumentNullException();
#endif

            //CursorIsOnControllField = true;

        }

        private void tvCatalog_MouseEnter(object sender, EventArgs e) { focusIfRightness(sender as Control); GeneralMouseEnter(tvCatalog); }
        private void tvCatalog_MouseLeave(object sender, EventArgs e) { tvCatalog_MouseMove_RatingChangePart(); GeneralMouseLeave(tvCatalog); }
        private void cbLocation_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(cbLocation); }
        private void cbLocation_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(cbLocation); }
        private void btnLocationCommands_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(btnLocationCommands); }
        private void btnLocationCommands_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(btnLocationCommands); }
        private void cbSortBy_MouseEnter(object sender, EventArgs e) { focusIfRightness(sender as Control); GeneralMouseEnter(cbSortBy); }
        private void cbSortBy_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(cbSortBy); }
        private void cbFilter_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(cbFilter);
            showToolTip_MouseEnter(sender as Control, Message.MiddleClickToClearPaste + "\n" + Message.LeftFlickToClear + "\n" + Message.RightFlickToPaste,
                avoidCursorIcon: false, avoidTarget: true); }
        private void cbFilter_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(cbFilter); showToolTip_MouseLeave(sender as Control); }
        private void btnFilterCommands_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(btnFilterCommands); }
        private void btnFilterCommands_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(btnFilterCommands); }
        private void menuStrip_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(menuStrip); }
        private void menuStrip_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(menuStrip); }
        private void CatalogForm_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(this); }
        private void CatalogForm_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(this); }
        private void dgvFileList_MouseEnter(object sender, EventArgs e) { focusIfRightness(sender as Control); GeneralMouseEnter(dgvFileList); }
        private void dgvFileList_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(dgvFileList); }
        private void splRight_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(splRight); }
        private void splRight_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(splRight); }
        private void zabLocation_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(zabLocation); }
        private void zabLocation_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(zabLocation); }
        private void btnGoToBack_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(btnGoToBack); }
        private void btnGoToBack_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(btnGoToBack); }
        private void btnGoToForward_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(btnGoToForward); }
        private void btnGoToForward_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(btnGoToForward); }

        private void menuStripLeft_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(sender); }
        private void menuStripLeft_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(sender); }
        private void addToolStripMenuItem_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(sender); }
        private void addToolStripMenuItem_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(sender); }
        private void dgvDirectoryList_MouseEnter(object sender, EventArgs e)
        {
            focusIfRightness(sender as Control); GeneralMouseEnter(sender);
            dgvDirectoryList.ShowCellToolTips = true; // ドラッグアウト時に false になるため
        }
        private void dgvDirectoryList_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(sender); }
        private void splLeft_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(sender); }
        private void splLeft_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(sender); }
        private void cmsDirectoryList_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(sender); }
        private void cmsDirectoryList_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(sender); }

        private void SelectedFileNameToolStripTextBox_MouseEnter(object sender, EventArgs e)
        {
            //SelectedFileNameToolStripTextBox_MouseEnter_UnselectedItemMaskPart();
            GeneralMouseEnter(selectedFileNameToolStripTextBox);
        }
        private void SelectedFileNameToolStripTextBox_MouseLeave(object sender, EventArgs e)
        {
            //SelectedFileNameToolStripTextBox_MouseLeave_UnselectedItemMaskPart();
            GeneralMouseLeave(selectedFileNameToolStripTextBox);
        }

        private void startToolStripMenuItem_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(startToolStripMenuItem); }
        private void startToolStripMenuItem_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(startToolStripMenuItem); }
        private void viewToolStripMenuItem_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(viewToolStripMenuItem); }
        private void viewToolStripMenuItem_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(viewToolStripMenuItem); }
        private void thumbnailSizeToolStripMenuItem_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(thumbnailSizeToolStripMenuItem); }
        private void thumbnailSizeToolStripMenuItem_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(thumbnailSizeToolStripMenuItem); }
        private void optionToolStripMenuItem1_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(optionToolStripMenuItem); }
        private void optionToolStripMenuItem1_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(optionToolStripMenuItem); }

        private void cmsRightClick_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(cmsRightClick); }
        private void cmsRightClick_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(cmsRightClick); }


        private void cmsRightClickOnBackground_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(cmsRightClickOnBackground); }

        private void cmsRightClickOnBackground_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(cmsRightClickOnBackground); }

        private void ratingFilterToolStripMenuItem_MouseEnter(object sender, EventArgs e) { GeneralMouseEnter(ratingFilterToolStripMenuItem); }
        private void ratingFilterToolStripMenuItem_MouseLeave(object sender, EventArgs e) { GeneralMouseLeave(ratingFilterToolStripMenuItem); }

        #endregion

        private readonly HashSet<Control> showToolTipWaitingControls = new HashSet<Control>();
        private async void showToolTip_MouseEnter(Control target, string message, bool avoidCursorIcon, bool avoidTarget)
        {
            if (target != null && !string.IsNullOrEmpty(message) && !showToolTipWaitingControls.Contains(target))
            {
                showToolTipWaitingControls.Add(target);
                await Task.Delay(toolTip.InitialDelay);
                if (showToolTipWaitingControls.Contains(target))
                {
                    var rectangle = target.ClientRectangle;
                    var point = target.PointToClient(Cursor.Position);
                    // if (target.Cursor is Cursor cursor) // HotSopt が正しく取得できない
                    if (avoidCursorIcon && Cursor.Current is Cursor cursor)
                    {
                        point.Y += cursor.Size.Height - cursor.HotSpot.Y;
                    }
                    if (avoidTarget && rectangle.Right > point.X && rectangle.Bottom > point.Y) point.Y = rectangle.Bottom;
                    toolTip.Show(message, target, point);
                    await Task.Delay(toolTip.AutoPopDelay);
                    if (showToolTipWaitingControls.Contains(target))
                    {
                        toolTip.Hide(target);
                        showToolTipWaitingControls.Remove(target);
                    }
                }
            }
        }
        private void showToolTip_MouseLeave(Control target)
        {
            if (target != null)
            {
                toolTip.Hide(target);
                showToolTipWaitingControls.Remove(target);
            }
        }

        /*
        private const int WM_NCMOUSELEAVE = 0x02A2;

        protected override void WndProc(ref System.Windows.Forms.Message m)
        {
            base.WndProc(ref m);

            switch (m.Msg)
            {
                case WM_NCMOUSELEAVE:
                    if (!this.Bounds.Contains(Cursor.Position))
                    {
                        unselectedItemMaskOn();
                    }
                    else
                    {
                        unselectedItemMaskOff();
                    }
                    break;
            }
        }
        */


        private void globalMouseEnter(Point screenLocation)
        {
            unselectedItemMaskOff();
            setWaitingProcessPriority(ProcessPriorityClass.Normal);
            CursorIsOnControllField = true;
        }

        private void globalMouseLeave(Point screenLocation)
        {
            bool? thisIsActiveNullable = null;
            if (SelectionHilightMode == SelectionHighlightMode.WhenMouseLeaves && !dragOuting && (bool)(thisIsActiveNullable = ActiveForm == this))
            {
                unselectedItemMaskOn();
            }

            setWaitingProcessPriority(ProcessPriorityClass.BelowNormal);

            if (!RenameShownArchive_MakePreviewSleepRequest && (!ClientRectangle.Contains(PointToClient(MousePosition))))
            {
                if (!(((MouseButtons & MouseButtons.Left) == MouseButtons.Left || cbFilter.Focused) && (bool)(
                     thisIsActiveNullable = thisIsActiveNullable ?? ActiveForm == this
                    )) && AllowFullpower)
                {
                    bmwMakePreview.ThreadCount = Math.Max(2, Environment.ProcessorCount - 1);
                    Program.SetPriority(ProcessPriorityClass.BelowNormal);
                }
            }
            
            if (!(bool)(thisIsActiveNullable = thisIsActiveNullable ?? ActiveForm == this))
            {
                if (OpenWaitingProcess_Processing)
                {
                    OpenWaitingProcess_StopPrepareLookAheadProcess = true;
                }
                else
                {
                    StopLookAheadProcess();
                    SetLookAheadArchive_PrevDataIndex = -1;
                }
            }

            CursorIsOnControllField = false;
        }

        //private static readonly Color unselectedItemMaskColor = Color.FromArgb(224, 255, 255, 255);
        private void unselectedItemMaskOn()
        {
            //if(tvCatalog.SelectedIndex >= 0)
            {
                tvCatalog.UnselectedItemAlphaChannel = 255 - MaskAlpha;
            }
        }

        private void unselectedItemMaskOff()
        {
            tvCatalog.UnselectedItemAlphaChannel = 255;
        }

        private bool NotInEditiongAnything()
        {
            return dgvFileList.ReadOnly && dgvDirectoryList.ReadOnly && !cbLocation.Focused && !cbFilter.Focused && !selectedFileNameToolStripTextBox.Focused;
        }

        private void focusIfRightness(Control control)
        {
            //if (NotInEditiongAnything()) control.Focus();
        }

        private void CatalogForm_Deactivate(object sender, EventArgs e)
        {
            SetBackgroundMode(false, 0);
            unselectedItemMaskOff();

            if (OpenWaitingProcess_Processing)
            {
                OpenWaitingProcess_StopPrepareLookAheadProcess = true;
            }
            else
            {
                StopLookAheadProcess();
                SetLookAheadArchive_PrevDataIndex = -1;
            }
        }

        private void setWaitingProcessPriority(ProcessPriorityClass priority)
        {
            if (waitingProcess == null || waitingProcess.HasExited) return;
            try
            {
                waitingProcess.PriorityClass = priority;
            }
            catch (InvalidEnumArgumentException)
            {
                throw;
            }
            catch
            {
            }
        }

        private void cbLocation_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                if (cbLocation_DropDowning)
                {
                    // ComboBox は Enter キーで閉じると Text が Items に含まれない場合に空白に置き換える
                    // 以下の記述で Text をそのままにできる
                    e.SuppressKeyPress = true;
                    var text = cbLocation.Text;
                    cbLocation.DroppedDown = false;
                    cbLocation.Text = text;
                }
                //else // エンターでドロップダウンを閉じた場合もそのまま移動
                {
                    e.SuppressKeyPress = true;
                    MakePreview();
                }
            }
            else if (e.KeyCode == Keys.Escape && !cbLocation_DropDowning)
            {
                e.SuppressKeyPress = true;
                FocusLatestControledControl();
            }
        }

        private void cbFilter_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Escape && !cbFilter.DroppedDown)
            {
                e.SuppressKeyPress = true;
                FocusLatestControledControl();
            }
        }

        private void cbLocation_MouseDown(object sender, MouseEventArgs e)
        {
            var cb = (ComboBox)sender;
            if (!cbLocation_Focused_for_MouseDown && e.Button == MouseButtons.Left && !cb.DroppedDown)
            {
                cbLocation.DroppedDown = true;
            }
            cbLocation_Focused_for_MouseDown = true;
        }

        bool cbLocation_Focused_for_MouseDown = false;
        private void cbLocation_Leave(object sender, EventArgs e)
        {
            cbLocation_Focused_for_MouseDown = false;
        }

        private void tvCatalog_KeyDown(object sender, KeyEventArgs e)
        {
            var mk = ModifierKeys;
            if (e.KeyCode == Keys.Enter)
            {
                // これを有効にする場合 Alt キーでメニューにフォーカスが移る動作を無効にする必要がある
                /*
                if ((mk & Keys.Alt) == Keys.Alt)
                {
                    OpenSelectedProperties();
                }
                else
                */
                {
                    OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.EnterKey, null);
                }
                LatestControledControl = sender as Control;
            }
            /*
            else if (e.KeyCode == Keys.Apps)
            {
                cmsRightClickPrepareAndShowForKeyOnTvCatalog(onlyTag: false);
                LatestControledControl = sender as Control;
            }
            */
            else if (e.KeyCode == Keys.Left || e.KeyCode == Keys.Right || e.KeyCode == Keys.Up || e.KeyCode == Keys.Down)
            {
                LatestControledControl = sender as Control;
            }
            else if (commonKeyAction(e, mk))
            {
                return;
            }
        }

        private bool commonKeyAction(KeyEventArgs e, Keys modifierKeys)
        {
            if (e.KeyCode == Keys.Delete)
            {
                deleteKeyAction(modifierKeys); return true;
            }
            else if (e.Control && e.KeyCode == Keys.X)
            {
                CutKeyAction(modifierKeys); return true;
            }
            else if (e.Control && e.KeyCode == Keys.C)
            {
                CopyKeyAction(modifierKeys); return true;
            }
            else if (e.Control && e.KeyCode == Keys.V)
            {
                PasteKeyAction(modifierKeys); return true;
            }
            else if (IsApps(e.KeyCode, modifierKeys))
            {
                AppsKeyAction(modifierKeys); return true;
            }
            else if (applicationShortcutKeyAction(e, modifierKeys) != applicationShortcutKeyAction_result.SomeException)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        private bool IsApps(Keys keys, Keys modifierKeys)
        {
            return keys == Keys.Apps || keys == Keys.F10 && (modifierKeys & Keys.Shift) == Keys.Shift;
        }

        enum applicationShortcutKeyAction_result { Application, Bookmark, SomeException, NotFound }
        private applicationShortcutKeyAction_result applicationShortcutKeyAction(KeyEventArgs e, Keys modifierKeys)
        {
            var startApplicationWithAccessKeyLocal = startApplicationWithAccessKey;
            var bookmarkWithAccessKeyLocal = startApplicationWithAccessKeyLocal;
            if (!startApplicationWithAccessKey && !bookmarkWithAccessKeyLocal) return applicationShortcutKeyAction_result.NotFound;
            ApplicationProvider[] aa = null;
            if (startApplicationWithAccessKeyLocal)
            {
                var onlyApp = !bookmarkWithAccessKeyLocal;
                aa = ApplicationArray;
                if (aa == null)
                {
                    if (onlyApp) return applicationShortcutKeyAction_result.NotFound;
                    startApplicationWithAccessKeyLocal = false;
                }
                else if (!aa.Any())
                {
                    if (onlyApp) return applicationShortcutKeyAction_result.NotFound;
                    startApplicationWithAccessKeyLocal = false;
                }
                if (!startApplicationWithAccessKeyLocal)
                {
                    var lcc = LatestControledControl;
                    if (lcc != dgvFileList && lcc != tvCatalog)
                    {
                        if (onlyApp) return applicationShortcutKeyAction_result.NotFound;
                        startApplicationWithAccessKeyLocal = false;
                    }
                }
            }
            
            if (modifierKeys != Keys.None) return applicationShortcutKeyAction_result.SomeException;
            var kc = e.KeyCode;
            if (kc < Keys.D0 || kc > Keys.Z) return applicationShortcutKeyAction_result.SomeException; // D0, D1, ..., D9, A, B, ..., Z の順に並んでいる

            try
            {
                // フォーカスによってはアプリケーションは無視されることがあると考えるとこちら優先が妥当
                if (bookmarkWithAccessKeyLocal)
                {
                    var rows = (from DataGridViewRow row in dgvDirectoryList.Rows select row).ToArray();
                    foreach (var row in rows)
                    {
                        if (row.Cells[tbcDirectoryName.Index].Value is ColoredBookmark bookmark && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None) // セパレーターなら無視される
                        {
                            var sb = bookmark.SimpleBookmark;

                            if (bookmark.SimpleBookmark.Alias is string alias && alias != "" && kc == ExternalApplicationProvider.GetAccessKey(alias))
                            {
                                /*if (dgvDirectoryList.Visible)*/ foreach (var row2 in rows) row2.Selected = row2 == row;
                                moveToBookmark(row.Index, ApplicationProviderUser.EnterKey); // AccessKey も EnterKey と同様に振る舞う
                                return applicationShortcutKeyAction_result.Bookmark;
                            }
                        }
                    }
                }

                if (startApplicationWithAccessKeyLocal)
                {
                    string[] selectedPaths;
                    bool[] isDirs;
                    getSelectedPathArray(-1, out selectedPaths, out isDirs);
                    if (selectedPaths == null || selectedPaths.Length <= 0) return applicationShortcutKeyAction_result.SomeException;
                    var zpa = ZipPathArray;
                    if (zpa == null || zpa.Length != tvCatalog.Count) return applicationShortcutKeyAction_result.SomeException;
                    var zna = ZipNameArray;
                    if (zna == null || zna.Length != zpa.Length) return applicationShortcutKeyAction_result.SomeException;
                    var infos = new FileInfoForApplicationProvider[selectedPaths.Length];
                    for (var i = 0; i < selectedPaths.Length; i++)
                    {
                        infos[i] = new FileInfoForApplicationProvider { Path = selectedPaths[i], IsDir = isDirs[i] };
                    }
                    RecentFfmpegExists = MovieThumbnailLoader.ffmpegExists();
                    foreach (var app in aa)
                    {
                        if (kc == app.GetAccessKey())
                        {
                            if (app.Supports(infos))
                            {
                                app.Exec(ApplicationProviderUser.AccessKey, selectedPaths);
                                return applicationShortcutKeyAction_result.Application;
                            }
                        }
                    }
                    //throw new Exception(Message.ApplicationIsNotSpecified);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
            }

            // プログラムが見つかったかどうか、エラーが出たかどうかで動作は変更しない
            return applicationShortcutKeyAction_result.NotFound;
        }

        private void cmsRightClickPrepareAndShowForKeyOnTvCatalog(bool onlyTag, Keys modifierKeys)
        {
            var mk = modifierKeys;
            //var mk = ModifierKeys;
            if (tvCatalog.SelectedIndicesCount > 0)
            {
                int showIndex = tvCatalog.FirstDisplayedSelectedShowIndex;
                if (showIndex < 0) return;
                var p = tvCatalog.GetSemiCenterClientcoordinateOf(showIndex);
                p = tvCatalog.PointToScreen(p);
                if (onlyTag)
                {
                    cmsRightClickPrepareAndShow_(p, true);
                }
                else
                {
                    rightClickContextMenuPrepareAndShow(p, mk);
                    /*
                    if (RightClickContextMenu == CatalogFormConfigConetxtMenu.ZipPla)
                    {
                        cmsRightClickPrepareAndShow_(p, false);
                    }
                    else if (RightClickContextMenu == CatalogFormConfigConetxtMenu.Explorer)
                    {
                        explorerContextMenuPrepareAndShow(p);
                    }
                    else if(ControlRightClickContextMenu == CatalogFormConfigConetxtMenu.ZipPla)
                    {
                        cmsRightClickPrepareAndShow_(p, false);
                    }
                    else if (ControlRightClickContextMenu == CatalogFormConfigConetxtMenu.Explorer)
                    {
                        explorerContextMenuPrepareAndShow(p);
                    }
                    */
                }
            }
            else if (!onlyTag && tvCatalog.Visible && (RightClickContextMenu != CatalogFormConetxtMenu.Tag))
            {
                var p = tvCatalog.PointToScreen(tvCatalog.Location);

                //cmsRightClickPrepareAndShow(p);

                rightClickContextMenuPrepareAndShow(p, mk);
                //cmsRightClickPrepareAndShow_(p, false);
            }
        }

        private void ThumbnailSize_Click(ToolStripMenuItem toolStripMenuItem)
        {
            if (!toolStripMenuItem.Checked)
            {
                ChangeThumbnailSize(toolStripMenuItem);
                UpdatePreview();
            }
        }

        int ChangeThumbnailSize_Width = 210;
        int ChangeThumbnailSize_Height = 297;
        double ChangeThumbnailSize_Padding = 2;
        private static int ChangeThumbnailSize_MenuItemOffset = 2;
        static readonly double ChangeThumbnailSize_NeutralLength = Math.Sqrt(210 * 297);
        private void ChangeThumbnailSize(ToolStripMenuItem toolStripMenuItem)
        {
            var items = thumbnailSizeToolStripMenuItem.DropDownItems;

            //var isPlaClip = clipModeByControl == ClipMode.PlaClip;

            var inSizeBlock = false;
            foreach (object itemObject in items)
            {
                if (!inSizeBlock)
                {
                    inSizeBlock = itemObject == thumbnailSizeTopSeparator;
                    continue;
                }
                if (itemObject == thumbnailSizeBottomSeparator) break;
                if (itemObject.GetType() != typeof(ToolStripMenuItem)) continue;
                var item = (ToolStripMenuItem)itemObject;
                if (toolStripMenuItem != null)
                {
                    item.Checked = item == toolStripMenuItem;
                }
                else if (item.Checked)
                {
                    toolStripMenuItem = item;
                }
            }

        }

        private bool ThumbnailSettingToCatalog_CoverSettingModeAtOnce = false;
        private void ThumbnailSettingToCatalog()
        {
            int size;
            if (tinyToolStripMenuItem.Checked) size = -2;
            else if (smallToolStripMenuItem.Checked) size = -1;
            else if (largeToolStripMenuItem.Checked) size = 1;
            else if (hugeToolStripMenuItem.Checked) size = 2;
            else size = 0;


            double localAspectRatio = aspectRatio;
            if (ThumbnailSettingToCatalog_CoverSettingModeAtOnce)
            {
                ThumbnailSettingToCatalog_CoverSettingModeAtOnce = false;
            }
            else if (InMovie)
            {
                var mia = MovieInfoArray;
                if (mia != null && mia.Length > 0)
                {
                    var info = mia[0];
                    var movieSize = info.SizeByPixel;
                    var sar = info.SAR;
                    if (sar != 0) movieSize = sar * (Fraction)movieSize;
                    if (movieSize.Width > 0 && movieSize.Height > 0)
                    {
                        localAspectRatio = Math.Max(0.2, Math.Min(5.0, (double)movieSize.Width / movieSize.Height));
                    }
                }
            }

            var padding = size * 2; if (padding == 2) padding = 3; else if (padding < 2) padding = 2;
            var ratioSqrt = Math.Sqrt(localAspectRatio);
            var scale = Math.Pow(2, size / 2.0);
            ChangeThumbnailSize_Width = Program.DpiScalingX(ChangeThumbnailSize_NeutralLength * scale * ratioSqrt);
            ChangeThumbnailSize_Height = Program.DpiScalingX(ChangeThumbnailSize_NeutralLength * scale / ratioSqrt);
            ChangeThumbnailSize_Padding = padding;
        }

        private int GetThumbnailCountInTvCatalogOrFileList(MovieInfo info)
        {
            if (thumbnailListToolStripMenuItem.Checked)
            {
                int size;
                if (tinyToolStripMenuItem.Checked) size = -2;
                else if (smallToolStripMenuItem.Checked) size = -1;
                else if (largeToolStripMenuItem.Checked) size = 1;
                else if (hugeToolStripMenuItem.Checked) size = 2;
                else size = 0;

                double localAspectRatio = aspectRatio;
                if (!ThumbnailSettingToCatalog_CoverSettingModeAtOnce && info != null)
                {
                    var movieSize = info.SizeByPixel;
                    var sar = info.SAR;
                    if (sar != 0) movieSize = sar * (Fraction)movieSize;
                    if (movieSize.Width > 0 && movieSize.Height > 0)
                    {
                        localAspectRatio = Math.Max(0.2, Math.Min(5.0, (double)movieSize.Width / movieSize.Height));
                    }
                }

                var padding = size * 2; if (padding == 2) padding = 3; else if (padding < 2) padding = 2;
                var ratioSqrt = Math.Sqrt(localAspectRatio);
                var scale = Math.Pow(2, size / 2.0);
                var w = Program.DpiScalingX(ChangeThumbnailSize_NeutralLength * scale * ratioSqrt);
                var h = Program.DpiScalingX(ChangeThumbnailSize_NeutralLength * scale / ratioSqrt);
                padding = Program.DpiScaling(padding * currentMinimumFrameThickness);
                var ChangeThumbnailSize_Padding = padding;

                // スクロールバーは無視するべきなので tvCatalog.ClientSize は不適切
                int textLength, textLines;
                if (numberOfLinesOfName != NumberOfLinesOfName.Full)
                {
                    GetNameLengthAndNameLines(out textLength, out textLines);
                }
                else
                {
                    textLength = 0;
                    textLines = ThumbViewer.GetTextLines(default(TimeSpan).ToString(), new Size(w, h), padding, tvCatalog.bottomPadding, currentAligning, tvCatalog.Size);
                }
                return ThumbViewer.GetThumbnailCountInScreen(new Size(w, h), padding, tvCatalog.bottomPadding, tvCatalog.ShowText, tvCatalog.GetCharHeight(), textLength, textLines, currentAligning, tvCatalog.Size);
            }
            else if (fileListToolStripMenuItem.Checked)
            {
                return (dgvFileList.ClientRectangle.Bottom - dgvFileList.ColumnHeadersHeight) / GetCellDisplayHeight(dgvFileList);
            }
            else
            {
                return 0;
            }
        }
        /// <summary>
        /// DPI も考慮してセルの標準の高さを取得
        /// </summary>
        private static int GetCellDisplayHeight(DataGridView dataGridView)
        {
            var i = dataGridView.FirstDisplayedScrollingRowIndex;
            int result;
            if (i >= 0)
            {
                result = dataGridView.GetRowDisplayRectangle(i, false).Height;
            }
            else
            {
                result = dataGridView.ColumnHeadersHeight + 1;
                // 2016/12 Windows10 100%, 125%, 150%, 175%, 200%, 225% で完全一致を確認
            }
            return result > 0 ? result : dataGridView.RowTemplate.Height;
        }

        private void tinyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ThumbnailSize_Click((ToolStripMenuItem)sender);
        }

        private void smallToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ThumbnailSize_Click((ToolStripMenuItem)sender);
        }

        private void normalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ThumbnailSize_Click((ToolStripMenuItem)sender);
        }

        private void largeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ThumbnailSize_Click((ToolStripMenuItem)sender);
        }

        private void hugeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ThumbnailSize_Click((ToolStripMenuItem)sender);
        }

        private void showIconToolStripMenuItem_Click(object sender, EventArgs e)
        {
            showIcon = showIconToolStripMenuItem.Checked = !showIcon;
            tvCatalog.Invalidate();
        }

        private void showRatingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            showRating = showRatingToolStripMenuItem.Checked = !showRating;
            setTagfilterLocationIfRatingFilterVisibleChanged();
            //UpdatePreview();
            tvCatalog.Invalidate();
        }

        private void showTagsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            showTags = showTagsToolStripMenuItem.Checked = !showTags;
            tvCatalog.Invalidate();
        }

        private void showFilenameToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setShowFileName(!showFilenameToolStripMenuItem.Checked);
        }

        private void setShowFileName(bool show)
        {
            showFilenameToolStripMenuItem.Checked = show;
            tvCatalog.ShowText = show;
            theNumberOfLinesOfNameToolStripMenuItem.Enabled = show;
        }

        private IpcLookAheadInfo lookAheadInfo = null;
        private Process waitingProcess = null;
        private IpcServerChannel currentIpcChanne = null;
        private IpcReportFromViewerToCatalog reportFromViewerToCatalog = null;
        private string currentIpcGUID = null; // チャンネル自身の名前及び ViewerForm 用プロセスからの連絡用オブジェクト名

        public void PrepareLookAheadProcess()
        {
            if (!AllowReadAheadProcess) return;
            PrepareLookAheadProcess(/*Configuration.GetLastWriteTime(),*/ forcePrepare: false);
        }
        void PrepareLookAheadProcess(/*DateTime iniModified,*/ bool forcePrepare = false)
        {
            if (!forcePrepare && !AllowReadAheadProcess) return;

            // チャンネル登録及び ViewerForm 用プロセスからの連絡用オブジェクト登録
            if (currentIpcChanne == null)
            {
                currentIpcGUID = Guid.NewGuid().ToString();
                var currentIpcChannePortName = IpcLookAheadInfo.ChannelName + "_" + currentIpcGUID;
                currentIpcChanne = new IpcServerChannel(currentIpcChannePortName);
                ChannelServices.RegisterChannel(currentIpcChanne, true);

                reportFromViewerToCatalog = new IpcReportFromViewerToCatalog();
                RemotingServices.Marshal(reportFromViewerToCatalog, currentIpcGUID, typeof(IpcReportFromViewerToCatalog));

                tmWatchIpc.Start();
            }

            // リモートオブジェクトを生成して公開
            if (lookAheadInfo != null)
            {
                RemotingServices.Disconnect(lookAheadInfo);
                lookAheadInfo = null;
            }
            lookAheadInfo = new IpcLookAheadInfo();

            var guid = Guid.NewGuid().ToString();
            RemotingServices.Marshal(lookAheadInfo, guid, typeof(IpcLookAheadInfo));

            //CheckAndRecoverWaitingProcess_INIModified = iniModified;

            var psi = new ProcessStartInfo();
            psi.FileName = Application.ExecutablePath;

            psi.WindowStyle = ProcessWindowStyle.Hidden;
            /*
            var command = BuiltInViewerInitialFullscreenMode == InitialFullscreenMode.ForceWindow ? "-LookAheadModeW" :
                BuiltInViewerInitialFullscreenMode == InitialFullscreenMode.ForceFullscreen ? "-LookAheadModeF" :
                "-LookAheadMode";
            if (AlwaysHideUI) command += "H";
            */
            const string command = "-LookAheadMode";
            psi.Arguments = command + " " + currentIpcGUID + " " + guid;
            waitingProcess = Process.Start(psi);
        }

        //private DateTime CheckAndRecoverWaitingProcess_INIModified;
        bool CheckAndRecoverWaitingProcess(bool forceDisposing = false, bool forcePrepare = false)
        {
            // 待ちプロセスがユーザーなどに消される可能性を考慮
            var hasExited = waitingProcess == null || waitingProcess.HasExited;
            //var iniLastWriteTime = Configuration.GetLastWriteTime();

            if (
                (hasExited/* || iniLastWriteTime > CheckAndRecoverWaitingProcess_INIModified*/)
                || forceDisposing || (forcePrepare && lookAheadInfo == null)
                )
            {
                if (!hasExited)
                {
                    try
                    {
                        waitingProcess.Kill();
                    }
                    catch (InvalidOperationException) { }
                }

                PrepareLookAheadProcess(/*iniLastWriteTime,*/ forcePrepare);
                return true;
            }
            return false;
        }

        private SortModeDetails GetCurrentSortModeDetails(int page)
        {
            /*
            if (page >= 0)
            {
                return null;
            }
            else
            */
            {
                return new SortModeDetails { SortMode = sortSyncMode == SortSyncMode.Directory ? sortMode : SortMode.NameInAsc,
                    PreSortMode = prevSortMode, RandomSeed = GetSortArray_RandomSeed };
            }
        }

        private string SetLookAheadArchive_PrevPath = null;
        private int SetLookAheadArchive_PrevPage = -1;
        private ArchivesInArchiveMode? SetLookAheadArchive_ArchivesInArchive = null;
        private ReadOnMemoryMode? SetLookAheadArchive_ReadOnMemory = null;
        private BindingMode? SetLookAheadArchive_PrevDefaultBinding = null;
        private SortModeDetails SetLookAheadArchive_PrevSortDetails = null;
        private IpcLookAheadInfo SetLookAheadArchive_PrevIpcLookAheadInfo = null;
        private Color? SetLookAheadArchive_PrevBackColor = null;
        private CoverBindingMode? SetLookAheadArchive_PrevCoverBindingMode = null;
        private bool? SetLookAheadArchive_PrevOpenInPrevImageFilter = null;
        private InitialFullscreenMode? SetLookAheadArchive_PrevOpenInPrevInitialFullscreenMode = null;
        private bool? SetLookAheadArchive_PrevOpenInPrevAlwaysHideUI = null;
        private bool? SetLookAheadArchive_SendFilterString = null;
        private string SetLookAheadArchive_BlackPrefix = null;
        void SetLookAheadArchive(string path, int page)
        {
            if (!AllowReadAheadProcess) return;
            if (path == null) return;
            if (!InDirectoryVirtualDirectoryOrSmartDirectory && !InArchive) return;
            if (IsOpendByExternalApplication(path)) return;
            //if (GPSizeThumbnail.TrySet_Creating.Contains(path)) return;
            CheckAndRecoverWaitingProcess();

            if (SetLookAheadArchive_BlackPrefix != null && path.StartsWith(SetLookAheadArchive_BlackPrefix)) return;

            if (lookAheadInfo?.Accept != true)
            {
                SetLookAheadArchive_PrevDataIndex = -1;
                return;
            }

            var currentSortModeDetails = null as SortModeDetails;

            if (SetLookAheadArchive_PrevPath != path || SetLookAheadArchive_PrevPage != page ||
                SetLookAheadArchive_ArchivesInArchive != ArchivesInArchiveMode ||
                SetLookAheadArchive_ReadOnMemory != ReadOnMemoryMode ||
                SetLookAheadArchive_PrevDefaultBinding != currentBindingMode ||
                SetLookAheadArchive_PrevBackColor != BackColorOfBuiltInViewer ||
                SetLookAheadArchive_PrevCoverBindingMode != CoverBindingMode ||
                SetLookAheadArchive_PrevOpenInPrevImageFilter != OpenInPreviousImageFilterSetting ||
                SetLookAheadArchive_SendFilterString != SendFilterStringToBuiltInViewer ||
                !(currentSortModeDetails = GetCurrentSortModeDetails(page)).ProbablyEquals(SetLookAheadArchive_PrevSortDetails) ||
                SetLookAheadArchive_PrevOpenInPrevInitialFullscreenMode != BuiltInViewerInitialFullscreenMode ||
                SetLookAheadArchive_PrevOpenInPrevAlwaysHideUI != AlwaysHideUI ||
                SetLookAheadArchive_PrevIpcLookAheadInfo != lookAheadInfo)
            {
                lookAheadInfo.Path = path;
                lookAheadInfo.Page = page;
                lookAheadInfo.ArchivesInArchive = ArchivesInArchiveMode;
                lookAheadInfo.ReadOnMemoryMode = ReadOnMemoryMode;
                lookAheadInfo.DefaultBinding = currentBindingMode;
                lookAheadInfo.CoverBinding = CoverBindingMode;
                lookAheadInfo.IgnoreSavedFilerSetting = !OpenInPreviousImageFilterSetting;
                lookAheadInfo.BackColor = BackColorOfBuiltInViewer;
                lookAheadInfo.SortModeDetails = currentSortModeDetails ?? (currentSortModeDetails = GetCurrentSortModeDetails(page));
                lookAheadInfo.InitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
                lookAheadInfo.AlwaysHideUI = AlwaysHideUI;
                setSendFilterToLookAheadInfo();
                lookAheadInfo.Accept = false;

                SetLookAheadArchive_PrevPath = path;
                SetLookAheadArchive_PrevPage = page;
                SetLookAheadArchive_ArchivesInArchive = ArchivesInArchiveMode;
                SetLookAheadArchive_ReadOnMemory = ReadOnMemoryMode;
                SetLookAheadArchive_PrevDefaultBinding = currentBindingMode;
                SetLookAheadArchive_PrevCoverBindingMode = CoverBindingMode;
                SetLookAheadArchive_PrevOpenInPrevImageFilter = OpenInPreviousImageFilterSetting;
                SetLookAheadArchive_SendFilterString = SendFilterStringToBuiltInViewer;
                SetLookAheadArchive_PrevBackColor = BackColorOfBuiltInViewer;
                SetLookAheadArchive_PrevSortDetails = currentSortModeDetails;
                SetLookAheadArchive_PrevOpenInPrevInitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
                SetLookAheadArchive_PrevIpcLookAheadInfo = lookAheadInfo;
                OpenWaitingProcess_AfterCalled = false;
            }
        }

        private void setSendFilterToLookAheadInfo()
        {
            if (SendFilterStringToBuiltInViewer)
            {
                var filterString = cbFilter.Text;
                if (string.IsNullOrEmpty(filterString))
                {
                    lookAheadInfo.FilterString = null;
                    lookAheadInfo.FilterStringWithoutAlias = null;
                }
                else
                {
                    lookAheadInfo.FilterString = filterString;
                    string filterStringWithoutAlias;
                    if (aliasesToFilteringStrings != null && aliasesToFilteringStrings.TryGetValue(filterString, out filterStringWithoutAlias))
                    {
                        lookAheadInfo.FilterStringWithoutAlias = filterStringWithoutAlias;
                    }
                    else
                    {
                        lookAheadInfo.FilterStringWithoutAlias = filterString;
                    }
                }
            }
            else
            {
                lookAheadInfo.FilterString = null;
                lookAheadInfo.FilterStringWithoutAlias = null;
            }
        }

        [DllImport("user32.dll")]
        private static extern bool AllowSetForegroundWindow(int dwProcessId);

        //private static readonly TimeSpan DoubleClickTimeSpan = TimeSpan.FromMilliseconds(SystemInformation.DoubleClickTime);
        int OpenWaitingProcess_LastOpenningTime;
        string OpenWaitingProcess_LastOpenningPath;
        bool OpenWaitingProcess_AfterCalled = false;
        bool OpenWaitingProcess_Opening = false;
        bool OpenWaitingProcess_Processing = false;
        bool OpenWaitingProcess_StopPrepareLookAheadProcess = false;
        async void OpenWaitingProcess(string path, int page, bool coverSettingMode)
        {
            var now = Environment.TickCount;
            if (OpenWaitingProcess_LastOpenningPath == path && InDoubleClickTime(now, OpenWaitingProcess_LastOpenningTime)) return;
            OpenWaitingProcess_LastOpenningTime = now;
            OpenWaitingProcess_LastOpenningPath = path;
            if (OpenWaitingProcess_Processing) return;
            OpenWaitingProcess_Processing = true;
            try
            {
                var existingProcess = !CheckAndRecoverWaitingProcess(forcePrepare: true);
                Cursor.Current = Cursors.WaitCursor;
                if (existingProcess && !lookAheadInfo.Accept)
                {
                    // 応答がなければすぐに置き換える
                    // 起動直後の読み込み処理が無駄になる
                    //PrepareLookAheadProcess();
                    //existingProcess = false;


                    // プロセスが停止しない限り待つ
                    Cursor.Current = Cursors.WaitCursor;
                    while (true)
                    {
                        var wp = waitingProcess;
                        var exit = await Task.Run(() =>
                        {
                            try
                            {
                                return wp.WaitForExit(50);
                            }
                            catch
                            {
                                return true; // エラーは終了したとみなす
                            }
                        });
                        if (exit || lookAheadInfo == null) // 非同期メソッドなので途中で lookAheadInfo が書き換わる可能性がある
                        {
                            PrepareLookAheadProcess();
                            existingProcess = false;
                            break;
                        }
                        else if (lookAheadInfo.Accept)
                        {
                            break;
                        }
                    }
                }
                if (existingProcess) setWaitingProcessPriority(ProcessPriorityClass.Normal);
                lookAheadInfo.Path = path;
                lookAheadInfo.Page = page;
                lookAheadInfo.ArchivesInArchive = ArchivesInArchiveMode;
                lookAheadInfo.ReadOnMemoryMode = ReadOnMemoryMode;
                lookAheadInfo.DefaultBinding = currentBindingMode;
                lookAheadInfo.CoverBinding = CoverBindingMode;
                lookAheadInfo.IgnoreSavedFilerSetting = !OpenInPreviousImageFilterSetting;
                lookAheadInfo.BackColor = BackColorOfBuiltInViewer;
                lookAheadInfo.InitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
                lookAheadInfo.AlwaysHideUI = AlwaysHideUI;
                var sortModeDetails = GetCurrentSortModeDetails(page);
                lookAheadInfo.SortModeDetails = sortModeDetails;
                setSendFilterToLookAheadInfo();
                lookAheadInfo.Message = coverSettingMode ? IpcLookAheadInfo.MessageEnum.CoverSetting : IpcLookAheadInfo.MessageEnum.Show;
                if (waitingProcess != null) AllowSetForegroundWindow(waitingProcess.Id);
                lookAheadInfo.Accept = false;
                var existingProcessAndFirstRequest = existingProcess || SetLookAheadArchive_PrevPath != path;
                var waitTime = 0;
                do
                {
                    OpenWaitingProcess_Opening = true;
                    //await Task.Run(() => Thread.Sleep(10));
                    await Task.Delay(10);
                    waitTime += 10;

                    // 初の呼び出しでない場合、ViewerForm.OpenFile 中は応答できないが
                    // それをもってプロセスを停止するべきではない
                    // 初の呼び出しで応答がないということは別のファイルを開こうとしているので
                    // 直ちにプロセスを停止する
                    /*if (AllowReadAheadProcess && existingProcessAndFirstRequest && waitTime == 100 && !lookAheadInfo.Accept)
                    // ビューアモードの通信チェック間隔よりも十分に長く
                    {
                        CheckAndRecoverWaitingProcess(forceDisposing: true);
                        lookAheadInfo.Path = path;
                        lookAheadInfo.Page = page;
                        lookAheadInfo.ArchivesInArchive = ArchivesInArchiveMode;
                        lookAheadInfo.ReadOnMemoryMode = ReadOnMemoryMode;
                        lookAheadInfo.DefaultBinding = currentBindingMode;
                        lookAheadInfo.CoverBinding = CoverBindingMode;
                        lookAheadInfo.IgnoreSavedFilerSetting = !OpenInPreviousImageFilterSetting;
                        lookAheadInfo.BackColor = BackColorOfBuiltInViewer;
                        lookAheadInfo.InitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
                        lookAheadInfo.AlwaysHideUI = AlwaysHideUI;
                        lookAheadInfo.SortModeDetails = sortModeDetails;
                        setSendFilterToLookAheadInfo();
                        lookAheadInfo.Message = coverSettingMode ? IpcLookAheadInfo.MessageEnum.CoverSetting : IpcLookAheadInfo.MessageEnum.Show;
                        lookAheadInfo.Accept = false;
                    }
                    else if (waitTime == 1000)
                    {
                        Cursor.Current = Cursors.WaitCursor;
                    }
                    else*/
                    bool processExited;
                    try
                    {
                        processExited = waitingProcess == null || waitingProcess.HasExited;
                    }
                    catch
                    {
                        processExited = true;
                    }
                    if (processExited || waitTime > 10000)
                    {
                        //Program.AlertError(new Exception(Message.ViewerProcessStopsResponding)); // 原因が明らかなのでプログラムの再起動は選択肢に入れない。
                        if (!processExited || !StopLookAheadProcessByProgram)
                        {
                            MessageBox.Show(Message.BuiltInViewerProcessStopsResponding, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                        StopLookAheadProcessByProgram = false;
                        break;
                    }
                    if (lookAheadInfo == null)// 非同期メソッドなので途中で lookAheadInfo が書き換わる可能性がある。ただし実際にはファイルの名前を変更しようとした場合などなので警告は出さない
                    {
                        break;
                    }
                }
                while (!lookAheadInfo.Accept);
                OpenWaitingProcess_Opening = false;

                Cursor.Current = Cursors.Default;

                if (!OpenWaitingProcess_StopPrepareLookAheadProcess && AllowReadAheadProcess)
                {
                    PrepareLookAheadProcess(/*Configuration.GetLastWriteTime()*/);
                }
                else
                {
                    if (lookAheadInfo != null)
                    {
                        RemotingServices.Disconnect(lookAheadInfo);
                        lookAheadInfo = null;
                    }
                    waitingProcess = null;
                }
                OpenWaitingProcess_StopPrepareLookAheadProcess = false;

                // 多くの場合に開いたファイル自体を再度先読みすることになりメリットがあまりない上、サムネイル用のリネームの妨げにもなる
                // こうすることで、一旦別のファイルの先読みをしなければ今開いたファイルの先読みは行われない
                // ただし単一のファイルの場合は永遠に先読みされなくなるので
                // After called の状態で Activate になれば元に戻す
                SetLookAheadArchive_PrevIpcLookAheadInfo = lookAheadInfo;
                SetLookAheadArchive_PrevPath = path;
                OpenWaitingProcess_AfterCalled = true;
                var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
                if (altPos >= 0)
                {
                    SetLookAheadArchive_BlackPrefix = path.Substring(0, altPos);
                }
            }
            finally
            {
                OpenWaitingProcess_Processing = false;
            }
        }

        private void CatalogForm_Activated(object sender, EventArgs e)
        {
            SetLookAheadArchive_BlackPrefix = null;

            // 単一の場合に先読みされなくなる問題の回避
            if (OpenWaitingProcess_AfterCalled)
            {
                OpenWaitingProcess_AfterCalled = false;
                SetLookAheadArchive_PrevIpcLookAheadInfo = null;
                SetLookAheadArchive_PrevPath = null;

                SetLookAheadArchive_PrevDataIndex = -1;
            }

            // ポインティングなしデバイスへの配慮としてアクティブ化直後はマスクしない
            unselectedItemMaskOff();

            /*
            if(Bounds.Contains(Cursor.Position))
            {
                unselectedItemMaskOff();
            }
            else
            {
                unselectedItemMaskOn();
            }
            */

            if (BookmarkConfigModifiedDateTime > DateTime.MinValue)
            {
                try
                {
                    //if (File.Exists(Configuration.XmlPath))
                    if (Configuration.ConfigFileExists())
                    {
                        //if (BookmarkConfigModifiedDateTime < File.GetLastWriteTime(Configuration.XmlPath))
                        if (BookmarkConfigModifiedDateTime < Configuration.GetLastWriteTimeWithoutFileCheckWithException())
                        {
                            loadBookmarkFromConfig(reload: true);
                        }
                    }
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            AllowFullpower = true;
        }

        private void CatalogForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            if (currentIpcChanne != null)
            {
                if (lookAheadInfo != null)
                {
                    RemotingServices.Disconnect(lookAheadInfo);
                    lookAheadInfo = null;
                }
                ChannelServices.UnregisterChannel(currentIpcChanne);
                currentIpcChanne = null;
            }
            // 待ちプロセスは自分で消滅するためこちらから消す必要はない
        }

        private void tvCatalog_MouseMove(object sender, MouseEventArgs e)
        {
            var dataIndex = tvCatalog.PointToIndex(e.Location);
            SetLookAheadArchive(dataIndex);
            tvCatalog_MouseMove_RatingChangePart();// (dataIndex);
        }


        private void dgvFileList_MouseMove(object sender, MouseEventArgs e)
        {
            var showIndex = dgvFileList.HitTest(e.X, e.Y).RowIndex;
            if (showIndex < 0) return;
            var s2d = tvCatalog.ShowIndexToDataIndex;
            if (showIndex >= s2d.Length) return;
            var dataIndex = s2d[showIndex];
            SetLookAheadArchive(dataIndex);
        }

        private int SetLookAheadArchive_PrevDataIndex = -1;
        private void SetLookAheadArchive(int dataIndex)
        {
            if (!InDirectoryVirtualDirectoryOrSmartDirectory && !InArchive) return;
            if (OpenWaitingProcess_Opening) return;
            if (dataIndex < 0) return;
            if (dataIndex == SetLookAheadArchive_PrevDataIndex) return;
            if (CreatingZipPathArray) return;
            var aa = ApplicationArray;
            if (aa == null) return;
            var bp = aa.FirstOrDefault(a => a != null && a is BuiltInViewerProvider);
            if (bp == default(ApplicationProvider)) return;
            var count = tvCatalog.Count;

            var lr = LoadResultArray;
            if (lr == null || lr.Length != count) return;
            var lrd = lr[dataIndex];
            //if (lrd == LoadResult.LoadError || lrd == LoadResult.FileNotFound || thumbnailCache == GPSizeThumbnail.AlternateDataStream && lrd == LoadResult.NotYet) return;
            if (lrd == LoadResult.LoadError || lrd == LoadResult.FileNotFound) return;

            if (dataIndex >= count) return;
            var zpa = ZipPathArray; if (zpa == null || zpa.Length != count) return;
            var zna = ZipNameArray; if (zna == null || zna.Length != count) return;
            var path = zpa[dataIndex];
            var isDir = zna[dataIndex].EndsWith(Path.DirectorySeparatorChar.ToString());
            if (!bp.IsDefaultFor(path, isDir) && !bp.Supports(path, isDir)) return;

            // 代替データストリームの保存を妨げないように
            if (InDirectoryVirtualDirectoryOrSmartDirectory && lrd == LoadResult.NotYet && thumbnailCache == GPSizeThumbnail.AlternateDataStream && (
                isDir && SubfolderIsFullDisplayed() /*SubfolderMode == SubfolderMode.Display*/ || !isDir && ArchiveLoadLevel == ItemLoadLevel.Full
                )) return;

            SetLookAheadArchive_PrevDataIndex = dataIndex;

            var altSepPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            if (altSepPos >= 0)
            {
                SetLookAheadArchive(path, -1);
                //SetLookAheadArchive(path.Substring(0, altSepPos), dataIndex);
            }
            else
            {
                var zga = ZipPageArray; if (zpa == null || zpa.Length != count) return;
                SetLookAheadArchive(path, zga[dataIndex]);
            }

            /*
            if (dataIndex >= 0)
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null && dataIndex < ZipPathArray.Length &&
                        LoadResultArray != null && LoadResultArray[dataIndex] != LoadResult.LoadError && LoadResultArray[dataIndex] != LoadResult.FileNotFound)
                    {
                        SetLookAheadArchive(ZipPathArray[dataIndex], ZipPageArray[dataIndex]);
                    }
                }
            }
            */
        }

        private void tmWatchIpc_Tick(object sender, EventArgs e)
        {
            var startingGuid = loadingGuid;

            IpcReportFromViewerToCatalog.OldAndNewString[] tmWatchIpc_Tick_GotData = null;
            try
            {
                if (reportFromViewerToCatalog.PathRequiredReload.Count > 0)
                {
                    tmWatchIpc_Tick_GotData = reportFromViewerToCatalog.PathRequiredReload.ToArray();
                    //reportFromViewerToCatalog.PathRequiredReload.Clear(); // サーバー側は書き換え用のメソッドが直接実行可能だがその途中でクライアントに読み出されることがある
                    reportFromViewerToCatalog.PathRequiredReload = new List<IpcReportFromViewerToCatalog.OldAndNewString>();
                }
            }
            catch { }

            if (tmWatchIpc_Tick_GotData != null)
            {
                // この関数はサブスレッドで実行されるため新たなスレッドの生成は不要
                string location = null;
                int[] d2s = null;
                var reloaded = false;

                for (var j = tmWatchIpc_Tick_GotData.Length - 1; j >= 0; j--)
                {
                    var newold = tmWatchIpc_Tick_GotData[j];
                    if (newold == null) continue;
                    if (newold.RequestToChangeSelection && (ItemSelectionFeedback == ItemSelectionFeedback.Always ||
                        ItemSelectionFeedback == ItemSelectionFeedback.IfSortMayBeSame && sortMode == newold.ViewerFormSortMode && IsNonvolatileSort()))
                    {
                        var path = newold.New;
                        var zpa = ZipPathArray;
                        var s2d = tvCatalog.ShowIndexToDataIndex;
                        if (path != null && zpa != null && s2d != null)
                        {
                            // できるだけ丁寧に無駄な走査をしないようチェック
                            if (InMovie) break;
                            var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
                            if (altPos >= 0)
                            {
                                if (InDirectoryVirtualDirectoryOrSmartDirectory) break;
                                var parent = path.Substring(0, altPos).ToLower();
                                var cd = currentLocation?.ToLower();
                                if (string.IsNullOrEmpty(cd)) break;
                                var last = cd.Last();
                                if (last == Path.DirectorySeparatorChar || last == Path.AltDirectorySeparatorChar)
                                {
                                    cd = cd.Substring(0, cd.Length - 1);
                                }
                                if (parent != cd) break;
                            }
                            else
                            {
                                if (InArchive) break;
                                if (!(InSmartDirectory || InVirtualDirectory))
                                {
                                    string parent;
                                    try
                                    {
                                        parent = Path.GetDirectoryName(path).ToLower();

                                        // ルートの場合に必要な処理
                                        if (parent.Last() == Path.DirectorySeparatorChar)
                                        {
                                            parent = parent.Substring(0, parent.Length - 1);
                                        }
                                    }
                                    catch
                                    {
                                        break;
                                    }
                                    var cd = currentLocation?.ToLower();
                                    if (string.IsNullOrEmpty(cd)) break;
                                    var last = cd.Last();
                                    if (last == Path.DirectorySeparatorChar || last == Path.AltDirectorySeparatorChar)
                                    {
                                        cd = cd.Substring(0, cd.Length - 1);
                                    }
                                    if (parent != cd) break;
                                }
                            }

                            var count = zpa.Length;
                            var index = -1;
                            var showIndex = -1;
                            foreach (var i in s2d)
                            {
                                showIndex++;
                                if (i < 0 || i >= count) break;
                                else if (path == zpa[i])
                                {
                                    index = i;
                                    break;
                                }
                            }
                            if (index >= 0)
                            {
                                tvCatalog.SelectedIndex = index;
                                tvCatalog.FocusedIndex = index;
                                tvCatalog.ScrollBarToIndexWithMinimalMove(showIndex);
                                // 詳細表示は自動的に連動する
                            }
                        }
                        break;
                    }
                }
                foreach (var newold in tmWatchIpc_Tick_GotData)
                {
                    if (newold == null) continue;
                    if (newold.RequestToReloadTags)
                    {
                        try
                        {
                            Invoke(new MethodInvoker(() =>
                            {
                                setTagFilteringMenuItems(needToRepairTagsFromBookmark: false, needToSaveCurrentTag: false);
                            }));
                        }
                        catch (ObjectDisposedException) { }

                        continue;
                    }
                    if (newold.RequestToChangeSelection)
                    {
                        // 先に実行済み
                        continue;
                    }
                    if (newold.RequestToUpdateLastAccessTime)
                    {
                        var path = newold.New;
                        Task.Run(() =>
                        {
                            for (var i = 0; i < 1000; i++)
                            {
                                Thread.Sleep(100);
                                //GPSizeThumbnail.AddBlackListWeight(path);
                                DateTime? now_;
                                GPSizeThumbnail.EnterEditing(path);
                                try
                                {
                                    now_ = Program.TryUpdateLastAccessTime(path);
                                }
                                finally
                                {
                                    GPSizeThumbnail.ExitedEditing(path);
                                }
                                if (now_ == null) GPSizeThumbnail.Editing(path);
                                else
                                {
                                    var now = (DateTime)now_;
                                    try
                                    {
                                        Invoke(new MethodInvoker(() =>
                                        {
                                            lock (ZipPathArrayLocker)
                                            {
                                                if (ZipPathArray != null)
                                                {
                                                    var index = Array.IndexOf(ZipPathArray, path);
                                                    if (index >= 0)
                                                    {
                                                        LastAccessTimeArray[index] = now;
                                                        var cul = Message.CurrentLanguage;
                                                        var ds = tvCatalog.DataIndexToShowIndex;
                                                        if (ds != null && ds.Length > index)
                                                        {
                                                            var showIndex = ds[index];
                                                            if (showIndex >= 0)
                                                            {
                                                                dgvFileList.Rows[showIndex].Cells[tbcAccessTime.Index].Value = getShortTimeString(now, cul);

                                                                if (sortMode == SortMode.AccessedInAsc || sortMode == SortMode.AccessedInDesc)
                                                                {
                                                                    var s2d = tvCatalog.ShowIndexToDataIndex;
                                                                    var sign = sortMode == SortMode.NameInAsc ? 1 : -1;
                                                                    if (showIndex > 0 && sign * GetSortArray_NaturalSort.Compare(LastAccessTimeArray[s2d[showIndex - 1]], now) > 0 ||
                                                                    showIndex < LastAccessTimeArray.Length - 1 && sign * GetSortArray_NaturalSort.Compare(now, ZipNameArray[s2d[showIndex + 1]]) > 0)
                                                                    {
                                                                        tbcAccessTime.HeaderCell.SortGlyphDirection = SortOrder.None;
                                                                        cbSortBy.SelectedIndex = -1;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                        }));
                                    }
                                    catch (ObjectDisposedException) { }
                                    return;
                                }
                            }
                        });
                    }
                    if (reloaded) continue;
                    if (newold.Sor == null)
                    {
                        // 子の変更がかかった場合。実フォルダフォルダ監視に先を越されて意味がない
                        if (!CreatingZipPathArray && (InVirtualDirectory || InSmartDirectory))
                        {
                            //Thread.Sleep(5 * 1000);
                            ReloadOneThumbnailForSubThread(newold.Old, newold.New, startingGuid);
                            swapPathAndNameInSorBookmarkUndoBuff(newold.Old, newold.New, needToSaveBookmark: true);
                        }

                        // 親の変更がかかった場合
                        if (!CreatingZipPathArray && currentLocation?.ToLower() == newold.Old?.ToLower())
                        {
                            try
                            {
                                var newPath = newold.New;
                                Invoke(new MethodInvoker(() =>
                                {
                                    if (!CreatingZipPathArray && currentLocation?.ToLower() == newold.Old?.ToLower()) // 二重チェック
                                    {
                                        UpdatePreview(renamedLocation: newPath);
                                    }
                                }));
                            }
                            catch (ObjectDisposedException) { }
                        }

                    }
                    else
                    {
                        if (location == null)
                        {
                            location = currentLocation?.ToLower();
                        }
                        var currentSor = newold.Sor.ToLower() == location;
                        if (currentSor || (LoadLastViewedPageFromHistory && InDirectoryVirtualDirectoryOrSmartDirectory))
                        {
                            try
                            {
                                Invoke(new MethodInvoker(() =>
                                {
                                    if (IsDisplay(SubfolderMode) || ArchiveLoadLevel != ItemLoadLevel.Ignore)
                                    {
                                        lock (ZipPathArrayLocker)
                                        {
                                            if (ZipPathArray != null)
                                            {
                                                var index = Array.IndexOf(ZipPathArray, newold.New);
                                                if (index >= 0 && index < tvCatalog.Count)
                                                {
                                                    var oldPage = ZipPageArray[index];
                                                    ZipPageArray[index] = newold.NewPage;
                                                    var total = FileCountArray[index];
                                                    if (d2s == null) d2s = tvCatalog.DataIndexToShowIndex;
                                                    var showIndex = d2s == null || d2s.Length <= index ? -1 : d2s[index];
                                                    if (showIndex >= 0 && dgvFileList.Rows.Count > showIndex)
                                                    {
                                                        dgvFileList.Rows[showIndex].Cells[tbcPage.Index].Value = getPageString(newold.NewPage, total);
                                                        if (LoadLastViewedPageFromHistory && oldPage != newold.NewPage)
                                                        {
                                                            tvCatalog[index]?.DrawItem(onlyFrame: false);
                                                        }

                                                        /*
                                                        if (PackedImageLoader.IsSupertedImage(newold.New))
                                                        {
                                                            dgvFileList.Rows[showIndex].Cells[tbcPage.Index].Value = EmptyPageString;
                                                        }
                                                        else if (newold.NewPage >= 0)
                                                        {
                                                            dgvFileList.Rows[showIndex].Cells[tbcPage.Index].Value = total >= 0 ? $"{newold.NewPage + 1}/{total}" : $"{newold.NewPage + 1}/?";
                                                        }
                                                        else if (ZipNameArray[index].EndsWith(Path.DirectorySeparatorChar.ToString()) || PackedImageLoader.SupportedArchivesPath.IsMatch(newold.New))
                                                        {
                                                            dgvFileList.Rows[showIndex].Cells[tbcPage.Index].Value = total >= 0 ? $"{total}" : $"?";
                                                        }
                                                        else
                                                        {
                                                            dgvFileList.Rows[showIndex].Cells[tbcPage.Index].Value = EmptyPageString;
                                                        }
                                                        */
                                                    }
                                                }
                                                else
                                                {
                                                    // 見つからなければ再読込する実装
                                                    // 表示設定などで見つからないことは想定されて
                                                    // その場合再読込しても結果は変わらないので不要
                                                    /*
                                                    reloadAllThumbnailsToolStripMenuItem_Click(null, null);
                                                    reloaded = true;
                                                    */
                                                }
                                            }
                                        }
                                    }
                                }));
                            }
                            catch (ObjectDisposedException) { }
                        }
                    }
                }
            }

            var p = Cursor.Position;
            var currentMouseOnWindow = Bounds.Contains(p) && !CursorIsJustOnWindow(p);
            if (mouseOnWindow && !currentMouseOnWindow)
            {
                if (!VisibleCobtextMenuStripExists())
                {
                    mouseOnWindow = false;
                    globalMouseLeave(p);
                }
            }
            else if (!mouseOnWindow && currentMouseOnWindow)
            {
                mouseOnWindow = true;
                globalMouseEnter(p);
            }

        }

        private bool mouseOnWindow;


        // ハンドルからウインドウの位置を取得。
        [System.Runtime.InteropServices.DllImport("user32.dll")]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [System.Runtime.InteropServices.DllImport("user32.dll")]
        public static extern IntPtr GetForegroundWindow();

        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public struct RECT
        {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public static implicit operator Rectangle(RECT rect)
            {
                return new Rectangle(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
            }
        }

        private bool CursorIsJustOnWindow(Point screenLocation)
        {
            if (ActiveForm == this) return false; // 極力 API は使わない

            var handle = GetForegroundWindow();
            if (handle == Handle) return false;
            RECT otherRectangle0;
            if (!GetWindowRect(handle, out otherRectangle0)) return false;
            var otherRectangle = (Rectangle)otherRectangle0;
            return otherRectangle.Contains(screenLocation);
        }

        // 64bit では動かない
        // http://pieceofnostalgy.blogspot.jp/2011/11/net-framework.html
        //[System.Runtime.InteropServices.DllImport("user32.dll", CallingConvention = System.Runtime.InteropServices.CallingConvention.StdCall)]
        //public static extern IntPtr WindowFromPoint(int x, int y);
        /*
        private bool CursorIsJustOnWindow()
        {
            var p = Cursor.Position;
            return WindowFromPoint(p.X, p.Y) == Handle;
        }
        */

        void ReloadOneThumbnailForSubThread(int index, Guid startingGuid)
        {
            if (index >= 0)
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null && index < ZipPathArray.Length)
                    {
                        ReloadOneThumbnailForSubThread(index, ZipPathArray[index], startingGuid);
                    }
                }
            }
        }

        void ReloadOneThumbnailForSubThread(string oldPath, string newPath, Guid startingGuid)
        {
            if (!string.IsNullOrEmpty(oldPath) && !string.IsNullOrEmpty(newPath))
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null)
                    {
                        ReloadOneThumbnailForSubThread(Array.IndexOf(ZipPathArray, oldPath), newPath, startingGuid);
                    }
                }
            }
        }

        enum SilentMode { Always, Never, OnlyIfNotSuccess }
        void ReloadOneThumbnailForSubThread(int index, string newPath, Guid startingGuid, string oldPath = null, SilentMode silentMode = SilentMode.Never, bool reloadPage = false)
        {
            if (index >= 0 && !string.IsNullOrEmpty(newPath))
            {
                if (startingGuid != loadingGuid) return;
                var enterIf = false;
                Bitmap thumbnail = null;
                int filecount = -1;
                LoadResult loadResult = LoadResult.NotYet;
                long fileSize = -1;
                ImageInfo imageInfo;
                MovieInfo movieInfo;
                string zipName = null;
                var path = newPath;
                var isDir = false;
                lock (ZipPathArrayLocker)
                {
                    if (CreatingZipPathArray) return;

                    if (ZipPathArray != null && index < ZipPathArray.Length)
                    {
                        enterIf = true;
                        try
                        {
                            if (oldPath != null && oldPath != ZipPathArray[index]) return;
                            ZipPathArray[index] = path;
                            //var name = path.Substring(dirPathFullPathLengthPlusOne);

                            //isDir = oldPath != null ? ZipNameArray[index].EndsWith(Path.DirectorySeparatorChar.ToString()) : Directory.Exists(newPath);
                            isDir = Directory.Exists(newPath);
                            ZipNameArray[index] = zipName = getRelativePath(path, isDir);// name + Path.DirectorySeparatorChar;

                            FileSystemInfo info;
                            if (isDir)
                            {
                                info = new DirectoryInfo(path);
                            }
                            else
                            {
                                info = new FileInfo(path);
                            }
                            CreateTimeArray[index] = Program.GetCreateTime(info);
                            LastAccessTimeArray[index] = Program.GetLastAccessTime(info); // info.LastAccessTime;
                            ModifiedTimeArray[index] = Program.GetLastWriteTime(info);// .LastWriteTime;
                            FileCountArray[index] = -1;
                            ImageInfoArray[index] = null;// Size.Empty;
                            MovieInfoArray[index] = null;

                            if (reloadPage && LoadLastViewedPageFromHistory && File.Exists(Program.HistorySorPath))
                            {
                                ZipPageArray[index] = VirtualFolder.GetPageFromBookmark(path, isDir, Program.HistorySorPath);
                            }

                        }
                        catch (Exception error)
                        {
                            Program.AlertError(error);
                            return;
                        }
                    }
                }
                if (enterIf)
                {
                    bool dummy; // 一部リロードでは再ソートしない仕様
                    movieInfo = null;
                    thumbnail = GetThumbnail(path, isDir, null, out dummy, out filecount, out loadResult, out fileSize, out imageInfo, ref movieInfo, existsHeader: false);
                    if (fileSize < 0 && !isDir) // フォルダの場合サイズは取得済みまたはサイズは表示しない設定
                    {
                        try
                        {
                            fileSize = (new FileInfo(path)).Length;
                        }
                        catch { }
                    }
                    //if (fileSize >= 0)
                    {
                        if (startingGuid != loadingGuid)
                        {
                            thumbnail?.Dispose();
                            return;
                        }
                        try
                        {
                            Invoke((MethodInvoker)(() =>
                            {
                                if (CreatingZipPathArray || startingGuid != loadingGuid)
                                {
                                    thumbnail?.Dispose();
                                    return;
                                }
                                try
                                {
                                    if (index >= tvCatalog.Count)
                                    {
                                        thumbnail?.Dispose();
                                        return;
                                    }
                                    /*
                                    var item = new ThumbViewerItem();
                                    item.Image = thumbnail;
                                    item.Text = zipName;
                                    tvCatalog[index] = item;
                                    */



                                    lock (ZipPathArrayLocker)
                                    {
                                        if (CreatingZipPathArray || index >= FileCountArray.Length)
                                        {
                                            thumbnail?.Dispose();
                                            return;
                                        }

                                        //NameInAsc, NameInDesc, RatingInAsc, RatingInDesc, AccessedInAsc, AccessedInDesc, ModifiedInAsc, ModifiedInDesc, SizeInAsc, SizeInDesc

                                        if (sortMode == SortMode.NameInAsc || sortMode == SortMode.NameInDesc)
                                        {
                                            var s2d = tvCatalog.ShowIndexToDataIndex;
                                            var sign = sortMode == SortMode.NameInAsc ? 1 : -1;
                                            var showIndex = tvCatalog.DataIndexToShowIndex[index];
                                            if (showIndex >= 0)
                                            {
                                                var clearSortOrder = false;
                                                var s2dLength = s2d.Length;
                                                var showIndexMinus1 = showIndex - 1;
                                                var ZipNameArrayLength = ZipNameArray.Length;
                                                if (showIndexMinus1 >= 0 && showIndexMinus1 < s2dLength)
                                                {
                                                    var preIndex = s2d[showIndexMinus1];
                                                    if (preIndex >= 0 && preIndex < ZipNameArrayLength)
                                                    {
                                                        var preName = ZipNameArray[preIndex];
                                                        if (preName != null && zipName != null && sign * GetSortArray_NaturalSort.Compare(preName, zipName) > 0)
                                                        {
                                                            clearSortOrder = true;
                                                        }
                                                    }
                                                }
                                                if (!clearSortOrder)
                                                {
                                                    var showIndexPlus1 = showIndex + 1;
                                                    if (showIndexPlus1 >= 0 && showIndexPlus1 < s2dLength)
                                                    {
                                                        var nexIndex = s2d[showIndexPlus1];
                                                        if (nexIndex >= 0 && nexIndex < ZipNameArrayLength)
                                                        {
                                                            var nexName = ZipNameArray[nexIndex];
                                                            if (nexName != null && zipName != null && sign * GetSortArray_NaturalSort.Compare(zipName, nexName) > 0)
                                                            {
                                                                clearSortOrder = true;
                                                            }
                                                        }

                                                    }
                                                }

                                                if (clearSortOrder)
                                                {
                                                    tbcFileName.HeaderCell.SortGlyphDirection = SortOrder.None;
                                                    cbSortBy.SelectedIndex = -1;
                                                }
                                            }
                                        }


                                        FileCountArray[index] = filecount;
                                        LoadResultArray[index] = loadResult;
                                        ZipSizeArray[index] = fileSize;
                                        ImageInfoArray[index] = imageInfo;
                                        MovieInfoArray[index] = movieInfo;

                                        setFileListRowInLock(index, dynamicOnly: false, localOnly: false, cultureForOnlyStatic: Message.CurrentLanguage, volatilitySortCancelIfChanged: true);

                                    }
                                    //var row = dgvFileList.Rows[tvCatalog.DataIndexToShowIndex[index]];
                                    //row.Cells[tbcFileName.Index].Value = zipName;
                                    //(row.Cells[tbcRating.Index] as RatingGridViewTextBoxCell).Rating = ZipPlaInfo.GetOnlyRating(path); // getShortRatingString(path);

                                    // 最後にやらないと描画時に Success 等が正しく参照されない
                                    var silent = silentMode == SilentMode.Always || silentMode == SilentMode.OnlyIfNotSuccess && loadResult != LoadResult.Success;
                                    if (tvCatalog[index] == null)
                                    {
                                        var item = new ThumbViewerItem();
                                        item.Image = thumbnail;
                                        item.Text = zipName;
                                        if (silent)
                                        {
                                            tvCatalog.SilentSet(index, item);
                                        }
                                        else
                                        {
                                            tvCatalog[index] = item;
                                        }
                                    }
                                    else
                                    {
                                        if (silent)
                                        {
                                            tvCatalog[index].SilentSet(thumbnail, zipName);
                                        }
                                        else
                                        {
                                            tvCatalog[index].Set(thumbnail, zipName);
                                        }
                                    }
                                }
                                catch (Exception error)
                                {
                                    Program.AlertError(error);
                                }
                                /*
                                if (tvCatalog.SelectedIndex == index)
                                {
                                    ShowStatusBar(index);
                                }
                                */
                                if (tvCatalog.SelectedIndices?.Contains(index) == true)
                                {
                                    ShowStatusBar();
                                }
                            }));
                        }
                        catch (ObjectDisposedException) { }
                    }
                }
            }
        }

        private void resetVolatilitySort()
        {
            foreach (DataGridViewColumn c in dgvFileList.Columns)
            {
                if (
                    c != tbcFileName &&
                    c != tbcRating &&
                    c != tbcCreateTime &&
                    c != tbcAccessTime &&
                    c != tbcWriteTime &&
                    c != tbcSize)
                {
                    c.HeaderCell.SortGlyphDirection = SortOrder.None;
                }
            }
        }
        private void setNonVolatilitySort()
        {
            resetVolatilitySort();
            dgvFileList.Columns[tbcIcon.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.TypeInAsc ? SortOrder.Ascending : sortMode == SortMode.TypeInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcFileName.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.NameInAsc ? SortOrder.Ascending : sortMode == SortMode.NameInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcRating.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.RatingInAsc ? SortOrder.Ascending : sortMode == SortMode.RatingInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcCreateTime.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.CreatedInAsc ? SortOrder.Ascending : sortMode == SortMode.CreatedInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcAccessTime.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.AccessedInAsc ? SortOrder.Ascending : sortMode == SortMode.AccessedInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcWriteTime.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.ModifiedInAsc ? SortOrder.Ascending : sortMode == SortMode.ModifiedInDesc ? SortOrder.Descending : SortOrder.None;
            dgvFileList.Columns[tbcSize.Index].HeaderCell.SortGlyphDirection = sortMode == SortMode.SizeInAsc ? SortOrder.Ascending : sortMode == SortMode.SizeInDesc ? SortOrder.Descending : SortOrder.None;
            var temp = cbSortBy_SelectedValueChanged_Stop;
            cbSortBy_SelectedValueChanged_Stop = true;
            //while (cbSortBy.Items.Count > (int)SortMode.Random + 1) cbSortBy.Items.RemoveAt(cbSortBy.Items.Count - 1);
            cbSortBy.SelectedIndex = (int)sortMode;
            cbSortBy_SelectedValueChanged_Stop = temp;
        }

        private long ShowStatusBar_NextID = 0;
        private long ShowStatusBar_CurrentID = 0;
        private void ShowStatusBar() { ShowStatusBar(tvCatalog.SelectedIndices); }
        private void ShowStatusBar(IEnumerable<int> selectedIndices)
        {
            var id = ShowStatusBar_NextID;
            ShowStatusBar_CurrentID = id;
            ShowStatusBar_NextID = ShowStatusBar_NextID < long.MaxValue ? ShowStatusBar_NextID + 1 : 0;

            var itemsCount = -1;
            var selectedCount = 0;
            long fileSize = 0;
            bool? ffmpegExists = null;
            //var atLeastOneDir = false;
            List<string> dirPathList = null;
            if (selectedIndices != null && selectedIndices.Any(i => i >= 0))
            {
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null)
                    {
                        itemsCount = ZipPathArray.Length;
                        foreach (var selectedIndex in selectedIndices)
                        {
                            if (0 <= selectedIndex && selectedIndex < itemsCount)
                            {
                                selectedCount++;
                                var name = ZipNameArray[selectedIndex];
                                var isDir = name.EndsWith(Path.DirectorySeparatorChar.ToString());
                                //if (isDir) atLeastOneDir = true;
                                if (selectedCount == 1)
                                {
                                    var path = ZipPathArray[selectedIndex];
                                    if (selectedFileNameToolStripTextBox.Text != path) selectedFileNameToolStripTextBox.Text = path;
                                    if (ImageLoader.SupportsGetImageInfo(path, ref ffmpegExists))
                                    {
                                        var info = ImageInfoArray[selectedIndex];
                                        if (info == null)
                                        {
                                            selectedFileContainsCountToolStripStatusLabel.Text = "?x?";
                                        }
                                        else
                                        {
                                            var size = info.Size;
                                            selectedFileContainsCountToolStripStatusLabel.Text = $"{size.Width}x{size.Height}";
                                        }
                                    }
                                    else if (isDir || PackedImageLoader.Supports(path))
                                    {
                                        selectedFileContainsCountToolStripStatusLabel.Text = Program.GetNPageString(IfNegativeThenQuestion(FileCountArray[selectedIndex]));
                                    }
                                    else if (MovieThumbnailLoader.Supports(path))
                                    {
                                        var info = MovieInfoArray[selectedIndex];
                                        if (info == null)
                                        {
                                            selectedFileContainsCountToolStripStatusLabel.Text = "";
                                        }
                                        else
                                        {
                                            selectedFileContainsCountToolStripStatusLabel.Text = info.ToShortString();
                                        }
                                    }
                                    else
                                    {
                                        selectedFileContainsCountToolStripStatusLabel.Text = "";
                                    }
                                    if (ffmpegExists != null) RecentFfmpegExists = (bool)ffmpegExists;
                                }

                                if (fileSize >= 0)
                                {
                                    var thisFileSize = ZipSizeArray[selectedIndex];
                                    if (thisFileSize >= 0)
                                    {
                                        fileSize += thisFileSize;
                                    }
                                    else if (isDir)
                                    {
                                        if (dirPathList == null) dirPathList = new List<string>();
                                        dirPathList.Add(ZipPathArray[selectedIndex]);
                                    }
                                    else
                                    {
                                        fileSize = -1;
                                        dirPathList = null;
                                    }
                                }
                                //var thisFileSize = ZipSizeArray[selectedIndex];
                                //fileSizeToolStripStatusLabel.Text = fileSize >= 0 ? Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true) :
                                //   isDir ? $"? {Message.Bytes}" : "";

                            }
                        }
                    }
                }
            }
            //var needToCheckDirSize = false;
            /*
            if (atLeastOneDir && !CheckDirectorySize)
            {
                fileSizeToolStripStatusLabel.Text = "";
            }
            else
            */
            {
                if (fileSize >= 0)
                {
                    if (dirPathList == null)
                    {
                        fileSizeToolStripStatusLabel.Text = Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true);
                    }
                    else
                    {
                        fileSizeToolStripStatusLabel.Text = Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true) + "+";
                    }
                }
                else
                {
                    fileSizeToolStripStatusLabel.Text = $"? {Message.Bytes}";
                }
            }
            tvCatalog_ShowIndexToDataIndexChanged(null, null);

            if (selectedCount != 1)
            {
                var selectedIndicesCount = tvCatalog.SelectedIndicesCount;
                if (selectedIndicesCount > 1)
                {
                    selectedFileNameToolStripTextBox.Text = Message._1ItemsAreSelected.Replace("$1", selectedIndicesCount.ToString());
                }
                else
                {
                    selectedFileNameToolStripTextBox.Text = "";
                }
                selectedFileContainsCountToolStripStatusLabel.Text = "";
                if (selectedCount < 1) fileSizeToolStripStatusLabel.Text = "";
            }

            if (fileSize >= 0 && dirPathList != null)
            {
                var lastCheck = (Environment.TickCount & int.MaxValue); // 最も高速だがループで大小関係が狂うので注意 http://d.hatena.ne.jp/saiya_moebius/20100819/1282201466
                Task.Run(() =>
                {
                    foreach (var dirPath in dirPathList)
                    {
                        try
                        {
                            foreach (var file in new DirectoryInfo(dirPath).EnumerateFiles("*", SearchOption.AllDirectories))
                            {
                                fileSize += file.Length;
                                const int span = 50;
                                if (id != ShowStatusBar_CurrentID) return;
                                var now = (Environment.TickCount & int.MaxValue);
                                bool over;
                                if (lastCheck <= int.MaxValue - span)
                                {
                                    over = now >= lastCheck + span || now < lastCheck;
                                }
                                else
                                {
                                    over = now >= lastCheck - (int.MaxValue - (span - 1)) && now < lastCheck;
                                }
                                if (over)
                                {
                                    lastCheck = now;
                                    Invoke(((MethodInvoker)(() =>
                                    {
                                        if (id != ShowStatusBar_CurrentID) return;
                                        fileSizeToolStripStatusLabel.Text = Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true) + "+";
                                    })));
                                }
                                if (id != ShowStatusBar_CurrentID) return;
                            }
                            Invoke(((MethodInvoker)(() =>
                            {
                                if (id != ShowStatusBar_CurrentID) return;
                                fileSizeToolStripStatusLabel.Text = Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true);
                            })));
                        }
                        catch
                        {
                            Invoke(((MethodInvoker)(() =>
                            {
                                if (id != ShowStatusBar_CurrentID) return;
                                fileSizeToolStripStatusLabel.Text = fileSizeToolStripStatusLabel.Text = $"? {Message.Bytes}";
                            })));
                            return;
                        }
                    }
                });

                /*
                var dirSize = await GetDirectorySizeAsync(dirPathList, id);
                if (dirSize >= 0)
                {
                    fileSize += dirSize;
                    fileSizeToolStripStatusLabel.Text = Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true);
                }
                */
            }
        }

        /*
        private async Task<long> GetDirectorySizeAsync(IEnumerable<string> dirPathCollection, long id)
        {
            return await Task.Run(() =>
            {
                var result = 0L;
                foreach (var dirPath in dirPathCollection)
                {
                    try
                    {
                        foreach (var file in new DirectoryInfo(dirPath).EnumerateFiles("*", SearchOption.AllDirectories))
                        {
                            result += file.Length;
                            if (id != ShowStatusBar_CurrentID) return -1;
                        }
                    }
                    catch
                    {
                        return -1;
                    }
                }
                return result;
            });
        }
        */

        /*
        private void ShowStatusBar() { ShowStatusBar(tvCatalog.SelectedIndex); }
        private void ShowStatusBar(int selectedIndex)
        {
            var itemsCount = -1;
            var selected = false;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null)
                {
                    itemsCount = ZipPathArray.Length;

                    if (0 <= selectedIndex && selectedIndex < itemsCount)
                    {
                        var path = ZipPathArray[selectedIndex];
                        var name = ZipNameArray[selectedIndex];
                        var isDir = name.EndsWith(Path.DirectorySeparatorChar.ToString());
                        if (selectedFileNameToolStripTextBox.Text != path) selectedFileNameToolStripTextBox.Text = path;
                        if (ImageLoader.SupportsGetImageInfo(path))
                        {
                            var info = ImageInfoArray[selectedIndex];
                            if (info == null)
                            {
                                selectedFileContainsCountToolStripStatusLabel.Text = "?x?";
                            }
                            else
                            {
                                var size = info.Size;
                                selectedFileContainsCountToolStripStatusLabel.Text = $"{size.Width}x{size.Height}";
                            }
                        }
                        else if (isDir || PackedImageLoader.SupportedArchivesPath.IsMatch(path))
                        {
                            selectedFileContainsCountToolStripStatusLabel.Text = Message._1Pages.Replace("$1", IfNegativeThenQuestion(FileCountArray[selectedIndex]));
                        }
                        else if  (MovieThumbnailLoader.Supports(path))
                        {
                            var info = MovieInfoArray[selectedIndex];
                            if(info == null)
                            {
                                selectedFileContainsCountToolStripStatusLabel.Text = "";
                            }
                            else
                            {
                                selectedFileContainsCountToolStripStatusLabel.Text = info.ToShortString();
                            }
                        }
                        else
                        {
                            selectedFileContainsCountToolStripStatusLabel.Text = "";
                        }

                        long fileSize = ZipSizeArray[selectedIndex];
                        fileSizeToolStripStatusLabel.Text = fileSize >= 0 ? Program.GetFormatSizeString(fileSize, Message.Bytes, simpleForm: true) :
                           isDir ? $"? {Message.Bytes}" : "";

                        selected = true;
                    }
                }
            }

            tvCatalog_ShowIndexToDataIndexChanged(null, null);

            if (!selected)
            {
                var selectedIndicesCount = tvCatalog.SelectedIndicesCount;
                if (selectedIndicesCount > 1)
                {
                    selectedFileNameToolStripTextBox.Text = Message._1ItemsAreSelected.Replace("$1", selectedIndicesCount.ToString());
                }
                else
                {
                    selectedFileNameToolStripTextBox.Text = "";
                }
                selectedFileContainsCountToolStripStatusLabel.Text = "";
                fileSizeToolStripStatusLabel.Text = "";
            }
        }
        */

        private void setThumbnailManuallyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenSelectedArchiveCoverSetting();
        }

        private void OpenSelectedArchiveCoverSetting()
        {
            var selectedIndex = tvCatalog.SelectedIndex;
            if (selectedIndex >= 0)
            {
                string selectedPath = null;
                lock (ZipPathArrayLocker)
                {
                    if (ZipPathArray != null && selectedIndex < ZipPathArray.Length)
                    {
                        if (LoadResultArray == null || selectedIndex >= LoadResultArray.Length) return;
                        // LoadResult.NotYet は読み込む
                        switch (LoadResultArray[selectedIndex])
                        {
                            case LoadResult.LoadError:
                                MessageBox.Show(Message.FailedToLoadFile, null, MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1);
                                return;
                            case LoadResult.FileNotFound:

                                MessageBox.Show(Message.NoReadableFile, null, MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1);
                                return;
                        }
                        try
                        {
                            selectedPath = ZipPathArray[selectedIndex];
                        }
                        catch (Exception error)
                        {
                            Program.AlertError(error);
                        }
                    }
                }
                if (selectedPath != null)
                {
                    try
                    {
                        if (PackedImageLoader.Supports(selectedPath))
                        {
                            OpenWaitingProcess(selectedPath, -1, true);
                        }
                        else if (InArchive)
                        {
                            OpenWaitingProcess(selectedPath, page: -1, coverSettingMode: true); // selectedPath が / を含むパスの場合 page は -1 でよい
                        }
                        else if (MovieThumbnailLoader.Supports(selectedPath) && MovieThumbnailLoader.ffmpegExists())
                        {
                            zabLocation.Text = selectedPath;
                            ThumbnailSettingToCatalog_CoverSettingModeAtOnce = true;
                            MakePreview();
                        }
                    }
                    catch (Exception error)
                    {
                        Program.AlertError(error);
                    }
                }
            }
        }

        private void RenameShownArchive(int selectedIndex, string path, string newPath, bool atFirstArrayChange = true, bool? needToReload = null)
        {
            RenameShownArchive(new int[] { selectedIndex }, new string[] { path }, new string[] { newPath }, atFirstArrayChange, needToReload);
        }

        private async Task<bool> showshowConfirmationDialogDialogAlways(string message, IReadOnlyList<string> paths)
        {
            return await showConfirmationDialog(message, paths, 1, getFileName: true);
        }

        private async Task<bool> showshowConfirmationDialogDialogIfIndicesAreMany(string message, IReadOnlyList<string> paths)
        {
            return await showConfirmationDialog(message, paths, 10, getFileName: true);
        }

        private async Task<bool> showConfirmationDialog(string message, IReadOnlyList<string> paths, int dialogLBound, bool getFileName)
        {
            var count = paths.Count;
            if (count >= dialogLBound)
            {
                const int dialogDisplayUBound = 13;
                const int dialogDisplayTail = 6;
                var fullMessage = new StringBuilder(message.Replace("$1", count.ToString())).AppendLine();
                try
                {
                    void appendPath(int i)
                    {
                        var s = paths[i];
                        fullMessage.AppendLine().Append(getFileName ? Path.GetFileName(s) : s);
                    }

                    if (count <= dialogDisplayUBound)
                    {
                        for (var i = 0; i < count; i++) appendPath(i);
                    }
                    else
                    {
                        for (var i = 0; i < dialogDisplayUBound - dialogDisplayTail - 1; i++) appendPath(i);
                        fullMessage.AppendLine().Append("...");
                        for (var i = -dialogDisplayTail; i < 0; i++) appendPath(count + i);
                    }
                    //var stop = count <= dialogDisplayUBound ? count : dialogDisplayUBound - 1;
                    //for (var i = 0; i < stop; i++) message += Path.GetFileName(paths[i]) +
                    //        (i < stop - 1 ? "\n" : stop < count ? "\n..." : "");
                }
                catch { }

                await Task.Run(() => Invoke((MethodInvoker)(() => CloseVisibleContextMenuStrips())));
                //var result = MessageBox.Show(this, message, Message.Question, MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
                var result = MessageForm.Show(this, fullMessage.ToString(), Message.Question, Message._Yes, Message._No, MessageBoxIcon.Question);
                await Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
                //return result == DialogResult.OK;
                return result == 0;
            }
            else
            {
                return true;
            }
        }

        private static void Arrange<T>(T[] target, int[] sorter)
        {
            var temp = target.Clone() as T[];
            for (var i = 0; i < target.Length; i++) target[i] = temp[sorter[i]];
        }

        bool RenameShownArchive_MakePreviewSleepRequest = false;
        /// <summary>
        /// needToReloadEvenIfFileNameIsNotChanged は atFirstArrayChange == false のときは未実装
        /// </summary>
        /// <param name="selectedIndices"></param>
        /// <param name="paths"></param>
        /// <param name="newPaths"></param>
        /// <param name="atFirstArrayChange"></param>
        /// <param name="needToReload"></param>
        /// <param name="needToReloadEvenIfFileNameIsNotChanged"></param>
        private async void RenameShownArchive(int[] selectedIndices, string[] paths, string[] newPaths, bool atFirstArrayChange = true, bool? needToReload = null, bool[] needToReloadEvenIfFileNameIsNotChanged = null)// bool atFirstArrayChange = false)
        {
            var startingGuid = loadingGuid;

            /*
            var count = selectedIndices.Length;
            const int dialogLBound = 10;
            if (count >= dialogLBound)
            {
                const int dialogDisplayUBound = 10;
                var message = Message.DoYouRenameFollowing1Items.Replace("$1", count.ToString()) + "\n\n";
                try
                {
                    var stop = count <= dialogDisplayUBound ? count : dialogDisplayUBound - 1; ;
                    for (var i = 0; i < stop; i++) message += Path.GetFileName(paths[i]) +
                            (i < stop - 1 ? "\n" : stop < count ? "\n..." : "");
                }
                catch { }

                await Task.Run(() => Invoke((MethodInvoker)(() => CloseVisibleContextMenuStrips())));
                var result = MessageBox.Show(this, message, Message.Question, MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
                await Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
                if (result != DialogResult.OK) return;
            }
            */

            var count = selectedIndices.Length;

            var d2s = tvCatalog.DataIndexToShowIndex;
            if (d2s == null) return;
            int[] sorter;
            try
            {
                sorter = Enumerable.Range(0, count).OrderBy(i => d2s[selectedIndices[i]]).ToArray();
            }
            catch // IndexOutOfRangeException
            {
                return;
            }
            Arrange(selectedIndices, sorter);
            Arrange(paths, sorter);
            Arrange(newPaths, sorter);
            if (needToReloadEvenIfFileNameIsNotChanged != null)
            {
                if (needToReloadEvenIfFileNameIsNotChanged.Length == count) Arrange(needToReloadEvenIfFileNameIsNotChanged, sorter);
                else needToReloadEvenIfFileNameIsNotChanged = null;
            }

            if (!await showshowConfirmationDialogDialogIfIndicesAreMany(Message.DoYouRenameFollowing1Items, paths)) return;

            bool[] changes;
            if (needToReloadEvenIfFileNameIsNotChanged == null)
            {
                changes = new bool[count];
                for (var i = 0; i < count; i++)
                {
                    changes[i] = paths[i].ToLower() != newPaths[i].ToLower();
                }
            }
            else
            {
                changes = needToReloadEvenIfFileNameIsNotChanged;
                for (var i = 0; i < count; i++)
                {
                    //var nameChange = paths[i].ToLower() != newPaths[i].ToLower();
                    changes[i] = changes[i] || paths[i].ToLower() != newPaths[i].ToLower();
                }
            }

            if (changes.All(v => !v)) return;

            var lra = LoadResultArray;
            int lraLen;
            if (lra == null || (lraLen = lra.Length) == 0) return;
            var allTargetsAreLoaded = true;
            var tempThreadCount = 0;
            var priority = ProcessPriorityClass.Normal;
            if (bmwMakePreview.IsBusy && (tempThreadCount = bmwMakePreview.ThreadCount) > 0)
            {
                priority = Program.GetPriority();
                for (var i = 0; i < count; i++)
                {
                    var idx = selectedIndices[i];
                    if (idx < 0 || idx >= lraLen) return;
                    if (lra[idx] == LoadResult.NotYet)
                    {
                        allTargetsAreLoaded = false;
                        break;
                    }
                }
            }

            Action renameAction = async () =>
            {
                try
                {
                    StopLookAheadProcess();

                    var needToReloadArray = new bool[count];

                    if (atFirstArrayChange)
                    {
                        var ntr = needToReload != false;
                        lock (ZipPathArrayLocker)
                        {
                            for (var i = 0; i < count; i++)
                            {
                                if (!changes[i]) continue;

                                var index = selectedIndices[i];
                                var path = newPaths[i];
                                var oldPath = paths[i];


                                if (oldPath.ToLower() != path.ToLower()) Program.FileOrDirectoryMove(oldPath, path); // ここで例外が発生した場合 ZipPathArray 等の書き換えは行われない

                                ZipPathArray[index] = path;
                                //var name = path.Substring(dirPathFullPathLengthPlusOne);

                                var name = getRelativePath(path, ZipNameArray[index]);// name + (isDir ? Path.DirectorySeparatorChar.ToString() : "");
                                ZipNameArray[index] = name;

                                setFileListRowInLock(index, dynamicOnly: false, localOnly: false, cultureForOnlyStatic: Message.CurrentLanguage, volatilitySortCancelIfChanged: true);

                                var item = tvCatalog[index];
                                item.SilentSet(name);
                                item.DrawItem(onlyFrame: false); // レートなどの再描画が必要なので

                                if (needToReload != null) needToReloadArray[i] = ntr;
                                else needToReloadArray[i] = LoadResultArray[index] == LoadResult.NotYet;
                            }
                        }
                    }
                    else
                    {
                        for (var i = 0; i < count; i++)
                        {
                            Program.FileOrDirectoryMove(paths[i], newPaths[i]);
                            needToReloadArray[i] = true;
                        }
                    }

                    // InDirectory に限りフォルダ監視でも実行されるが、イベントを落とすリスクに備え常に実行
                    // この関数は二重呼び出しに対する制御は実装済み
                    swapPathAndNameInSorBookmarkUndoBuff(paths, newPaths, needToSaveBookmark: true);

                    PrepareLookAheadProcess();

                    if (needToReloadArray.Any(n => n))
                    {
                        await Task.Run(() =>
                        {
                            for (var i = 0; i < count; i++)
                            {
                                if (needToReloadArray[i])
                                {
                                    ReloadOneThumbnailForSubThread(selectedIndices[i], newPaths[i], startingGuid, atFirstArrayChange ? newPaths[i] : paths[i]);
                                }
                            }
                        });
                    }

                }
                catch (Exception error)
                {
                    await Task.Run(() => Invoke((MethodInvoker)(() => CloseVisibleContextMenuStrips())));
                    MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    await Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
                }
            };

            if (allTargetsAreLoaded)
            {
                //await Task.Run(renameAction);
                renameAction();
            }
            else
            {

                RenameShownArchive_MakePreviewSleepRequest = true;
                bmwMakePreview.ThreadCount = 0;
                Program.SetPriority(ProcessPriorityClass.Normal);
                BackgroundMultiWorker.EachRunWorkerCompletedEventHandler eh = null;

                eh = (sender, e) =>
                {
                    if (bmwMakePreview.CurrentThreadCount <= 1) // 自分はカウントされていて良い
                    {
                        //await Task.Run(renameAction);
                        renameAction();

                        bmwMakePreview.ThreadCount = tempThreadCount;
                        Program.SetPriority(priority);
                        RenameShownArchive_MakePreviewSleepRequest = false;
                        bmwMakePreview.EachRunWorkerCompleted -= eh;
                    }
                };

                bmwMakePreview.EachRunWorkerCompleted += eh;
            }
        }

        private void swapPathAndNameInSorBookmarkUndoBuff(string oldPath, string newPath, bool needToSaveBookmark)
        {
            swapPathAndNameInSorBookmarkUndoBuff(new string[1] { oldPath }, new string[1] { newPath }, needToSaveBookmark);
        }
        private void swapPathAndNameInSorBookmarkUndoBuff(string[] oldPathArray, string[] newPathArray, bool needToSaveBookmark)
        {
            int count;
            if (oldPathArray == null || newPathArray == null || (count = oldPathArray.Length) != newPathArray.Length) return;

            Exception innerCurrentEditException = null;

            try
            {
                Invoke(((MethodInvoker)(() =>
                {

                    var current = currentLocation;

                    // 現在の場所
                    var indexOfCurrentLocation = Array.IndexOf(oldPathArray, current);
                    if (indexOfCurrentLocation >= 0)
                    {
                        current = currentLocation = newPathArray[indexOfCurrentLocation];
                    }

                    // キャッシュ
                    var tc = thumbnailCache;
                    if (tc != null && tc != GPSizeThumbnail.AlternateDataStream)
                    {
                        for (var i = 0; i < count; i++)
                        {
                            GPSizeThumbnail.TryMove(tc, oldPathArray[i], newPathArray[i]);
                        }
                    }

                    // ブックマーク
                    var changedBookmark = false;
                    var changedBookmarkDisplayedName = false;
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (bookmark != null && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None) // セパレーターなら無視される
                        {
                            var sb = bookmark.SimpleBookmark;
                            var i = Array.IndexOf(oldPathArray, sb.Location);
                            if (i >= 0)
                            {
                                changedBookmark = true;
                                sb.Location = newPathArray[i];
                                if (bookmark.SimpleBookmark.Alias == null) changedBookmarkDisplayedName = true;
                            }
                        }
                    }
                    if (changedBookmark)
                    {
                        if (changedBookmarkDisplayedName)
                        {
                            dgvDirectoryList.Invalidate();
                        }
                        if (needToSaveBookmark)
                        {
                            saveBookmarkToIni_bookmarkChanged = true;
                            saveBookmarkToConfig();
                        }
                    }


                    // ブックマーク内と現在開いている SOR 及び履歴の中身
                    var renameTargetsSorSet = new HashSet<string>(from bmk in getVirtualFoldersInBookmarks() select bmk.SimpleBookmark.Location); // getVirtual は null を含むものは返さない
                    renameTargetsSorSet.Add(Program.HistorySorPath);
                    if (!CreatingZipPathArray && InVirtualDirectory && (current?.ToUpper().EndsWith(".SOR") == true)) // Virtual の中でも特に SOR のみ
                    {
                        renameTargetsSorSet.Add(current);
                    }
                    foreach (var renameTarget in renameTargetsSorSet)
                    {
                        try
                        {
                            VirtualFolder.ReplaceBookmarkData(renameTarget, oldPathArray, newPathArray);
                        }
                        catch (Exception e)
                        {
                            if (current == renameTarget && innerCurrentEditException == null) innerCurrentEditException = e;
                        }
                    }

                    // ブックマーク内と現在開いている KDD の中身
                    var renameTargetsKdkSet = new HashSet<string>(from bmk in getSmartFolderInBookmarks() select bmk.SimpleBookmark.Location); // getVirtual は null を含むものは返さない
                    if (!CreatingZipPathArray && InSmartDirectory && current != null && SmartFolder.IsSmartFolderPath(current))
                    {
                        renameTargetsKdkSet.Add(current);
                    }
                    var oldPathInLower = (from path in oldPathArray select path.ToLower()).ToArray();
                    foreach (var renameTarget in renameTargetsKdkSet)
                    {
                        try
                        {
                            var smartFolder = new SmartFolder(renameTarget);
                            var items = smartFolder.Items;
                            if (items == null) continue;
                            var changed = false;
                            foreach (var item in smartFolder.Items)
                            {
                                var path = item.Path;
                                if (path == null) continue;
                                var idx = Array.IndexOf(oldPathInLower, path.ToLower());
                                if (idx < 0) continue;
                                changed = true;
                                item.Path = newPathArray[idx];
                            }
                            if (changed)
                            {
                                smartFolder.SaveToFile(renameTarget);
                            }
                        }
                        catch (Exception e)
                        {
                            if (current == renameTarget && innerCurrentEditException == null) innerCurrentEditException = e;
                        }
                    }

                    // UndoBuffer
                    foreach (var b in undoBuffer)
                    {
                        var i = Array.IndexOf(oldPathArray, b.Location);
                        if (i >= 0) b.Location = newPathArray[i];

                        var bSelectedName = b.SelectedFileName;
                        if (!string.IsNullOrEmpty(bSelectedName))
                        {
                            for (var j = 0; j < count; j++)
                            {
                                if (oldPathArray[j].EndsWith(bSelectedName))
                                {
                                    b.SelectedFileName = newPathArray[j].Substring(oldPathArray[j].Length - bSelectedName.Length);
                                    break;
                                }
                            }
                        }
                    }
                })));
            }
            catch (ObjectDisposedException) { }


            if (innerCurrentEditException != null) throw innerCurrentEditException;
        }

        /*
        private void swapPathAndNameInSorBookmarkUndoBuff(string[] oldPathArray, string[] newPathArray, bool needToSaveBookmark)
        {
            int count;
            if (oldPathArray == null || newPathArray == null || (count = oldPathArray.Length) != newPathArray.Length) return;
            
            // SOR
            var renameTargetsSorSet = new HashSet<string>(from bmk in getVirtualFoldersInBookmarks() select bmk.SimpleBookmark.Location); // getVirtual は null を含むものは返さない
            renameTargetsSorSet.Add(Program.HistorySorPath);
            var current = currentLocation;
            if (!CreatingZipPathArray && (current?.ToUpper().EndsWith(".SOR") == true)) // Virtual の中でも特に SOR のみ
            {
                renameTargetsSorSet.Add(current);
            }
            foreach (var renameTarget in renameTargetsSorSet)
            {
                try
                {
                    VirtualFolder.ReplaceBookmarkData(renameTarget, oldPathArray, newPathArray);
                }
                catch
                {
                    if (current == renameTarget) throw;
                }
            }

            // ブックマーク
            var changedBookmark = false;
            var changedBookmarkDisplayedName = false;
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                if (bookmark != null)
                {
                    var sb = bookmark.SimpleBookmark;
                    var i = Array.IndexOf(oldPathArray, sb.Location);
                    if(i >= 0)
                    {
                        changedBookmark = true;
                        sb.Location = newPathArray[i];
                        if (bookmark.SimpleBookmark.Alias == null) changedBookmarkDisplayedName = true;
                    }
                }
            }
            if(changedBookmark)
            {
                if (changedBookmarkDisplayedName)
                {
                    dgvDirectoryList.Invalidate();
                }
                if (needToSaveBookmark)
                {
                    saveBookmarkToIni_bookmarkChanged = true;
                    saveBookmarkToConfig();
                }
            }

            // UndoBuffer
            foreach (var b in undoBuffer)
            {
                var i = Array.IndexOf(oldPathArray, b.Location);
                if (i >= 0) b.Location = newPathArray[i];
                
                var bSelectedName = b.SelectedFileName;
                if (!string.IsNullOrEmpty(bSelectedName))
                {
                    for (var j = 0; j < count; j++)
                    {
                        if (oldPathArray[j].EndsWith(bSelectedName))
                        {
                            b.SelectedFileName = newPathArray[j].Substring(oldPathArray[j].Length - bSelectedName.Length);
                            break;
                        }
                    }
                }
            }

            // 現在の場所
            var indexOfCurrentLocation = Array.IndexOf(oldPathArray, current);
            if (indexOfCurrentLocation >= 0)
            {
                currentLocation = newPathArray[indexOfCurrentLocation];
            }

        }*/

        private string getRelativePath(string fullPath, string oldRelativePath)
        {
            return getRelativePath(fullPath, oldRelativePath.EndsWith(Path.DirectorySeparatorChar.ToString()));
        }

        private string getRelativePath(string fullPath, bool isDir)
        {
            string result = null;
            var cl = currentLocation;
            if (fullPath.Length >= cl.Length + 2 && fullPath.StartsWith(cl))
            {
                var sp = fullPath[cl.Length];
                if (sp == Path.DirectorySeparatorChar || sp == Path.AltDirectorySeparatorChar)
                {
                    result = fullPath.Substring(cl.Length + 1);
                }
            }
            if (result == null) result = fullPath.Substring(fullPath.LastIndexOfAny(new char[2] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar }) + 1);
            return result + (isDir ? Path.DirectorySeparatorChar.ToString() : "");
        }


        private void propertiesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenSelectedProperties();
        }

        private void OpenSelectedProperties()
        {
            var selectedIndex = tvCatalog.SelectedIndex;
            if (selectedIndex < 0 || ZipPathArray == null || ZipPathArray.Length <= selectedIndex)
            {
                return;
            }
            var path = ZipPathArray[selectedIndex];

            AllowFullpower = false;

            string newPath;
            using (var pform = new ArchivePropertiesForm(path, FileCountArray[selectedIndex], ArchivesInArchiveMode, ImageInfoArray[selectedIndex], MovieInfoArray[selectedIndex]))
            {
                pform.ShowDialog(this);
                newPath = pform.FilePath;
            }

            RenameShownArchive(selectedIndex, path, newPath);

            AllowFullpower = true;
        }

        private void startToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            try
            {
                openHistoryToolStripMenuItem.Enabled = File.Exists(Program.HistorySorPath);
            }
            catch
            {
                openHistoryToolStripMenuItem.Enabled = false;
            }
            newFolderToolStripMenuItem.Enabled = !CreatingZipPathArray && InRealDirectory;
            AllowFullpower = false;
        }

        private void startToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {
            // ショートカットキーで使用できるように
            openHistoryToolStripMenuItem.Enabled = true;
            newFolderToolStripMenuItem.Enabled = true;

            AllowFullpower = true;
        }


        private void thumbnailSizeToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            AllowFullpower = false;
        }


        private void thumbnailSizeToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {
            AllowFullpower = true;
        }

        private void viewToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            AllowFullpower = false;
        }

        private void viewToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {
            AllowFullpower = true;
        }

        private void optionToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {
            AllowFullpower = true;
        }

        private void optionToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            AllowFullpower = false;
        }

        private void cmsRightClick_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
            msSortBy.Stop = msFilter.Stop = msCatalog.Stop = msFileList.Stop = true;
        }

        private void cmsRightClick_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            //renameForTextBoxRatingTagPageSequence(noop: KeyboardShortcut.GetKeyState(Keys.Escape));
            renameForTextBoxRatingTagPageSequence(noop: cmsRightClick_Closing_CloseReason == ToolStripDropDownCloseReason.Keyboard);
            //MessageBox.Show(cmsRightClick_Closing_CloseReason.ToString());

            //msSortBy.Stop = msFilter.Stop = msCatalog.Stop = msFileList.Stop = false; // 直後の Opening と逆転することがあるので Closing で
            //AllowFullpower = true; // 直後の Opening と逆転することがあるので Closing で
        }

        private void cmsLocationCommands_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
        }

        private void cmsLocationCommands_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            AllowFullpower = true;
        }

        private void cmsFilterCommands_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
        }

        private void cmsFilterCommands_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            AllowFullpower = true;
        }

        private void cmsFileListHeader_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
        }

        private void cmsFileListHeader_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            AllowFullpower = true;
        }

        private void cmsDirectoryList_Opening(object sender, CancelEventArgs e)
        {
            msDirectoryList.Stop = true;
            AllowFullpower = false;
        }

        private void cmsDirectoryList_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            msDirectoryList.Stop = false;
            AllowFullpower = true;
        }

        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;
            Program.ShowAbout();
            AllowFullpower = true;
        }

        private void openDirectoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            var path = Program.ItsSelfOrExistingParentDirectory(zabLocation.Text);
            if (!string.IsNullOrEmpty(path))
            {
                folderBrowserDialog.SelectedPath = path;
            }
            if (folderBrowserDialog.ShowDialog(this) == DialogResult.OK)
            {
                zabLocation.Text = folderBrowserDialog.SelectedPath;
                MakePreview();
            }

            AllowFullpower = true;
        }


        private void openFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            var path = Program.ItsSelfOrExistingParentDirectory(zabLocation.Text);
            if (!string.IsNullOrEmpty(path))
            {
                openFileDialog.InitialDirectory = path;
            }
            openFileDialog.FileName = "";

            PackedImageLoader.CheckSevenZipExistence(this);
            var supportedArchiveFileFilter = PackedImageLoader.GetSupportedArchiveFileFilter();

            if (MovieThumbnailLoader.ffmpegExists())
            {
                openFileDialog.Filter =
                    Message.AllSupportedFiles + $"|*.sor;*.{SmartFolder.ExtensionWithoutPeriodInLower};" +
                        supportedArchiveFileFilter + ";" + MovieThumbnailLoader.SupportedVideoFileFilter + "|" +
                    Message.VirtualFolder + "|*.sor|" +
                    Message.SmartFolder + $"|*.{SmartFolder.ExtensionWithoutPeriodInLower}|" +
                    Message.ArchiveFilesPdfFiles + "|" + supportedArchiveFileFilter + "|" +
                    Message.VideoFiles + "|" + MovieThumbnailLoader.SupportedVideoFileFilter;
            }
            else
            {
                openFileDialog.Filter =
                    Message.AllSupportedFiles + $"|*.sor;*.{SmartFolder.ExtensionWithoutPeriodInLower};" + supportedArchiveFileFilter + "|" +
                    Message.VirtualFolder + "|*.sor|" +
                    Message.SmartFolder + $"|*.{SmartFolder.ExtensionWithoutPeriodInLower}|" +
                    Message.ArchiveFilesPdfFiles + "|" + supportedArchiveFileFilter + "|" +
                    Message.VideoFilesRequireFfmpeg + "|;"; // 最後の ; を省略するとすべてのファイルが表示されてしまう
            }

            if (openFileDialog.ShowDialog(this) == DialogResult.OK)
            {
                zabLocation.Text = openFileDialog.FileName;
                MakePreview();
                //OpenInDefaultViewer(ApplicationProviderUser.OpenFileDialog, openFileDialog.FileName);
            }

            AllowFullpower = true;
        }


        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Close();
        }

        private void reloadAllThumbnailsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            //MakePreview(tvCatalog.ScrollBarPercentage, tvCatalog.SelectedIndex);
            UpdatePreview();
        }


        /*
        private void openInBuiltinViewerToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenSelectedArchiveInBuiltInViewer();
        }

        private void openInExternalViewerToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenSelectedArchiveInExternalViewer();
        */

        /*
    private void openInAssociationToolStripMenuItem_Click(object sender, EventArgs e)
    {
        var selectedIndex = tvCatalog.SelectedIndex;
        if (selectedIndex >= 0)
        {
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray != null && selectedIndex < ZipPathArray.Length)
                {
                    try
                    {
                        Process.Start(ZipPathArray[selectedIndex]);
                    }
                    catch (Exception error)
                    {
                        Program.AlertError(error);
                    }
                }
            }
        }
    }
    */

        private void editLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cbLocation.Focus();
            cbLocation.DroppedDown = true;
        }

        private void editFilterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cbFilter.Focus();
            cbFilter.DroppedDown = true;
        }

        private void fileListToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
        {
            var ckd = fileListToolStripMenuItem.Checked;
            var ckd2 = thumbnailListToolStripMenuItem.Checked;
            var firstCkd = ckd && dgvFileList.FirstDisplayedScrollingRowIndex < 0;
            var temp = selectionSynchronizing;
            selectionSynchronizing = true;
            splRight.Visible = ckd && ckd2;
            pnlRight.Visible = ckd;
            selectionSynchronizing = temp;
            if (ckd)
            {
                dgvFileList.Focus();
            }

            if (ckd && ckd2)
            {
                pnlRight.Dock = getFileListDock();
            }

            if (firstCkd) // 現実装では分岐の必要なし
            {
                selectionSynchronizingFromThumbnailToFileList();
            }
            else
            {
                selectionSynchronizingFromThumbnailToFileList();
            }
            if (!ckd && !ckd2)
            {
                thumbnailListToolStripMenuItem.Checked = true;
            }
            else
            {
                setTagfilterLocationIfRatingFilterVisibleChanged();
            }
        }

        private void thumbnailListToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
        {
            var ckd = thumbnailListToolStripMenuItem.Checked;
            var ckd2 = fileListToolStripMenuItem.Checked;

            if (ckd) setFileListWidthWithoutSettingWidth(pnlRight_NormalWidth);

            pnlCenter.Visible = ckd;
            splRight.Visible = ckd && ckd2;

            //pnlRight.Dock = ckd ? DockStyle.Right : DockStyle.Fill;

            if (ckd)
            {
                if (ckd2)
                {
                    pnlRight.Dock = getFileListDock();
                }
            }
            else
            {
                pnlRight.Dock = DockStyle.Fill;
            }

            /*
            if (ckd && ckd2)
            {
                pnlRight.Dock = getFileListDock();
            }
            */

            if (WindowState != FormWindowState.Minimized) setMainPanelWidth();

            if (ckd)
            {
                tvCatalog.Focus();
            }

            if (!ckd && !ckd2)
            {
                fileListToolStripMenuItem.Checked = true;
            }
            else
            {
                setTagfilterLocationIfRatingFilterVisibleChanged();
            }
        }

        /*
        private void pnlCenter_VisibleChanged(object sender, EventArgs e)
        {
            return;
            if(pnlCenter.Visible)
            {
                if(pnlRight.Visible)
                {
                    pnlRight.Dock = getFileListDock();
                }
            }
            else
            {
                pnlRight.Dock = DockStyle.Fill;
            }
        }

        private void pnlRight_VisibleChanged(object sender, EventArgs e)
        {
            return;
            if (pnlCenter.Visible && pnlRight.Visible)
            {
                pnlRight.Dock = getFileListDock();
            }
        }
        */

        int pnlBookmarkNoFillHeight;
        private void bookmarkToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
        {
            if (bookmarkToolStripMenuItem.Checked)
            {
                pnlBookmark.Visible = pnlLeft.Visible = splLeft.Visible = true;
                if (folderTreeToolStripMenuItem.Checked)
                {
                    pnlBookmark.Dock = DockStyle.Top;
                    splBookmark.Visible = true;
                    pnlBookmark.Height = pnlBookmarkNoFillHeight;
                }
                else
                {
                    splBookmark.Visible = false;
                    if (pnlBookmark.Dock != DockStyle.Fill)
                    {
                        pnlBookmarkNoFillHeight = pnlBookmark.Height;
                        pnlBookmark.Dock = DockStyle.Fill;
                    }
                }
                fixLeftSplitter();
                dgvDirectoryList.Focus();
            }
            else
            {
                pnlBookmark.Visible = splBookmark.Visible = false;
                pnlLeft.Visible = splLeft.Visible = folderTreeToolStripMenuItem.Checked;
            }
        }

        private void folderTreeToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
        {
            setFolderTreeVisible(silent: false);
            if (folderTreeToolStripMenuItem.Checked)
            {
                if (SynchroFromBarToTree)
                {
                    setToTree(currentLocation, CollapseOthersWhenSynchronizing);
                }
                explorerTreeView.TreeViewWnd.Focus();
            }
        }

        private void setFolderTreeVisible(bool silent)
        {
            if (folderTreeToolStripMenuItem.Checked)
            {
                pnlDirectoryTree.Visible = pnlLeft.Visible = splLeft.Visible = true;
                if (bookmarkToolStripMenuItem.Checked)
                {
                    pnlBookmark.Dock = DockStyle.Top;
                    splBookmark.Visible = true;
                    pnlBookmark.Height = pnlBookmarkNoFillHeight;
                }
                else
                {
                    splBookmark.Visible = false;
                }
                fixLeftSplitter();

                if (!explorerTreeView.Initialized)
                {
                    // MessageBox などでないと効果なし
                    //await Task.Run(() => Invoke((MethodInvoker)(() => explorerTreeView.Initialize())));

                    // 高速化前
                    //Application.DoEvents();
                    //explorerTreeView.Initialize(IsShown ? Message.NowLoading + "..." : null);

                    // 十分に高速化したので同期的で良い
                    explorerTreeView.Initialize(null);

                    //await Task.Delay(1);
                    //explorerTreeView.Initialize(); // await のコストを考えて一度しか呼び出さないが二回以上呼び出しても無視されるだけ
                }
            }
            else
            {
                pnlDirectoryTree.Visible = splBookmark.Visible = false;
                if (bookmarkToolStripMenuItem.Checked)
                {
                    if (pnlBookmark.Dock != DockStyle.Fill)
                    {
                        pnlBookmarkNoFillHeight = pnlBookmark.Height;
                        pnlBookmark.Dock = DockStyle.Fill;
                    }
                }
                else
                {
                    pnlLeft.Visible = splLeft.Visible = false;
                }
            }
        }

        private void pnlLeft_SizeChanged(object sender, EventArgs e)
        {
            fixLeftSplitter();
        }

        private void fixLeftSplitter()
        {
            if (WindowState != FormWindowState.Minimized && pnlBookmark.Visible &&
                pnlDirectoryTree.Visible && pnlDirectoryTree.Height < splBookmark.MinExtra)
            {
                pnlBookmark.Height = Math.Max(splBookmark.MinSize, pnlLeft.Height - splBookmark.MinExtra - splBookmark.Height);
            }
        }

        private void ratingHeaderRightClickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcRating.Visible = !tbcRating.Visible;
            setTagfilterLocationIfRatingFilterVisibleChanged();
        }

        private void iconToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcIcon.Visible = !tbcIcon.Visible;
        }

        private void pageToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcPage.Visible = !tbcPage.Visible;
        }

        private void dateCreatedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcCreateTime.Visible = !tbcCreateTime.Visible;
        }

        private void accessTimeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcAccessTime.Visible = !tbcAccessTime.Visible;
        }

        private void writeTimeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcWriteTime.Visible = !tbcWriteTime.Visible;
        }

        private void sizeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcSize.Visible = !tbcSize.Visible;
        }

        private void resolutionToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcResolution.Visible = !tbcResolution.Visible;
        }

        private void ratioToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcRatio.Visible = !tbcRatio.Visible;
        }

        private void widthToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcWidth.Visible = !tbcWidth.Visible;
        }

        private void heightToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcHeight.Visible = !tbcHeight.Visible;
        }

        private void lengthToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcLength.Visible = !tbcLength.Visible;
        }

        private void fPSToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcFPS.Visible = !tbcFPS.Visible;
        }

        private void dgvFileList_KeyDown(object sender, KeyEventArgs e)
        {
            var mk = ModifierKeys;
            if (e.KeyCode == Keys.Enter)
            {
                OpenSelectedArchiveInDefaultViewer(ApplicationProviderUser.EnterKey, null);
                e.Handled = true;
                LatestControledControl = sender as Control;
            }
            else if (e.KeyCode == Keys.F2)
            {
                renameToolStripMenuItem_Click(sender, e);
                LatestControledControl = sender as Control;
            }
            else if (e.KeyCode == Keys.Left || e.KeyCode == Keys.Right || e.KeyCode == Keys.Up || e.KeyCode == Keys.Down)
            {
                LatestControledControl = sender as Control;
            }
            else if (e.KeyCode == Keys.Home)
            {
                LatestControledControl = dgvFileList;
                if (SelectItem(0, dgvFileList.CurrentRow?.Index ?? -1, mk))
                {
                    e.Handled = true;
                    if (tvCatalog.SelectedIndicesCount > 1) dgvFileList.FirstDisplayedScrollingRowIndex = 0; // 単数選択なら自動的にスクロールされる
                    else tvCatalog.ScrollBarPercentage = 0; // 単数の場合のみサムネイル側もスクロール
                }
            }
            else if (e.KeyCode == Keys.End)
            {
                LatestControledControl = dgvFileList;
                if (SelectItem(-1, dgvFileList.CurrentRow?.Index ?? -1, mk))
                {
                    e.Handled = true;
                    if (tvCatalog.SelectedIndicesCount > 1) dgvFileList.FirstDisplayedScrollingRowIndex = dgvFileList.Rows.Count - 1;
                    else tvCatalog.ScrollBarPercentage = 100;
                }
            }
            /*
            else if (e.KeyCode == Keys.Delete)
            {
                //deleteonlyForListFileToolStripMenuItem_Click(sender, e);
                //deleteSelectedItems(mk);
                deleteKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.X)
            {
                //cutSelection(mk);
                CutKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.C)
            {
                //copySelection(mk);
                CopyKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.V)
            {
                //pasteToCurrentLocation();
                PasteKeyAction(mk);
            }
            else if (e.KeyCode == Keys.Apps)
            {
                cmsRightClickPrepareAndShowForKeyOnFileList(onlyTag: false);
                LatestControledControl = sender as Control;
            }
            */
            else if (commonKeyAction(e, mk))
            {
                return;
            }
            else if (e.Alt)
            {
                e.Handled = true;
            }
        }

        private bool SelectItem(int showIndex, int currentShowIndex, Keys modifiedKeys)
        {
            if (CreatingZipPathArray) return false;
            var s2d = tvCatalog.ShowIndexToDataIndex;
            if (s2d == null) return false;
            var count = s2d.Length;
            if (count <= 0) return false;
            if (showIndex < 0) showIndex += count;
            if (showIndex < 0 || showIndex >= count) return false;
            if ((modifiedKeys & Keys.Shift) != Keys.Shift) currentShowIndex = -1;
            if (currentShowIndex < 0 || currentShowIndex >= count || currentShowIndex == showIndex)
            {
                tvCatalog.SelectedIndex = s2d[showIndex];
            }
            else
            {
                var selectedShowTable = new bool[count];
                var alreadySelected = tvCatalog.SelectedIndices;
                var d2s = tvCatalog.DataIndexToShowIndex;
                var selectedCount = alreadySelected.Length;
                for (var i = 0; i < alreadySelected.Length; i++) selectedShowTable[d2s[alreadySelected[i]]] = true;
                int start, stop;
                if (showIndex < currentShowIndex)
                {
                    start = showIndex;
                    stop = currentShowIndex + 1;
                }
                else
                {
                    start = currentShowIndex;
                    stop = showIndex + 1;
                }
                for (var i = start; i < stop; i++)
                {
                    if (!selectedShowTable[i])
                    {
                        selectedShowTable[i] = true;
                        selectedCount++;
                    }
                }
                var selectedIndices = new int[selectedCount];
                var k = 0;
                for (var i = 0; i < selectedShowTable.Length; i++)
                {
                    if (selectedShowTable[i])
                    {
                        selectedIndices[k++] = s2d[i];
                    }
                }
                tvCatalog.SelectedIndices = selectedIndices;
            }
            return true;
        }

        private void cmsRightClickPrepareAndShowForKeyOnFileList(bool onlyTag, Keys modifierKeys)
        {
            var mk = modifierKeys;
            //var mk = ModifierKeys;
            if (tvCatalog.SelectedIndicesCount > 0)
            {
                var selectedRow = dgvFileList_FirstDisplayedSelectedRow();
                if (selectedRow == null) return;
                var rect = dgvFileList.GetRowDisplayRectangle(selectedRow.Index, cutOverflow: true);
                var m2 = Math.Min(rect.Height, rect.Width) / 2;
                var p = dgvFileList.PointToScreen(new Point(rect.X + m2, rect.Y + m2));

                //cmsRightClickPrepareAndShow(p, onlyTag);
                if (onlyTag)
                {
                    cmsRightClickPrepareAndShow_(p, true);
                }
                else
                {
                    rightClickContextMenuPrepareAndShow(p, mk);
                    /*
                    if (RightClickContextMenu == CatalogFormConfigConetxtMenu.ZipPla)
                    {
                        cmsRightClickPrepareAndShow_(p, false);
                    }
                    else if (RightClickContextMenu == CatalogFormConfigConetxtMenu.Explorer)
                    {
                        explorerContextMenuPrepareAndShow(p);
                    }
                    else if (ControlRightClickContextMenu == CatalogFormConfigConetxtMenu.ZipPla)
                    {
                        cmsRightClickPrepareAndShow_(p, false);
                    }
                    else if (ControlRightClickContextMenu == CatalogFormConfigConetxtMenu.Explorer)
                    {
                        explorerContextMenuPrepareAndShow(p);
                    }
                    */
                }
            }
            else if (!onlyTag && dgvFileList.Visible && (RightClickContextMenu != CatalogFormConetxtMenu.Tag))
            {
                var p = dgvFileList.PointToScreen(dgvFileList.Location);
                p.Y += dgvFileList.ColumnHeadersHeight;
                //cmsRightClickPrepareAndShow_(p);

                rightClickContextMenuPrepareAndShow(p, mk);
            }
        }

        private DataGridViewRow dgvFileList_FirstDisplayedSelectedRow()
        {
            return getFirstDisplayedSelectedRow(dgvFileList);
        }

        private static DataGridViewRow getFirstDisplayedSelectedRow(DataGridView dataGridView)
        {
            try
            {
                var start = dataGridView.FirstDisplayedScrollingRowIndex;
                var stop = start + dataGridView.DisplayedRowCount(includePartialRow: true);
                for (var i = start; i < stop; i++)
                {
                    if (dataGridView.Rows[i].Selected) return dataGridView.Rows[i];
                }
            }
            catch
            {
            }
            return null;
        }

        string renameToolStripMenuItem_Click_OldName = null;
        string renameToolStripMenuItem_Click_OldPath = null;
        int renameToolStripMenuItem_Click_Index = -1;
        private void renameToolStripMenuItem_Click(object sender, EventArgs e)
        {
            //if (!dgvFileList.Focused) return;
            if (!fileListToolStripMenuItem.Checked || !dgvFileList.Visible) return;

            if (renameToolStripMenuItem_Click_OldName != null) return;
            if (CreatingZipPathArray) return;

            try
            {
                if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;
            }
            catch
            {
                return;
            }

            if (!dgvFileList.Focused) dgvFileList.Focus();

            var selectedIndex = tvCatalog.SelectedIndex;
            if (selectedIndex < 0) return;

            string currentPath;
            bool isDirectory;
            lock (ZipPathArrayLocker)
            {
                if (ZipPathArray == null || ZipPathArray.Length <= selectedIndex) return;
                currentPath = ZipPathArray[selectedIndex];
                isDirectory = ZipNameArray[selectedIndex].EndsWith(Path.DirectorySeparatorChar.ToString());
            }
            if (isDirectory && !Directory.Exists(currentPath) || !isDirectory && !File.Exists(currentPath))
            {
                var exception = new FileNotFoundException(null, currentPath);
                MessageBox.Show(this, exception.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            var d2s = tvCatalog.DataIndexToShowIndex;
            if (selectedIndex >= d2s.Length) return;
            var showIndex = d2s[selectedIndex];
            var rows = dgvFileList.Rows;
            if (showIndex < 0 || showIndex >= rows.Count) return;
            var cell = rows[showIndex].Cells[tbcFileName.Index];

            var name = cell.Value.ToString();
            cell.Value = getBaseName(name);

            renameToolStripMenuItem_Click_OldName = name;
            renameToolStripMenuItem_Click_Index = selectedIndex;
            renameToolStripMenuItem_Click_OldPath = currentPath;

            dgvFileList.CurrentCell = cell;
            dgvFileList.ReadOnly = false;
            dgvFileList.BeginEdit(true);
        }

        private string getBaseName(string name)
        {
            if (string.IsNullOrEmpty(name)) return name;
            if (name.Last() == Path.DirectorySeparatorChar)
            {
                return name.Substring(0, name.Length - 1);
            }
            else
            {
                try
                {
                    var ext = Path.GetExtension(name);
                    if (!string.IsNullOrEmpty(ext))
                    {
                        return name.Substring(0, name.Length - ext.Length);
                    }
                }
                catch { }
                return name;
            }
        }

        private bool dgvFileList_CellEndEdit_Edited = false;
        private void dgvFileList_CellEndEdit(object sender, DataGridViewCellEventArgs e)
        {
            if (!dgvFileList.ReadOnly)
            {
                dgvFileList.ReadOnly = true;

                if (!dgvFileList_CellEndEdit_Edited)
                {
                    var d2s = tvCatalog.DataIndexToShowIndex;
                    if (renameToolStripMenuItem_Click_Index < d2s.Length)
                    {
                        var showIndex = d2s[renameToolStripMenuItem_Click_Index];
                        if (showIndex >= 0)
                        {
                            var rows = dgvFileList.Rows;
                            if (showIndex < rows.Count)
                            {
                                rows[showIndex].Cells[tbcFileName.Index].Value = renameToolStripMenuItem_Click_OldName;
                            }
                        }
                    }
                }
            }
            dgvFileList_CellEndEdit_Edited = false;
            renameToolStripMenuItem_Click_Index = -1;
            renameToolStripMenuItem_Click_OldName = null;
            renameToolStripMenuItem_Click_OldPath = null;
        }

        private void dgvFileList_CellParsing(object sender, DataGridViewCellParsingEventArgs e)
        {
            DataGridView dgv = (DataGridView)sender;
            if (e.RowIndex == dgv.NewRowIndex || !dgv.IsCurrentCellDirty)
            {
                return;
            }

            var oldName = renameToolStripMenuItem_Click_OldName;
            var selectedIndex = renameToolStripMenuItem_Click_Index;
            var oldPath = renameToolStripMenuItem_Click_OldPath;

            var isDirectrory = oldName.EndsWith(Path.DirectorySeparatorChar.ToString());
            var newName = e.Value.ToString();

            e.Value = oldName;

            try
            {
                newName = newName + (isDirectrory ? "" : Path.GetExtension(oldPath));
                var newPath = Path.Combine(oldPath.Substring(0, oldPath.Length - oldName.Length), newName);
                Program.FileSaveCheckWithException(Path.GetDirectoryName(oldPath), newName);
                RenameShownArchive(selectedIndex, oldPath, newPath);
                e.Value = isDirectrory ? newName + Path.DirectorySeparatorChar : newName;
                e.ParsingApplied = true;
                dgvFileList_CellEndEdit_Edited = true;
            }
            catch (Exception error)
            {
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void openHistoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            zabLocation.Text = Program.HistorySorPath;
            MakePreview();
        }

        /*
        private void ratingInFileListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcRating.Visible = !tbcRating.Visible;
        }

        private void pageInFileListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcPage.Visible = !tbcPage.Visible;
        }

        private void accessTimeInFileListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcAccessTime.Visible = !tbcAccessTime.Visible;
        }

        private void writeTimeInFileListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            tbcWriteTime.Visible = !tbcWriteTime.Visible;
        }
        */


        private void deleteonlyForListFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            deleteSelectedItems(ModifierKeys);
        }

        private async void deleteSelectedItems(Keys modifierKeys)
        {
            var current = currentLocation;
            if (current == null || CreatingZipPathArray) return;
            if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;


            var selectedIndices = tvCatalog.SelectedIndices;
            if (selectedIndices != null && selectedIndices.Length > 0)
            {
                var isSor = InVirtualDirectory;
                if (!isSor && !InSmartDirectory)
                {
                    try
                    {
                        if (!Directory.Exists(current))
                        {
                            return;
                        }
                    }
                    catch
                    {
                        return;
                    }
                }


                string[] deleteList;
                //
                /*
                var d2s = tvCatalog.DataIndexToShowIndex;
                int indexWithMaxShowIndex = -1;
                int maxShowIndex = -1;
                if (d2s != null)
                {
                    foreach (var index in selectedIndices)
                    {
                        if(index >= d2s.Length)
                        {
                            maxShowIndex = -1;
                            break;
                        }
                        var showIndex = d2s[index];
                        if(showIndex > maxShowIndex)
                        {
                            maxShowIndex = showIndex;
                            indexWithMaxShowIndex = index;
                        }
                    }
                }
                */
                int[] d2s;
                lock (ZipPathArrayLocker)
                {
                    if (ZipMaskArray == null) return;
                    d2s = tvCatalog.DataIndexToShowIndex;
                    if (d2s == null) return;
                    var indexBound = Math.Min(ZipMaskArray.Length, d2s.Length);
                    deleteList = new string[selectedIndices.Length];
                    var showIndexArray = new int[selectedIndices.Length];
                    for (var k = 0; k < selectedIndices.Length; k++)
                    {
                        var index = selectedIndices[k];
                        if (index < 0 || index >= indexBound) return;
                        var path = ZipPathArray[index]; if (path == null) return;
                        var name = ZipNameArray[index]; if (name == null) return;
                        /*
                        ZipMaskArray[index] = false;
                        ZipPathArray[index] = null;
                        ZipNameArray[index] = null;
                        tvCatalog[index] = null; // これで Dispose される
                        */
                        deleteList[k] = path;
                        showIndexArray[k] = d2s[index];
                        //if (!isSor) isDirList.Add(name.EndsWith(Path.DirectorySeparatorChar.ToString()));
                    }
                    var sorter = Enumerable.Range(0, deleteList.Length).OrderBy(i => showIndexArray[i]).ToArray();
                    Arrange(deleteList, sorter);
                    Arrange(selectedIndices, sorter);
                    //deleteList.Sort()
                    /*
                    var sp = tvCatalog.ScrollBarPercentage;
                    tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex);
                    tvCatalog.ScrollBarPercentage = sp;
                    setFileListFromThumbnailViewer(tryToKeepScroll: true);
                    */
                }

                var deleteFromDisk = false;
                if (isSor)
                {
                    if (!await showshowConfirmationDialogDialogIfIndicesAreMany(Message.DoYouRemoveFollowing1ItemsFromVirtualFolder, deleteList)) return;
                }
                else
                {
                    deleteFromDisk = (modifierKeys & Keys.Shift) == Keys.Shift;
                    if (!await showshowConfirmationDialogDialogAlways(deleteFromDisk ? Message.DoYouDeleteFollowing1ItemsPermanently : Message.DoYouSendFollowing1ItemsToRecycleBin, deleteList)) return;
                }

                var isDirList = isSor ? null : new List<bool>();
                // 削除の確認は出来ているので表示が変わっていても削除は行う
                lock (ZipPathArrayLocker)
                {
                    if (ZipMaskArray != null)
                    {
                        var leastIndex = int.MaxValue;

                        var fullBufCount = ZipMaskArray.Length;
                        var indexindex = -1;
                        foreach (var index in selectedIndices)
                        {
                            indexindex++;
                            if (index < 0 || index >= fullBufCount || index >= d2s.Length) break; // fullBufCount は d2s.Length より長い場合もある
                            var path = ZipPathArray[index]; if (path == null) break; if (deleteList[indexindex] != path) break;
                            var name = ZipNameArray[index]; if (name == null) break;
                            leastIndex = Math.Min(leastIndex, d2s[index]);
                            ZipMaskArray[index] = false;
                            ZipPathArray[index] = null;
                            ZipNameArray[index] = null;
                            tvCatalog[index] = null; // これで Dispose される
                            //deleteList.Add(path);
                            if (!isSor) isDirList.Add(name.EndsWith(Path.DirectorySeparatorChar.ToString()));
                        }
                        indexindex++;
                        if (indexindex == selectedIndices.Length && leastIndex >= 0 && leastIndex < int.MaxValue)
                        {
                            var sp = tvCatalog.ScrollBarPercentage;
                            var s2d = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex);
                            tvCatalog.ShowIndexToDataIndex = s2d;
                            tvCatalog.ScrollBarPercentage = sp;
                            leastIndex = Math.Min(leastIndex, s2d.Length - 1); // s2d がゼロなら -1
                            if (leastIndex >= 0) tvCatalog.FocusedIndex = s2d[leastIndex];
                            setFileListFromThumbnailViewer(tryToKeepScroll: true);
                        }
                    }
                }

                if (isSor)
                {

                    try
                    {
                        VirtualFolder.DeleteBookmarkData(current, deleteList);
                    }
                    catch { }
                }
                else
                {
                    /*
                    var r = MessageBox.Show(this, deleteFromDisk ? Message.DoYouDeleteSelectedItemsPermanently : Message.DoYouSendSelectedItemsToRecycleBin,
                        Message.Question, MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2);
                    if (r != DialogResult.OK) return;
                    */

                    var count = deleteList.Length;
                    //Exception exception = null;

                    StopLookAheadProcess();

                    var target = deleteFromDisk ? Microsoft.VisualBasic.FileIO.RecycleOption.DeletePermanently : Microsoft.VisualBasic.FileIO.RecycleOption.SendToRecycleBin;
                    var deleteSuccessedList = new List<string>();
                    for (var i = 0; i < count; i++)
                    {
                        var deletePath = deleteList[i];
                        try
                        {
                            if (isDirList[i])
                            {
                                Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory(deletePath,
                                    Microsoft.VisualBasic.FileIO.UIOption.OnlyErrorDialogs,
                                    target);
                            }
                            else
                            {
                                Microsoft.VisualBasic.FileIO.FileSystem.DeleteFile(deletePath,
                                    Microsoft.VisualBasic.FileIO.UIOption.OnlyErrorDialogs,
                                    target);
                            }
                            deleteSuccessedList.Add(deletePath);
                        }
                        catch//(Exception ex)
                        {
                            //MessageBox.Show(this, exception.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            MakePreview(tvCatalog.ScrollBarPercentage, tvCatalog.SelectedIndex);
                            break;
                        }
                    }


                    var renameTargetsSet = new HashSet<string>(from bmk in getVirtualFoldersInBookmarks() select bmk.SimpleBookmark.Location); // getVir... は null を含むものは返さない
                    renameTargetsSet.Add(Program.HistorySorPath);
                    foreach (var renameTarget in renameTargetsSet)
                    {
                        try
                        {
                            VirtualFolder.DeleteBookmarkData(renameTarget, deleteSuccessedList);
                        }
                        catch { }
                    }

                    PrepareLookAheadProcess();
                }
            }
        }

        bool StopLookAheadProcessByProgram = false;
        public void StopLookAheadProcess()
        {
            if (waitingProcess != null && !waitingProcess.HasExited)
            {
                var p = waitingProcess;
                waitingProcess = null;
                p.Kill(); // CloseWindow は隠れているプロセスには効かない。Close すると非同期であるにも関わらず内部で Dispose されてその後 WaitForExit できない。従って Kill が最善。
                p.WaitForExit();
                if (OpenWaitingProcess_Processing)
                {
                    StopLookAheadProcessByProgram = true;
                }
            }
        }

        private void addToNewListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            addSelectedToList(false, addToBookmark: true);
        }
        private void addSelectedToList(bool append, string sorPath = null, bool addToBookmark = false)
        {
            if (string.Compare(sorPath, Program.HistorySorPath, ignoreCase: true) == 0)
            {
                string[] pathArray;
                bool[] isDirArray;
                int[] pageArray;
                getSelectedPathArray(-1, out pathArray, out pageArray, out isDirArray);
                addToList(pathArray, append, pageArray: pageArray, sorPath: sorPath, addToBookmark: addToBookmark);
            }
            else
            {
                string[] pathArray;
                bool[] isDirArray;
                getSelectedPathArray(-1, out pathArray, out isDirArray);
                addToList(pathArray, append, pageArray: null, sorPath: sorPath, addToBookmark: addToBookmark);
            }

        }
        private void addToList(string[] addArray, bool append, int[] pageArray = null, string sorPath = null, bool addToBookmark = false)
        {
            if (addArray == null || addArray.Length <= 0) return;
            if (pageArray == null || pageArray.Length != addArray.Length)
            {
                pageArray = new int[addArray.Length];
                for (var i = 0; i < pageArray.Length; i++) pageArray[i] = -1;
            }
            var temp = AllowFullpower;
            try
            {
                if (sorPath == null)
                {
                    AllowFullpower = false;
                    addToNewListSaveFileDialog.FileName = "";
                    if (addToNewListSaveFileDialog.ShowDialog(this) == DialogResult.OK)
                    {
                        sorPath = addToNewListSaveFileDialog.FileName;
                        if (!append && File.Exists(sorPath)) File.Delete(sorPath);
                    }
                }
                if (sorPath != null)
                {
                    VirtualFolder.AddBookmarkData(sorPath, addArray, pageArray);
                    if (addToBookmark)
                    {
                        addCatalogBookmarkToList(currentConditionToColoredBookmark(currentProfileColor, sorPath));
                    }

                    // addToBookmark == false は既に存在することを表す。その場合も表示は行う
                    bookmarkToolStripMenuItem.Checked = true;
                    var rowIndexBound = dgvDirectoryList.Rows.Count - 1;
                    for (var i = 0; i <= rowIndexBound; i++) dgvDirectoryList.Rows[i].Selected = i == rowIndexBound;
                    saveBookmarkToIni_bookmarkChanged = true;
                    saveBookmarkToConfig();
                }
            }
            catch (Exception error)
            {
#if DEBUG
                MessageBox.Show(this, error.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
            }
            finally
            {
                AllowFullpower = temp;
            }
        }

        private void removeFromHistoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            removeSelectedFromHistory();
        }

        private void removeSelectedFromHistory()
        {
            string[] pathArray;
            bool[] isDirArray;
            int[] dummy;
            getSelectedPathArray(-1, out pathArray, out dummy, out isDirArray, pageReset: true);
            removeSelectedFromList(pathArray, Program.HistorySorPath);
        }
        private void removeSelectedFromList(string[] removeArray, string sorPath)
        {
            if (removeArray == null || removeArray.Length <= 0) return;
            var temp = AllowFullpower;
            try
            {
                if (sorPath != null)
                {
                    VirtualFolder.DeleteBookmarkData(sorPath, removeArray);
                }
            }
            catch (Exception error)
            {
#if DEBUG
                MessageBox.Show(this, error.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
            }
            finally
            {
                AllowFullpower = temp;
            }
        }

        /*
        private void addSelectedToListOld(bool append, string sorPath = null, bool addToBookmark = false)
        {
            var selectedIndices = tvCatalog.SelectedIndices;
            if (selectedIndices != null && selectedIndices.Length > 0)
            {
                var addList = new List<string>();
                var pageList = new List<int>();
                lock (ZipPathArrayLocker)
                {
                    var fullBufCount = ZipMaskArray.Length;
                    foreach (var index in selectedIndices)
                    {
                        if (index < 0 || index >= fullBufCount) return;
                        addList.Add(ZipPathArray[index]);
                        pageList.Add(-1);
                    }
                }
                if (addList.Count > 0)
                {
                    var temp = AllowFullpower;
                    try
                    {
                        if (sorPath == null)
                        {
                            AllowFullpower = false;
                            if (addToNewListSaveFileDialog.ShowDialog(this) == DialogResult.OK)
                            {
                                sorPath = addToNewListSaveFileDialog.FileName;
                                if (!append && File.Exists(sorPath)) File.Delete(sorPath);
                            }
                        }
                        if (sorPath != null)
                        {
                            VirtualFolder.AddBookmarkData(sorPath, addList, pageList);
                            if (addToBookmark)
                            {
                                addCatalogBookmarkToList(currentConditionToColoredBookmark(currentProfileColor, sorPath));
                            }
                            bookmarkToolStripMenuItem.Checked = true;
                            var rowIndexBound = dgvDirectoryList.Rows.Count - 1;
                            for (var i = 0; i <= rowIndexBound; i++) dgvDirectoryList.Rows[i].Selected = i == rowIndexBound;
                            saveBookmarkToIni_bookmarkChanged = true;
                            saveBookmarkToConfig();
                        }
                    }
                    catch (Exception error)
                    {
#if DEBUG
                        MessageBox.Show(this, error.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                        MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                    }
                    finally
                    {
                        AllowFullpower = temp;
                    }
                }
            }
        }
        */

        /*
        private void openListFileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var temp = AllowFullpower;
            AllowFullpower = false;
            try
            {
                string path = null;
                try
                {
                    if (File.Exists(zabLocation.Text))
                    {
                        path = zabLocation.Text;
                    }
                }
                catch { }
                if (path == null) path = Program.ItsSelfOrExistingParentDirectory(zabLocation.Text);
                if (!string.IsNullOrEmpty(path))
                {
                    if (File.Exists(path))
                    {
                        openListFileDialog.InitialDirectory = Path.GetDirectoryName(path);
                        openListFileDialog.FileName = Path.GetFileName(path);
                    }
                    else
                    {
                        openListFileDialog.InitialDirectory = path;
                        openListFileDialog.FileName = "";
                    }
                }
                if (openListFileDialog.ShowDialog(this) == DialogResult.OK)
                {
                    zabLocation.Text = openListFileDialog.FileName;
                    MakePreview();
                }
            }
            catch (Exception error)
            {
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                AllowFullpower = temp;
            }
        }
        */

        private void btnGoToBack_Click(object sender, EventArgs e)
        {
            gotToUnderBuffer(undoBufferIndex - 1, ApplicationProviderUser.MouseClick);
        }

        private void btnGoToForward_Click(object sender, EventArgs e)
        {
            gotToUnderBuffer(undoBufferIndex + 1, ApplicationProviderUser.MouseClick);
        }

        private void gotToUnderBuffer(int index, ApplicationProviderUser user)
        {
            if (index == undoBufferIndex) return;
            //if (CreatingZipPathArray) return;
            var preIndex = undoBufferIndex;
            UndoBufferClass newData = null;
            if (index >= 0 && index < undoBuffer.Count)
            {
                undoBufferIndex = index;
                newData = undoBuffer[index];
            }
            btnGoToForward.Enabled = undoBufferIndex < undoBuffer.Count - 1;
            btnGoToBack.Enabled = undoBufferIndex > 0;

            if (!string.IsNullOrEmpty(newData?.Location))
            {
                //zabLocation.Text = newData.Location;

                // キー操作でも選択項目が存在すれば一番上を選択するという操作は行わない
                if (user == ApplicationProviderUser.EnterKey && !string.IsNullOrEmpty(newData.SelectedFileName)) user = ApplicationProviderUser.MouseClick;

                var prevColor = currentProfileColor;
                var prevProfile = prepareMoveLocationWithChangingProfile(newData.Location, newData.ProfileColor, newData.Profile, user);

                MakePreview(manualUndoShift: undoBufferIndex - preIndex, selectedIndex: -1, selectedFileName: newData.SelectedFileName,
                    tScrollbar: newData.ThumbnailPosition, fScrollbar: newData.FileListPosition, prevProfileInfo: Tuple.Create(prevColor, prevProfile));
            }
        }

        private void goUpFromCurrentLocation()
        {
            var basePath = preCurrentLocation; // 読み込み準備中に呼び出した場合準備している方を基準にする
            changeCurrentAndGoUpFromCurrentLocation(basePath);
        }

        private void changeCurrentAndGoUpFromCurrentLocation(string newBasePath)
        {
            var cl = currentLocation;
            if (string.IsNullOrEmpty(cl)) return;
            string parent;
            try
            {
                parent = Path.GetDirectoryName(cl);
            }
            catch
            {
                return;
            }
            goUpFromCurrentLocation(parent, newBasePath);
        }

        private void goUpFromCurrentLocation(string newPath)
        {
            var basePath = preCurrentLocation; // 読み込み準備中に呼び出した場合準備している方を基準にする
            goUpFromCurrentLocation(newPath, basePath);
        }

        private void goUpFromCurrentLocation(string newPath, string basePath)
        {
            if (string.IsNullOrEmpty(newPath)) return;

            var c = newPath.Last();
            if (c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar)
            {
                if (newPath.Length == 1) return;
                newPath = newPath.Substring(0, newPath.Length - 1);
            }

            if (basePath == null || basePath.Length - newPath.Length < 2 || !basePath.StartsWith(newPath, StringComparison.OrdinalIgnoreCase))
            {
                zabLocation.Text = newPath;
                MakePreview();
                return;
            }

            c = basePath[newPath.Length];
            if (c != Path.DirectorySeparatorChar && c != Path.AltDirectorySeparatorChar)
            {
                zabLocation.Text = newPath;
                MakePreview();
                return;
            }

            var selectedFileName = basePath.Substring(newPath.Length + 1);
            var stop1 = selectedFileName.IndexOf(Path.DirectorySeparatorChar); if (stop1 < 0) stop1 = int.MaxValue;
            var stop2 = selectedFileName.IndexOf(Path.AltDirectorySeparatorChar); if (stop2 < 0) stop2 = int.MaxValue;
            var stop = Math.Min(stop1, stop2);
            if (stop != int.MaxValue)
            {
                selectedFileName = selectedFileName.Substring(0, stop) + Path.DirectorySeparatorChar;
            }
            else
            {
                if (!CreatingZipPathArray)
                {
                    if (InRealDirectory)
                    {
                        selectedFileName += Path.DirectorySeparatorChar;
                    }
                }
                else
                {
                    try
                    {
                        if (Directory.Exists(newPath + Path.DirectorySeparatorChar + selectedFileName))
                        {
                            selectedFileName += Path.DirectorySeparatorChar;
                        }
                    }
                    catch
                    {
                        selectedFileName = null;
                    }
                }
            }

            if (selectedFileName == null)
            {
                zabLocation.Text = newPath;
                MakePreview();
                return;
            }

            zabLocation.Text = newPath;
            MakePreview(selectedIndex: -1, selectedFileName: selectedFileName,
                tScrollbar: MakePreview_tScrollbarMoveToSelectedFile, fScrollbar: MakePreview_fScrollbarMoveToSelectedFile);
            return;

        }

        /*
        private void gotToParent()
        {
            try
            {
                var parent = Path.GetDirectoryName(currentLocation);
                if (!string.IsNullOrEmpty(parent))
                {
                    zabLocation.Text = parent;
                    MakePreview(manualUndoShift: 0);!
                }
            }
            catch { }
        }
        */

        private void CatalogForm_KeyDown(object sender, KeyEventArgs e)
        {
            SetLookAheadArchive_BlackPrefix = null;

            if (e.Alt)
            {
                if (e.KeyCode == Keys.Left)
                {
                    gotToUnderBuffer(undoBufferIndex - 1, ApplicationProviderUser.EnterKey);
                }
                else if (e.KeyCode == Keys.Right)
                {
                    gotToUnderBuffer(undoBufferIndex + 1, ApplicationProviderUser.EnterKey);
                }
                else if (e.KeyCode == Keys.Up)
                {
                    goUpFromCurrentLocation();
                }
                //e.Handled = true; // 1.3.3.5 で Alt+← 等でカーソルキー移動が発生しないように追記したが、
                // これにより メニュー表示や終了などの Alt の標準的な機能が使えなくなっていた。    
                // 1.6.4.6 においては ThumbView 側でそれが回避されているので不要
            }
            else if (e.KeyCode == Keys.Back)
            {
                if (NotInEditiongAnything())
                {
                    if (btnGoToBack.Enabled)
                    {
                        gotToUnderBuffer(undoBufferIndex - 1, ApplicationProviderUser.EnterKey);
                    }
                    else
                    {
                        goUpFromCurrentLocation();
                        /*
                        try
                        {
                            var path = Path.GetDirectoryName(preCurrentLocation);
                            if (path != preCurrentLocation && Directory.Exists(path))
                            {
                                zabLocation.Text = path;
                                bmwMakePreviewRunWorkerStartingFinalAction = () =>
                                {
                                    firstShownItemSelect();
                                    bmwMakePreviewRunWorkerStartingFinalAction = null;
                                };
                                MakePreview();
                            }
                        }
                        catch { }
                        */
                    }
                }
            }
            else if (e.KeyCode == Keys.Escape)
            {
                clearCutItemInClipBoard();
            }
            else if (e.KeyCode == Keys.Q && (e.Modifiers & Keys.Control) == Keys.Control) // 仮想キーボードは使用しない
            {
                Close();
            }
        }

        private void addToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            AllowFullpower = false;
            var validLocation = locationValid();
            currentLocationToolStripMenuItem.Enabled = validLocation;
            currentLocationAndFilterToolStripMenuItem.Enabled = validLocation;// && filterValid();
        }

        private bool locationValid()
        {
            try
            {
                return !string.IsNullOrEmpty(currentLocation) && !CreatingZipPathArray;// && VirtualFolder.DirectoryOrBookmarkExists(currentLocation);
            }
            catch
            {
                return false;
            }
        }

        private bool filterValid()
        {
            return cbFilter_Valid;
            //return cbFilter.BackColor == WindowColor;
        }

        private void currentLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!locationValid()) return;
            AddBookmarkWithCurrentProfileColor(currentLocation);
        }

        private void AddBookmarkWithCurrentProfileColor(string location)
        {
            addCatalogBookmarkToList(currentConditionToColoredBookmark(currentProfileColor, location));
            saveBookmarkToIni_bookmarkChanged = true;
            saveBookmarkToConfig();
        }

        private void currentLocationAndFilterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!locationValid()) return;

            AddBookmarkWithNewProfileColor(currentLocation);
        }

        private void AddBookmarkWithNewProfileColor(string location)
        {
            AllowFullpower = false;
            var newColor = getNewProfileColorFromDialog(useCurrentAsDefault: false);
            if (!newColor.IsEmpty)

            {
                synchronizeCurrentProfile();

                var currentConditionBookmark = currentConditionToColoredBookmark(newColor, location);

                addCatalogBookmarkToList(currentConditionBookmark);
                saveBookmarkToIni_bookmarkChanged = true;
                saveBookmarkToConfig();

                var prevProfileInfo = Tuple.Create(currentProfileColor, currentConditionToProfile());

                currentProfileColor = newColor;

                // if (Tags == null) Tags = new ZipTag[0]; // currentConditionToColoredBookmark で行われる
                var config = new ZipTagConfig();
                config.Tags = Tags;
                config.ProfileColor = currentProfileColor;
                config.Save();

                undoBufferUpdateForMovingLocation(0, prevProfileInfo);

            }
            AllowFullpower = true;
        }

        /*
        private bool newColorIsTooCloseToSomeColors(Color newColor, HashSet<Color> colors)
        {
            if (colors == null || colors.Count == 0) return false;
            var min = (from c in colors select dist2(c, newColor)).Min();

            var optimum = Math.Pow(colors.Count + 1, -1.0 / 3);

            return min < optimum;
        }

        private double dist2(Color a, Color b)
        {
            //const double c = Math.Pow(0.299 * 0.587 * 0.114 * 255 * 255 * 255, -2.0 / 3);
            const double c = 0.00020866208;

            var dr = a.R - b.R;
            var dg = a.G - b.G;
            var db = a.B - b.B;
            return (0.299 * 0.299 * c) * dr * dr + (0.587 * 0.587 * c) * dg * dg + (0.114 * 0.114 * c) * db * db;
        }
        */

        private CatalogProfile synchronizeCurrentProfile()
        {
            var currentProfile = currentConditionToProfile();
            var cc = currentProfileColor;
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                if (bookmark != null && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None && bookmark.Color == cc) // セパレーターなら無視される
                {
                    bookmark.Profile = currentProfile;
                }
            }
            foreach (var buf in undoBuffer)
            {
                if (buf.ProfileColor == cc)
                {
                    buf.Profile = currentProfile;
                }
            }
            return currentProfile;
        }

        private void addCatalogBookmarkToList(ColoredBookmark bookmark, bool insertToSelected = false)
        { addCatalogBookmarkToList(new ColoredBookmark[] { bookmark }, insertToSelected); }
        private void addCatalogBookmarkToList(IReadOnlyList<ColoredBookmark> bookmarks, bool insertToSelected = false)
        {
            var sr = dgvDirectoryList.SelectedRows;
            if (sr != null && sr.Count > 0)
            {
                addCatalogBookmarkToList(bookmarks, (from DataGridViewRow r in sr select r.Index).Min());
            }
            else
            {
                addCatalogBookmarkToList(bookmarks, int.MaxValue);
            }
        }
        private void addCatalogBookmarkToList(IReadOnlyList<ColoredBookmark> bookmarks, int insertIndex)
        {
            if (bookmarks == null) return;
            var count = bookmarks.Count;
            if (count == 0) return;
            var newRows = new List<DataGridViewRow>();
            var colorToProfile = new Dictionary<Color, CatalogProfile>();
            foreach (var bookmark in bookmarks)
            {
                var role = bookmark.SimpleBookmark.SpecialRole;
                if (role == 0)
                {
                    if (bookmark.Profile == null) continue; // フォールトトレランス

                    if (colorToProfile.ContainsKey(bookmark.Color))
                    {
                        bookmark.Profile = colorToProfile[bookmark.Color];
                    }
                    else
                    {
                        colorToProfile[bookmark.Color] = bookmark.Profile;
                    }

                    var row = new DataGridViewRow();
                    row.CreateCells(dgvDirectoryList);
                    row.Cells[tbcDirectoryName.Index].Value = bookmark;
                    newRows.Add(row);
                }
                else
                {
                    var row = new DataGridViewRow();
                    row.CreateCells(dgvDirectoryList);
                    var spBookmark = getColoredBookmarkWithSpecialRole(role);
                    spBookmark.Color = dgvDirectoryList.BackgroundColor;
                    spBookmark.SimpleBookmark.SetOrResetAlias(bookmark.SimpleBookmark.Alias);
                    row.Cells[tbcDirectoryName.Index].Value = spBookmark;
                    newRows.Add(row);
                }
            }
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                if (bookmark != null && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None && colorToProfile.ContainsKey(bookmark.Color)) // セパレーターなら無視される
                {
                    bookmark.Profile = colorToProfile[bookmark.Color];
                }
            }
            var rows = dgvDirectoryList.Rows;
            int addTop = Math.Max(0, Math.Min(rows.Count, insertIndex));
            rows.InsertRange(addTop, newRows.ToArray());
            var rowsCount = rows.Count;
            for (var i = 0; i < rowsCount; i++)
            {
                rows[i].Selected = false; // i >= start;
            }
        }

        private void moveToBookmark(int bookmarkRowIndex, ApplicationProviderUser user, bool loadOnlyProfileColor = false)
        {
            if (!dgvDirectoryList.ReadOnly) return;
            if (bookmarkRowIndex < 0) return;
            var rows = dgvDirectoryList.Rows;
            if (rows.Count > bookmarkRowIndex)
            {
                var bookmark = rows[bookmarkRowIndex].Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                if (bookmark == null || bookmark.SimpleBookmark.SpecialRole != SimpleBookmarkSpecialRole.None) return;// セパレーターなら無視される
                var profile = bookmark.Profile;
                var text = loadOnlyProfileColor ? null : bookmark?.SimpleBookmark?.Location;

                //if (text == null || profile == null) return; // フォールトトレランス
                if (profile == null) return; // フォールトトレランス

                var prevColor = currentProfileColor;
                var prevProfile = prepareMoveLocationWithChangingProfile(text, bookmark.Color, profile, user, out var prepareToReload);

                if (!string.IsNullOrEmpty(text))
                {
                    MakePreview(resetBookmark: false, prevProfileInfo: Tuple.Create(prevColor, prevProfile));
                }
                else if (prepareToReload)
                {
                    UpdatePreview();
                }
            }
        }

        private CatalogProfile prepareMoveLocationWithChangingProfile(string location, Color color, CatalogProfile profile, ApplicationProviderUser user)
            => prepareMoveLocationWithChangingProfile(location, color, profile, user, out var prepareToReload);
        private CatalogProfile prepareMoveLocationWithChangingProfile(string location, Color color, CatalogProfile profile, ApplicationProviderUser user, out bool prepareToReload)
        {
            var textExists = !string.IsNullOrEmpty(location);
            if (textExists) zabLocation.Text = location;

            prepareToReload = false;

            if (color != currentProfileColor)
            {
                // リロード時にブックマークのセーブが行われるのでこのシンクロのあとに明示的にセーブする必要はない
                var prevProfile = synchronizeCurrentProfile();

                currentProfileColor = color;

                if (profile.ClipMode is ClipMode clipMode && clipMode != clipModeByControl)
                {
                    prepareToReload = true;
                    clipModeByControl = clipMode;
                }

                if (profile.AligningMode != null || profile.MinimumFrameThickness != null)
                {
                    var temp = tvCatalog.StopUpdateRowsCols;
                    tvCatalog.StopUpdateRowsCols = true;
                    if (profile.AligningMode != null) currentAligning = (ThumbViewerAligningMode)profile.AligningMode;
                    if (profile.MinimumFrameThickness != null) currentMinimumFrameThickness = (double)profile.MinimumFrameThickness;
                    tvCatalog.StopUpdateRowsCols = temp;
                }

                if (profile.ThumbnailMouseWheelScrollAmount != null && profile.ThumbnailMouseWheelScrollUnit != null)
                {
                    setMouseWheelScrollAmount((int)profile.ThumbnailMouseWheelScrollAmount, (ThumbViewerScrollUnit)profile.ThumbnailMouseWheelScrollUnit);
                }

                if (profile.AspectRatio is double aspectRatioLocal && aspectRatioLocal != aspectRatio)
                {
                    prepareToReload = true;
                    aspectRatio = aspectRatioLocal;
                    setAspectRatioCheckState();
                }

                if (profile.ThumbnailSize is int size && 0 <= size && size < 5)
                {
                    var tsmi = (ToolStripMenuItem)thumbnailSizeToolStripMenuItem.DropDownItems[size + ChangeThumbnailSize_MenuItemOffset];
                    if (!tsmi.Checked)
                    {
                        prepareToReload = true;
                        ChangeThumbnailSize(tsmi);
                    }
                }

                var filterHistory = profile.FilterHistory;
                if (filterHistory != null)
                {
                    cbFilter.Items.Clear();
                    cbFilter.Items.Add("");
                    foreach (var h in filterHistory)
                    {
                        cbFilter.Items.Add(h);
                    }
                }

                var alias = profile.FilterAliasToString;
                if (alias != null)
                {
                    aliasesToFilteringStrings = new Dictionary<string, string>();
                    foreach (var kav in alias) aliasesToFilteringStrings.Add(kav.Key, kav.Value);
                }

                if (profile.InvariantFilter != null)
                {
                    invariantFilteringList = (bool)profile.InvariantFilter;
                }

                var tags = profile.Tags;
                if (tags != null)
                {
                    // runworker starting で行われるが早めに更新することを目的に実行。読み込み待ち中に他のウインドウをアクティブにすることも想定して needToSaveCurrentTag も true に
                    setTagFilteringMenuItems(needToRepairTagsFromBookmark: true, needToSaveCurrentTag: true);

                }

                if (profile.TinyOnScreenKeyboardVisible != null)
                {
                    TinyOnScreenKeyboardVisible = (bool)profile.TinyOnScreenKeyboardVisible;
                }
                if (profile.SelectionHighlightMode != null)
                {
                    SelectionHilightMode = (SelectionHighlightMode)profile.SelectionHighlightMode;
                }
                bool removeFilter = false;
                if (profile.FilterRemovingMode != null)
                {
                    var frm = (FilterRemovingMode)profile.FilterRemovingMode;
                    FilterRemovingMode = frm;
                    removeFilter = frm == FilterRemovingMode.WhenMovingLocation;
                }
                if (profile.LoadLastViewedPageFromHistory != null)
                {
                    LoadLastViewedPageFromHistory = (bool)profile.LoadLastViewedPageFromHistory;
                }
                if (profile.DoubleClickFileOpenMode != null)
                {
                    DoubleClickFileOpenMode = (DoubleClickMode)profile.DoubleClickFileOpenMode;
                }
                if (profile.RightClickContextMenu != null)
                {
                    RightClickContextMenu = (CatalogFormConetxtMenu)profile.RightClickContextMenu;
                }
                if (profile.MiddleClickContextMenu != null)
                {
                    MiddleClickContextMenu = (CatalogFormConetxtMenu)profile.MiddleClickContextMenu;
                }
                if (profile.ControlRightClickContextMenu != null)
                {
                    ControlRightClickContextMenu = (CatalogFormConetxtMenu)profile.ControlRightClickContextMenu;
                }
                if (profile.ItemSelectionFeedback != null)
                {
                    ItemSelectionFeedback = (ItemSelectionFeedback)profile.ItemSelectionFeedback;
                }
                if (profile.SynchroFromTreeToBar != null && profile.SynchroFromBarToTree != null)
                {
                    setSynchroBetweenTreeAndBar((bool)profile.SynchroFromTreeToBar, (bool)profile.SynchroFromBarToTree);
                }
                if (profile.CollapseOthersWhenSynchronizing != null)
                {
                    CollapseOthersWhenSynchronizing = (bool)profile.CollapseOthersWhenSynchronizing;
                }
                /*
                if (profile.CheckDirectorySize != null)
                {
                    CheckDirectorySize = (bool)profile.CheckDirectorySize;
                }
                */
                if (profile.ArchivesInArchiveMode is ArchivesInArchiveMode aiam && aiam != ArchivesInArchiveMode )
                {
                    prepareToReload = true;
                    ArchivesInArchiveMode = aiam;
                }
                if (profile.ReadOnMemoryMode is ReadOnMemoryMode romm)
                {
                    ReadOnMemoryMode = romm;
                }
                if (profile.OpenInPreviousImageFilterSetting != null)
                {
                    OpenInPreviousImageFilterSetting = (bool)profile.OpenInPreviousImageFilterSetting;
                }
                if (profile.DefaultBindingMode != null)
                {
                    bindingModeByControl = (BindingMode)profile.DefaultBindingMode;
                }
                if (profile.CoverBindingMode != null)
                {
                    CoverBindingMode = (CoverBindingMode)profile.CoverBindingMode;
                }
                if (profile.SortSyncMode is SortSyncMode sortSyncMode)
                {
                    SortSyncMode = sortSyncMode;
                }
                if (profile.AlwaysHideUI != null)
                {
                    SetAlwaysHideUI((bool)profile.AlwaysHideUI, silent: true);
                }
                if (profile.AllowReadAheadProcess != null)
                {
                    SetAllowReadAheadProcess((bool)profile.AllowReadAheadProcess, silent: true);
                }
                if (profile.BackColorOfBuiltInViewer != null)
                {
                    BackColorOfBuiltInViewer = (Color)profile.BackColorOfBuiltInViewer;
                }
                if (profile.SelectedColorForBackColorOfBuiltInViewer != null)
                {
                    SelectedColorForBackColorOfBuiltInViewer = (Color)profile.SelectedColorForBackColorOfBuiltInViewer;
                }
                if (profile.BuiltInViewerInitialFullscreenMode != null)
                {
                    BuiltInViewerInitialFullscreenMode = (InitialFullscreenMode)profile.BuiltInViewerInitialFullscreenMode;
                }

                if (profile.DisplayArchiveFiles != null && profile.DisplayImageFiles != null && profile.DisplayVideoFiles != null && profile.DisplayOtherFiles != null && profile.SubfolderMode != null)
                {
                    var a = ParseItemLoadLevel(profile.DisplayArchiveFiles);
                    var i = ParseItemLoadLevel(profile.DisplayImageFiles);
                    var v = ParseItemLoadLevel(profile.DisplayVideoFiles);
                    var o = ParseItemLoadLevel(profile.DisplayOtherFiles);
                    var s = (SubfolderMode)profile.SubfolderMode;

                    if (a == ItemLoadLevel.Ignore && i == ItemLoadLevel.Ignore && v == ItemLoadLevel.Ignore && o == ItemLoadLevel.Ignore && !IsDisplay(s)) a = ItemLoadLevel.Full;

                    if (!textExists && !prepareToReload) prepareToReload = ArchiveLoadLevel != a || ImageLoadLevel != i || VideoLoadLevel != v || OtherLoadLevel != o || SubfolderMode != s;

                    ArchiveLoadLevel = a;
                    ImageLoadLevel = i;
                    VideoLoadLevel = v;
                    OtherLoadLevel = o;
                    SubfolderMode = s;

                    /*
                    var a = (bool)profile.DisplayArchiveFiles;
                    var i = (bool)profile.DisplayImageFiles;
                    var v = (bool)profile.DisplayVideoFiles;
                    var o = (bool)profile.DisplayOtherFiles;
                    if (!a && !i && !v && !o) a = true;
                    archivesFilesPDFFielsToolStripMenuItem.Checked = a;
                    imageFilesToolStripMenuItem.Checked = i;
                    videoFilesToolStripMenuItem.Checked = v;
                    otherFilesToolStripMenuItem.Checked = o;
                    */
                }
                if (profile.ThumbnailCacheRoot != null)
                {
                    if (profile.ThumbnailCacheRoot == CatalogFormConfig.NOCACHE)
                    {
                        thumbnailCache = null;
                    }
                    else
                    {
                        thumbnailCache = profile.ThumbnailCacheRoot;
                    }
                }

                if (profile.ShowIcon != null) showIcon = showIconToolStripMenuItem.Checked = (bool)profile.ShowIcon;
                if (profile.ShowRating != null) showRating = showRatingToolStripMenuItem.Checked = (bool)profile.ShowRating;
                if (profile.ShowTags != null) showTags = showTagsToolStripMenuItem.Checked = (bool)profile.ShowTags;
                //if (profile.ShowFilename != null) tvCatalog.ShowText = showFilenameToolStripMenuItem.Checked = (bool)profile.ShowFilename;
                if (profile.ShowFilename != null) setShowFileName((bool)profile.ShowFilename);
                
                var noReload = !locationValid() || user == ApplicationProviderUser.Error;

                // changeMaxCaptchaCount のコストが高いのでできるだけ後で行う
                if (profile.MaxCaptchaCountInOneVideo is int maxCaptchaCountInOneVideo)
                {
                    if (noReload || textExists || prepareToReload)
                    {
                        MaxCaptchaCountInAVideo = maxCaptchaCountInOneVideo;
                    }
                    else
                    {
                        changeMaxCaptchaCount(maxCaptchaCountInOneVideo, out prepareToReload);
                    }
                }

                if (noReload) prepareToReload = false;

                // リロードするかどうかが確定したあとの処理
                var makePreviewOrUpdate = textExists || prepareToReload;

                if (!removeFilter || !textExists) // さもなければ makePreview で消される。prepareToReload 後の Update では消されないので注意。
                {
                    cbFilter_TextChanged_StopResort = true;
                    if (profile.Filter != null) cbFilter.Text = profile.Filter;
                    cbFilter_TextChanged_StopResort = false;
                }

                if (profile.NumberOfLinesOfName is NumberOfLinesOfName numberOfLinesOfName && numberOfLinesOfName != NumberOfLinesOfName)
                {
                    SetNumberOfLinesOfName(numberOfLinesOfName, refresh: !makePreviewOrUpdate); // 読み込みの Starting でリフレッシュされるので Update の場合もここではリフレッシュしない

                    //NumberOfLinesOfName = (NumberOfLinesOfName)profile.NumberOfLinesOfName;
                }

                var needToResortForFolderSortMode = false;
                FolderSortMode needToResortForFolderSortMode_Mode = default(FolderSortMode);
                if (profile.FolderSortMode is FolderSortMode folderSortMode && folderSortMode != FolderSortMode)
                {
                    if (makePreviewOrUpdate)
                    {
                        SetFolderSortMode(folderSortMode, reSort: false);
                    }
                    else
                    {
                        needToResortForFolderSortMode_Mode = folderSortMode;
                        needToResortForFolderSortMode = true;
                    }
                }

                if (profile.LastSortMode is SortMode lastSortModeLocal && profile.SortMode is SortMode sortModeLocal)
                {
                    var temp = cbSortBy_SelectedValueChanged_Stop;
                    if (makePreviewOrUpdate) cbSortBy_SelectedValueChanged_Stop = true;
                    prevSortMode = (SortMode)profile.LastSortMode;
                    cbSortBy.SelectedIndex = (int)profile.SortMode;
                    sortMode = (SortMode)profile.SortMode;
                    GetSortArray_RandomSeed = profile.RandomSeed;
                    if (makePreviewOrUpdate) cbSortBy_SelectedValueChanged_Stop = temp;
                }

                if (needToResortForFolderSortMode) SetFolderSortMode(needToResortForFolderSortMode_Mode, reSort: true);

                if (makePreviewOrUpdate)
                {
                    //BackgroundMultiWorker.RunWorkerStartingEventHandler eh = null;
                    //eh = (sender2, e2) =>
                    bmwMakePreviewRunWorkerStartingFinalAction = () =>
                    {
                        prepareMoveLocationWithChangingProfile_SetProfileAfterReloaded(profile);

                        if (textExists && IsKeyboard(user))
                        {
                            firstShownItemSelect();
                        }

                        //bmwMakePreview.RunWorkerStarting -= eh;
                        bmwMakePreviewRunWorkerStartingFinalAction = null;
                    };
                    //bmwMakePreview.RunWorkerStarting += eh;
                }
                else
                {
                    prepareMoveLocationWithChangingProfile_SetProfileAfterReloaded(profile);

                    if (undoBufferIndex >= 0 && undoBufferIndex < undoBuffer.Count)
                    {
                        var data = undoBuffer[undoBufferIndex];
                        data.ProfileColor = color;
                    }
                }

                return prevProfile;
            }
            else if (textExists)
            {
                if (IsKeyboard(user))
                {
                    bmwMakePreviewRunWorkerStartingFinalAction = () =>
                    {
                        firstShownItemSelect();

                        //bmwMakePreview.RunWorkerStarting -= eh;
                        bmwMakePreviewRunWorkerStartingFinalAction = null;
                    };
                }

                return null;
            }
            else return null;
        }

        private void prepareMoveLocationWithChangingProfile_SetProfileAfterReloaded(CatalogProfile profile)
        {
            if (profile.ThumbnailListVisible != null) thumbnailListToolStripMenuItem.Checked = (bool)profile.ThumbnailListVisible;
            if (profile.FileListVisible != null) fileListToolStripMenuItem.Checked = (bool)profile.FileListVisible;
            if (profile.FileListDock != null) setFileListDock((DockStyle)profile.FileListDock, keepWidth: false, fixWidth: false);
            if (profile.FileListWidth != null)
            {
                pnlRight_NormalWidth = (int)profile.FileListWidth;
                setFileListWidthWithoutSettingWidth(pnlRight_NormalWidth);
            }
            if (profile.FileListOrder != null) Program.DecodeDisplayIndices(dgvFileList.Columns, (string[])profile.FileListOrder);
            if (profile.IconInFileList != null) tbcIcon.Visible = (bool)profile.IconInFileList;
            if (profile.PageInFileList != null) tbcPage.Visible = (bool)profile.PageInFileList;
            if (profile.RatingInFileList != null) tbcRating.Visible = (bool)profile.RatingInFileList;
            if (profile.DateCreatedInFileList != null) tbcCreateTime.Visible = (bool)profile.DateCreatedInFileList;
            if (profile.DateAccessedInFileList != null) tbcAccessTime.Visible = (bool)profile.DateAccessedInFileList;
            if (profile.DateModifiedInFileList != null) tbcWriteTime.Visible = (bool)profile.DateModifiedInFileList;
            if (profile.SizeInFileList != null) tbcSize.Visible = (bool)profile.SizeInFileList;
            if (profile.ResolutionInFileList != null) tbcResolution.Visible = (bool)profile.ResolutionInFileList;
            if (profile.RatioInFileList != null) tbcRatio.Visible = (bool)profile.RatioInFileList;
            if (profile.WidthInFileList != null) tbcWidth.Visible = (bool)profile.WidthInFileList;
            if (profile.HeightInFileList != null) tbcHeight.Visible = (bool)profile.HeightInFileList;
            if (profile.LengthInFileList != null) tbcLength.Visible = (bool)profile.LengthInFileList;
            if (profile.FpsInFileList != null) tbcFPS.Visible = (bool)profile.FpsInFileList;

            if (WindowState != FormWindowState.Minimized) setMainPanelWidth();
        }

        private static ItemLoadLevel ParseItemLoadLevel(string str)
        {
            if (str == null) return ItemLoadLevel.Full;
            if (!Enum.TryParse(str, out ItemLoadLevel result))
            {
                result = bool.TryParse(str, out bool strIsTrue) && !strIsTrue ? ItemLoadLevel.Ignore : ItemLoadLevel.Full;
            }
            return result;
        }

        private static bool IsKeyboard(ApplicationProviderUser user)
        {
            return user == ApplicationProviderUser.EnterKey || user == ApplicationProviderUser.AccessKey;
        }

        private void firstShownItemSelect()
        {
            if (tvCatalog.Count > 0)
            {
                var s2d = tvCatalog.ShowIndexToDataIndex;
                tvCatalog.SelectedIndex = s2d[0];

                if (pnlCenter.Visible) tvCatalog.Focus();
                else if (pnlRight.Visible) dgvFileList.Focus();
            }
        }

        private void DgvSorter_CellClick(object sender, DataGridViewCellEventArgs e)
        {
            moveToBookmark(e.RowIndex, ApplicationProviderUser.MouseClick);
        }

        private void DgvSorter_RowsReleased(DataGridView sender, DataGridViewSorterRowsReleasedEventArgs e)
        {
            if (e.Operation == DataGridViewSorterRowsReleasedOperation.NotMoved)
            {
                moveToBookmark(e.RowIndex, ApplicationProviderUser.MouseClick);
            }
        }

        private Action bmwMakePreviewRunWorkerStartingFinalAction = null;

        DateTime BookmarkConfigModifiedDateTime = DateTime.MinValue;

        private bool SetBookmarkConfigModifiedDateTimeFromFile()
        {
            try
            {
                //BookmarkConfigModifiedDateTime = File.GetLastWriteTime(Configuration.XmlPath);
                BookmarkConfigModifiedDateTime = Configuration.GetLastWriteTimeWithoutFileCheckWithException();
                return true;
            }
            catch (Exception ex)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return false;
            }
        }

        private void loadBookmarkFromConfig(bool reload = false)
        {
            var config = new ColoredBookmarkConfig();

            var ex = config.GetLastException();
            if (ex != null)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (!SetBookmarkConfigModifiedDateTimeFromFile()) return;

            var bookmarks = config.Bookmarks;
            var bookmarkColors = config.BookmarkColors;
            var profiles = config.Profiles;
            var profileColors = config.ProfileColors;
            if (bookmarks != null && bookmarks.Length == bookmarkColors?.Length && profiles != null && profiles.Length == profileColors?.Length)
            {
                var coloredBookmarks = new ColoredBookmark[bookmarks.Length];
                for (var i = 0; i < bookmarks.Length; i++)
                {
                    var bookmark = bookmarks[i];
                    var color = (Color)bookmarkColors[i];
                    CatalogProfile profile = null;
                    for (var j = 0; j < profiles.Length; j++)
                    {
                        if (profileColors[j] == color)
                        {
                            profile = profiles[j];
                            break;
                        }
                    }
                    if (profile != null)
                    {
                        coloredBookmarks[i] = new ColoredBookmark(color, bookmark, profile);
                    }
                    else
                    {
                        coloredBookmarks[i] = new ColoredBookmark(color, bookmark, new CatalogProfile());
                    }
                }

                if (reload) dgvDirectoryList.Rows.Clear();

                addCatalogBookmarkToList(coloredBookmarks);
            }
        }

        bool saveBookmarkToIni_bookmarkChanged = false;
        private void saveBookmarkToConfig()
        {
            if (saveBookmarkToIni_bookmarkChanged)
            {
                saveBookmarkToIni_bookmarkChanged = false;
                var config = new ColoredBookmarkConfig();
                var bookmarks = (from DataGridViewRow row in dgvDirectoryList.Rows select row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark).ToArray();
                if (bookmarks != null)
                {
                    var simpleBookmarks = new SimpleBookmark[bookmarks.Length];
                    var bookmarkColors = new SerializableRGB[bookmarks.Length];
                    var profiles = new List<CatalogProfile>();
                    var profileColors = new List<SerializableRGB>();
                    for (var i = 0; i < bookmarks.Length; i++)
                    {
                        var bookmark = bookmarks[i];
                        var color = (SerializableRGB)bookmark.Color;
                        simpleBookmarks[i] = bookmark.SimpleBookmark;
                        bookmarkColors[i] = color;
                        var profile = bookmark.Profile;
                        if (profile != null && !profileColors.Contains(color))
                        {
                            profileColors.Add(color);
                            profiles.Add(profile);
                        }
                    }
                    config.Bookmarks = simpleBookmarks;
                    config.BookmarkColors = bookmarkColors;
                    config.Profiles = profiles.ToArray();
                    config.ProfileColors = profileColors.ToArray();
                }
                else
                {
                    config.Bookmarks = null;
                    config.BookmarkColors = null;
                    config.Profiles = null;
                    config.ProfileColors = null;
                }
                config.Save();
                SetBookmarkConfigModifiedDateTimeFromFile();
            }
        }

        private void dgvDirectoryList_UserDeletedRow(object sender, DataGridViewRowEventArgs e)
        {
            saveBookmarkToIni_bookmarkChanged = true;
            saveBookmarkToConfig();
        }

        private ColoredBookmark currentConditionToColoredBookmark(Color color, string location)
        {
            var simpleBookmark = new SimpleBookmark(null, location);
            if (string.IsNullOrEmpty(location))
            {
                var cl = currentLocation;
                simpleBookmark.Alias = string.IsNullOrEmpty(cl) ? Message.ProfileColor : Message.ProfileColorOf1.Replace("$1", SimpleBookmark.GetDisplayName(cl).Replace("&", "&&"));
            }
            return new ColoredBookmark(color, simpleBookmark, currentConditionToProfile());
        }

        private ColoredBookmark getColoredBookmarkWithSpecialRole(SimpleBookmarkSpecialRole specialRole)
        {
            var result = new ColoredBookmark(default(Color), new SimpleBookmark(specialRole), null);
            return result;
        }

        private void separatorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            addSeparatorToBookmarkList(insertToSelected: false);
        }

        private void addSeparatorToBookmarkList(bool insertToSelected)
        {
            //if (!locationValid()) return;

            var selectedRows = (from DataGridViewRow row in dgvDirectoryList.SelectedRows select row).ToArray();
            if (selectedRows.Length == 0) insertToSelected = false;
            int addTop;
            if (insertToSelected)
            {
                addTop = (from row in selectedRows select row.Index).Min();
            }
            else
            {
                addTop = dgvDirectoryList.RowCount;
            }

            var separator = getColoredBookmarkWithSpecialRole(SimpleBookmark.Separator);
            separator.SimpleBookmark.SetOrResetAlias(Message.Separator);
            addCatalogBookmarkToList(separator, insertToSelected);
            saveBookmarkToIni_bookmarkChanged = true;
            saveBookmarkToConfig();

            editBookmarkName(dgvDirectoryList.Rows[addTop]);
        }

        private CatalogProfile currentConditionToProfile()
        {
            if (Tags == null) setTagFilteringMenuItems(needToRepairTagsFromBookmark: false, needToSaveCurrentTag: false);

            return new CatalogProfile(
                prevSortMode,
                sortMode,
                sortMode == SortMode.Random ? GetSortArray_RandomSeed : null,
                cbFilter.Text,
                thumbnailSizeToolStripMenuItem.DropDownItems.IndexOf(SelectedThumbnailSize) - ChangeThumbnailSize_MenuItemOffset,
                aspectRatio,
                showIcon,
                showRating,
                showTags,
                tvCatalog.ShowText,
                clipModeByControl,
                currentAligning,
                NumberOfLinesOfName,
                currentMinimumFrameThickness,
                tvCatalog.MouseWheelScrollAmount,
                tvCatalog.MouseWheelScrollUnit,
                thumbnailListToolStripMenuItem.Checked,
                fileListToolStripMenuItem.Checked,
                getFileListDock(),
                pnlRight_NormalWidth,
                Program.EncodeDisplayIndices(dgvFileList.Columns),
                tbcIcon.Visible,
                tbcPage.Visible,
                tbcRating.Visible,
                tbcCreateTime.Visible,
                tbcAccessTime.Visible,
                tbcWriteTime.Visible,
                tbcSize.Visible,
                tbcResolution.Visible,
                tbcRatio.Visible,
                tbcWidth.Visible,
                tbcHeight.Visible,
                tbcLength.Visible,
                tbcFPS.Visible,
                TinyOnScreenKeyboardVisible,
                SelectionHilightMode,
                FilterRemovingMode,
                LoadLastViewedPageFromHistory,
                DoubleClickFileOpenMode,
                RightClickContextMenu,
                MiddleClickContextMenu,
                ControlRightClickContextMenu,
                ItemSelectionFeedback,
                SynchroFromTreeToBar,
                SynchroFromBarToTree,
                CollapseOthersWhenSynchronizing,
                FolderSortMode,
                //CheckDirectorySize,
                ArchivesInArchiveMode,
                ReadOnMemoryMode,
                OpenInPreviousImageFilterSetting,
                bindingModeByControl,
                CoverBindingMode,
                SortSyncMode,
                AlwaysHideUI,
                AllowReadAheadProcess,
                BackColorOfBuiltInViewer,
                SelectedColorForBackColorOfBuiltInViewer,
                BuiltInViewerInitialFullscreenMode,
                MaxCaptchaCountInAVideo,
                ArchiveLoadLevel,
                ImageLoadLevel,
                VideoLoadLevel,
                OtherLoadLevel,
                //archivesFilesPDFFielsToolStripMenuItem.Checked,
                //imageFilesToolStripMenuItem.Checked,
                //videoFilesToolStripMenuItem.Checked,
                //otherFilesToolStripMenuItem.Checked,
                thumbnailCache,
                SubfolderMode,
                (from object item in cbFilter.Items where !string.IsNullOrEmpty(item?.ToString()) select item.ToString()).ToArray(),
                invariantFilteringList,
                aliasesToFilteringStrings != null ? (from kav in aliasesToFilteringStrings select new KeyAndValue<string, string>(kav)).ToArray() : new KeyAndValue<string, string>[0], // null では意味が変わる
                Tags
                );
        }

        int dgvDirectoryList_MouseDown_RButtonDownIndex = -2;
        private void dgvDirectoryList_MouseDown(object sender, MouseEventArgs e)
        {
            simplifiedKeyBoard.UpHeldKey();
            LatestControledControl = sender as Control;
            //if (!dgvSorter.InRowsHolded) cmsDirectoryListPrepareAndShow(e);

            DataGridView.HitTestInfo hit = null;

            if (!dgvSorter.InRowsHolded && e.Button == MouseButtons.Right)
            {
                hit = dgvDirectoryList.HitTest(e.X, e.Y);
                var rowIndex = hit.RowIndex;
                dgvDirectoryList_MouseDown_RButtonDownIndex = rowIndex;
                if (!(from DataGridViewRow row in dgvDirectoryList.SelectedRows select row).Any(row => row.Index == rowIndex))
                {
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        row.Selected = row.Index == rowIndex;
                    }
                    dgvDirectoryList.CurrentCell = rowIndex >= 0 ? dgvDirectoryList[0, rowIndex] : null;
                }
            }

            if (e.Button == MouseButtons.Left)
            {
                hit = hit ?? dgvDirectoryList.HitTest(e.X, e.Y);
                if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                {
                    foreach (DataGridViewRow row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows select r).ToArray())
                    {
                        row.Selected = false;
                    }
                    dgvDirectoryList.EndEdit();
                }
            }
        }

        private void dgvDirectoryList_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right && dgvDirectoryList_MouseDown_RButtonDownIndex >= -1)
            {
                cmsDirectoryListPrepareAndShow(e);
            }
            dgvDirectoryList_MouseDown_RButtonDownIndex = -2;
        }

        System.Drawing.Bitmap cmsDirectoryListPrepareAndShow_ProfileColorIcon;
        void cmsDirectoryListPrepareAndShow(MouseEventArgs e)
        {
            var hit = dgvDirectoryList.HitTest(e.X, e.Y);
            if (e.Button == MouseButtons.Right)
            {
                if (!dgvDirectoryList.ReadOnly && hit.RowIndex != dgvDirectoryList.CurrentCell.RowIndex)
                {
                    dgvDirectoryList.EndEdit();
                }

                //if (hit.RowIndex >= 0)
                if (hit.Type != DataGridViewHitTestType.ColumnHeader)
                {
                    if (hit.RowIndex >= 0)
                    {
                        var clickedRow = dgvDirectoryList.Rows[hit.RowIndex];
                        if (!clickedRow.Selected)
                        {
                            foreach (DataGridViewRow row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows select r).ToArray())
                            {
                                row.Selected = false;
                            }
                            clickedRow.Selected = true;
                        }
                    }
                    else
                    {
                        foreach (DataGridViewRow row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows select r).ToArray())
                        {
                            row.Selected = false;
                        }
                    }
                    var selectedRows = dgvDirectoryList.SelectedRows;
                    var selectedCount = selectedRows.Count;
                    deleteToolStripMenuItem.Enabled = selectedCount > 0;

                    bool specialRoleIncluded = false;
                    bool locationIncluded = false;
                    bool pureProfileColorIncluded = false;
                    bool aliasIncluded = false;
                    Color firstColor = Color.Empty ;
                    foreach (DataGridViewRow row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows select r).ToArray())
                    {
                        var coloredBookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (coloredBookmark == null) continue;
                        var bookmark = coloredBookmark.SimpleBookmark;
                        if (bookmark == null) continue;
                        if (!specialRoleIncluded && bookmark.SpecialRole != SimpleBookmarkSpecialRole.None)
                        {
                            specialRoleIncluded = true;
                        }
                        else
                        {
                            if (firstColor.IsEmpty) firstColor = coloredBookmark.Color;
                        }
                        if (!pureProfileColorIncluded && string.IsNullOrEmpty(bookmark.Location)) pureProfileColorIncluded = true;
                        if (!aliasIncluded && bookmark.Alias != null) aliasIncluded = true;
                        if (!locationIncluded && bookmark.Location != null) locationIncluded = true;

                    }
                    realNameToolStripMenuItem.Enabled = aliasIncluded && !specialRoleIncluded && !pureProfileColorIncluded;
                    if (selectedCount == 1)
                    {
                        aliasToolStripMenuItem.Text = specialRoleIncluded || pureProfileColorIncluded ? Message.Rename : Message.EditAlias;
                        aliasToolStripMenuItem.Enabled = true;
                        openInExplorerInDirectoryListToolStripMenuItem.Enabled = !specialRoleIncluded;
                        loadOnlyProfileColorToolStripMenuItem.Enabled = !specialRoleIncluded;
                        loadOnlyProfileColorToolStripMenuItem.Text = specialRoleIncluded || locationIncluded ? Message.LoadOnlyProfileColor : Message.LoadProfileColor;


                    }
                    else
                    {
                        aliasToolStripMenuItem.Text = Message.EditAlias;
                        aliasToolStripMenuItem.Enabled = false;
                        openInExplorerInDirectoryListToolStripMenuItem.Enabled = false;
                        loadOnlyProfileColorToolStripMenuItem.Enabled = false;
                        loadOnlyProfileColorToolStripMenuItem.Text = Message.LoadOnlyProfileColor;
                    }
                    if (selectedCount == 1)
                    {
                        var path = (selectedRows[0].Cells[tbcDirectoryName.Index].Value as ColoredBookmark)?.SimpleBookmark?.Location;
                        editSmartFolderToolStripMenuItem.Visible = path?.ToLower()?.EndsWith("." + SmartFolder.ExtensionWithoutPeriodInLower) == true && FileExistsWithoutException(path);
                    }
                    else
                    {
                        editSmartFolderToolStripMenuItem.Visible = false;
                    }
                    if (selectedCount == 1 && !specialRoleIncluded && !firstColor.IsEmpty)
                    {
                        if (cmsDirectoryListPrepareAndShow_ProfileColorIcon == null)
                        {
                            var size = cmsDirectoryList.ImageScalingSize;
                            cmsDirectoryListPrepareAndShow_ProfileColorIcon = new System.Drawing.Bitmap(size.Width, size.Height);
                        }
                        loadOnlyProfileColorToolStripMenuItem.Image = cmsDirectoryListPrepareAndShow_ProfileColorIcon;
                        using (var g = Graphics.FromImage(cmsDirectoryListPrepareAndShow_ProfileColorIcon))
                        using (var b = new SolidBrush(firstColor))
                        {
                            g.FillRectangle(b, g.ClipBounds);
                        }
                    }
                    else
                    {
                        loadOnlyProfileColorToolStripMenuItem.Image = null;
                    }


                    /*
                    if (selectedCount == 1)
                    {
                        var lv = locationValid();
                        var fv = filterValid();
                        setCurrentLocationToolStripMenuItem.Enabled = lv;
                        setCurrentLocationAndStateToolStripMenuItem.Enabled = lv && fv;
                    }
                    else
                    {
                        setCurrentLocationToolStripMenuItem.Enabled = false;
                        setCurrentLocationAndStateToolStripMenuItem.Enabled = false;
                    }
                    */

                    dgvDirectoryList.Update();
                    //cmsDirectoryList.Show(Cursor.Position);
                    var p = e.X < 0 || e.Y < 0 ? Point.Empty : e.Location;

                    //cmsDirectoryList.Show(dgvDirectoryList.PointToScreen(p));
                    if (this != ActiveForm) Activate();
                    cmsDirectoryList.Show(dgvDirectoryList, p);
                }
                /*
                if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                {
                    foreach (DataGridViewRow row in (from DataGridViewRow r in dgvDirectoryList.SelectedRows select r).ToArray())
                    {
                        row.Selected = false;
                    }
                }
                */
            }
            else if (e.Button == MouseButtons.Left)
            {
                if (hit.RowIndex < 0 && hit.Type != DataGridViewHitTestType.ColumnHeader)
                {
                    foreach (DataGridViewRow row in dgvDirectoryList.SelectedRows.Cast<DataGridViewRow>().ToArray())
                    {
                        row.Selected = false;
                    }
                    dgvDirectoryList.CurrentCell = null;
                    dgvDirectoryList.EndEdit();
                }
            }
        }

        private static bool FileExistsWithoutException(string path)
        {
            try { return !string.IsNullOrEmpty(path) && File.Exists(path); }
            catch { return false; }
        }

        private IEnumerable<DataGridViewRow> getDirectoryListSelectedRows()
        {
            foreach (DataGridViewRow row in dgvDirectoryList.SelectedRows) yield return row;
        }

        private async void deleteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectedRows = (from DataGridViewRow row in dgvDirectoryList.SelectedRows orderby row.Index select row).ToArray();
            if (selectedRows.Length > 1)
            {
                if (!await showConfirmationDialog(Message.DoYouDeleteFollowing1Items,
                    (from row in selectedRows let name = (row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark)?.SimpleBookmark?.ToString() where name != null select name).ToArray(),
                    dialogLBound: 2, getFileName: false)) return;
            }

            var deleted = false;
            var rows = dgvDirectoryList.Rows; // await を挟むので再度取得
            foreach (var row in selectedRows)
            {
                if (rows.Contains(row))
                {
                    deleted = true;
                    rows.Remove(row);
                }
            }
            if (deleted)
            {
                saveBookmarkToIni_bookmarkChanged = true;
                saveBookmarkToConfig();
            }
        }

        private void aliasToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectedRows = dgvDirectoryList.SelectedRows;
            if (selectedRows.Count != 1) return;
            editBookmarkName(selectedRows[0]);
        }

        private void editBookmarkName(DataGridViewRow row)
        {
            var cell = row.Cells[tbcDirectoryName.Index];

            dgvDirectoryList.CurrentCell = cell;
            dgvDirectoryList.ReadOnly = false;
            dgvDirectoryList.BeginEdit(true);
        }

        private void realNameToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var renamed = false;
            foreach (DataGridViewRow row in dgvDirectoryList.SelectedRows)
            {
                var simple = (row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark)?.SimpleBookmark;
                if (simple?.SpecialRole == SimpleBookmarkSpecialRole.None && !string.IsNullOrEmpty(simple.Location))
                {
                    renamed = true;
                    simple?.SetOrResetAlias(null);
                }
            }
            if (renamed)
            {
                dgvDirectoryList.Refresh();
                saveBookmarkToIni_bookmarkChanged = true;
                saveBookmarkToConfig();
            }
        }


        private void dgvDirectoryList_CellEndEdit(object sender, DataGridViewCellEventArgs e)
        {
            if (!dgvDirectoryList.ReadOnly)
            {
                dgvDirectoryList.ReadOnly = true;
                saveBookmarkToConfig();
            }
        }

        private void dgvDirectoryList_CellParsing(object sender, DataGridViewCellParsingEventArgs e)
        {
            DataGridView dgv = (DataGridView)sender;
            if (e.RowIndex == dgv.NewRowIndex || !dgv.IsCurrentCellDirty)
            {
                return;
            }
            var alias = e.Value.ToString();
            var bookmark = dgv.Rows[e.RowIndex].Cells[e.ColumnIndex].Value as ColoredBookmark;
            if (!string.IsNullOrEmpty(alias) && alias.Length < 128)
            {
                bookmark?.SimpleBookmark?.SetOrResetAlias(alias);
            }
            e.Value = bookmark; // CellParsing 後 e.Value が対象のセルに代入されるので bookmark が参照型であることとは無関係にこの行は必要
            e.ParsingApplied = true;
            saveBookmarkToIni_bookmarkChanged = true;
        }

        private void dgvDirectoryList_KeyDown(object sender, KeyEventArgs e)
        {
            var mk = ModifierKeys;
            if (e.KeyCode == Keys.F2)
            {
                aliasToolStripMenuItem_Click(sender, e);
                LatestControledControl = sender as Control;
            }
            else if (e.KeyCode == Keys.Enter)
            {
                var sr = dgvDirectoryList.SelectedRows;
                if (sr.Count == 1)
                {
                    moveToBookmark(sr[0].Index, ApplicationProviderUser.EnterKey);
                    LatestControledControl = sender as Control;
                }
            }
            else if (commonKeyAction(e, mk))
            {
                return;
            }
            /*
            else if (e.KeyCode == Keys.Apps)
            {
                var selectedRows = dgvDirectoryList.SelectedRows;
                if (selectedRows.Count > 0)
                {
                    var selectedRow = getFirstDisplayedSelectedRow(dgvDirectoryList);
                    if (selectedRow == null) return;
                    var rect = dgvDirectoryList.GetRowDisplayRectangle(selectedRow.Index, cutOverflow: true);
                    var m2 = Math.Min(rect.Height, rect.Width) / 2;
                    var p = new Point(rect.X + m2, rect.Y + m2);
                    cmsDirectoryListPrepareAndShow(new MouseEventArgs(MouseButtons.Right, 1, p.X, p.Y, 0));
                }
                else if (dgvDirectoryList.Visible)
                {
                    cmsDirectoryListPrepareAndShow(new MouseEventArgs(MouseButtons.Right, 1, -1, -1, 0));
                }
                LatestControledControl = sender as Control;
            }
            else if (e.KeyCode == Keys.Delete)
            {
                deleteKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.X)
            {
                //cutSelection(mk);
                CutKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.C)
            {
                //copySelection(mk);
                CopyKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.V)
            {
                //pasteToCurrentLocation();
                PasteKeyAction(mk);
            }
            */
            else if (e.Alt)
            {
                e.Handled = true;
            }
        }

        private void deleteKeyAction(Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == dgvDirectoryList)
            {
                deleteToolStripMenuItem_Click(null, null);
            }
            else if (lcc == tvCatalog || lcc == dgvFileList)
            {
                deleteSelectedItems(modifierKeys);
            }
        }

        private void CopyKeyAction(Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == tvCatalog || lcc == dgvFileList)
            {
                copySelection(modifierKeys);
            }
        }

        private void PasteKeyAction(Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == tvCatalog || lcc == dgvFileList)
            {
                pasteToCurrentLocation();
            }
        }

        private void CutKeyAction(Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == tvCatalog || lcc == dgvFileList)
            {
                cutSelection(modifierKeys);
            }
        }

        private void AppsKeyAction(Keys modifierKeys)
        {
            var lcc = LatestControledControl;
            if (lcc == dgvDirectoryList)
            {
                var selectedRows = dgvDirectoryList.SelectedRows;
                if (selectedRows.Count > 0)
                {
                    var selectedRow = getFirstDisplayedSelectedRow(dgvDirectoryList);
                    if (selectedRow == null) return;
                    var rect = dgvDirectoryList.GetRowDisplayRectangle(selectedRow.Index, cutOverflow: true);
                    var m2 = Math.Min(rect.Height, rect.Width) / 2;
                    var p = new Point(rect.X + m2, rect.Y + m2);
                    cmsDirectoryListPrepareAndShow(new MouseEventArgs(MouseButtons.Right, 1, p.X, p.Y, 0));
                }
                else if (dgvDirectoryList.Visible)
                {
                    cmsDirectoryListPrepareAndShow(new MouseEventArgs(MouseButtons.Right, 1, -1, -1, 0));
                }
            }
            else if (lcc == tvCatalog)
            {
                cmsRightClickPrepareAndShowForKeyOnTvCatalog(onlyTag: false, modifierKeys: modifierKeys);
            }
            else if (lcc == dgvFileList)
            {
                cmsRightClickPrepareAndShowForKeyOnFileList(onlyTag: false, modifierKeys: modifierKeys);
            }
            else if (lcc == explorerTreeView.TreeViewWnd)
            {
                cmsRightClickPrepareAndShowForKeyOnTreeView();
            }
        }

        private void openInExplorerInDirectoryListToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectedRows = dgvDirectoryList.SelectedRows;
            if (selectedRows.Count == 1)
            {
                var path = (selectedRows[0].Cells[tbcDirectoryName.Index].Value as ColoredBookmark)?.SimpleBookmark?.Location;
                if (!string.IsNullOrEmpty(path))
                {
                    try
                    {
                        if (Directory.Exists(path))
                        {
                            Process.Start(path);
                        }
                        else
                        {
                            Program.OpenWithExplorer(path);
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }


        private void dgvDirectoryList_MouseMove(object sender, MouseEventArgs e)
        {
            if (dgvDirectoryList_MouseDown_RButtonDownIndex >= -1)
            {
                if (dgvDirectoryList_MouseDown_RButtonDownIndex != dgvDirectoryList.HitTest(e.X, e.Y).RowIndex)
                {
                    if (e.Button == MouseButtons.Right)
                    {
                        dgvDirectoryList_DragOutPart();
                    }
                    dgvDirectoryList_MouseDown_RButtonDownIndex = -2;
                }
            }
            else
            {
                dgvDirectoryList_MouseLeave_DragOutPart(e);
            }
        }

        bool dgvDirectoryList_MouseLeave_DragOutPart_Dragouting = false;
        void dgvDirectoryList_MouseLeave_DragOutPart(MouseEventArgs e)
        {
            if (dgvSorter.InRowsHolded && !dgvDirectoryList.ClientRectangle.Contains(e.Location))
            {
                dgvSorter.CancelDrag();
                if (MouseButtons == MouseButtons.Left)
                {
                    dgvDirectoryList_DragOutPart();
                }
            }
        }

        void dgvDirectoryList_DragOutPart()
        {
            try
            {
                var files = new List<string>();
                foreach (DataGridViewRow row in dgvDirectoryList.SelectedRows)
                {
                    var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                    var path = bookmark.SimpleBookmark.Location;
                    if (!string.IsNullOrEmpty(path) && (Directory.Exists(path) || File.Exists(path)))
                    {
                        files.Add(path);
                    }
                    else
                    {
                        files.Clear();
                        break;
                    }
                }

                // 他のセルに重なると同時にドラッグが発生した場合に
                // そのセルのツールチップが表示されることがある
                if (dgvDirectoryList.ShowCellToolTips)
                {
                    dgvDirectoryList.ShowCellToolTips = false;
                }

                if (files.Count == 0)
                {
                    dgvDirectoryList_MouseLeave_DragOutPart_Dragouting = true;
                    DragDropEffects dde = dgvDirectoryList.DoDragDrop(new string[0], DragDropEffects.None);
                }
                else
                {
                    //DataObjectを作成する
                    DataObject dataObj = new DataObject(DataFormats.FileDrop, files.ToArray());
                    dgvDirectoryList_MouseLeave_DragOutPart_Dragouting = true;
                    DragDropEffects dde = dgvDirectoryList.DoDragDrop(dataObj, DragDropEffects.All);
                }

            }
            catch (Exception ex)
            {
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            finally
            {
                dgvDirectoryList_MouseLeave_DragOutPart_Dragouting = false;

                // このタイミングで戻すと非表示中に本来表示されたものがドロップ後に表示されてしまうので
                // 次の DragEnter で戻す
                //dgvDirectoryList.ShowCellToolTips = true;
            }
        }

        private void dgvDirectoryList_QueryContinueDrag(object sender, QueryContinueDragEventArgs e)
        {
            if (((Keys)e.KeyState & (Keys.LButton | Keys.RButton)) == (Keys.LButton | Keys.RButton))
            {
                e.Action = DragAction.Cancel;
            }
        }

        private bool dgvDirectoryList_DragEnter_ByLeftClick;
        private void dgvDirectoryList_DragEnter(object sender, DragEventArgs e)
        {
            if (dgvDirectoryList_MouseLeave_DragOutPart_Dragouting)
            {
                e.Effect = DragDropEffects.None;
                return;
            }
            try
            {
                if ((e.KeyState == DragEventKeyState_LeftButton || e.KeyState == (int)Keys.RButton) && e.Data.GetDataPresent(DataFormats.FileDrop))
                {
                    //string[] Files = (string[])e.Data.GetData(DataFormats.FileDrop, false);
                    //string[] Files = (from rawPath in (string[])e.Data.GetData(DataFormats.FileDrop, false) select Program.GetTargetIfItIsLink(rawPath)).ToArray();
                    string[] Files = ShortcutResolver.Exec((string[])e.Data.GetData(DataFormats.FileDrop, false)).ToArray();
                    //if (Files.All(file => VirtualFolder.DirectoryOrBookmarkExists(file)))
                    //if (Files.Any(file => VirtualFolder.DirectoryOrBookmarkExists(file)))
                    if (Files.Any(file => Directory.Exists(file) || IsSupportedByCatalogFormExceptFolder(file) && File.Exists(file)))
                    {
                        dgvDirectoryList_DragEnter_ByLeftClick = e.KeyState == (int)Keys.LButton;
                        e.Effect = DragDropEffects.Copy;
                    }
                    else
                    {
                        e.Effect = DragDropEffects.None;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            catch (Exception error)
            {
                Program.AlertError(error);
            }
        }

        private Tuple<string[], Point> dgvDirectoryList_DragDrop_DropInfo = null;
        private void dgvDirectoryList_DragDrop(object sender, DragEventArgs e)
        {
            if (dgvDirectoryList_MouseLeave_DragOutPart_Dragouting)
            {
                return;
            }
            try
            {
                if (e.Data.GetDataPresent(DataFormats.FileDrop))
                {
                    //var Files = ((string[])e.Data.GetData(DataFormats.FileDrop, false));
                    //string[] Files = (from rawPath in (string[])e.Data.GetData(DataFormats.FileDrop, false) select Program.GetTargetIfItIsLink(rawPath)).ToArray();
                    string[] Files = ShortcutResolver.Exec((string[])e.Data.GetData(DataFormats.FileDrop, false)).ToArray();

                    var dropInfo = Tuple.Create(Files, new Point(e.X, e.Y));

                    if (!dgvDirectoryList_DragEnter_ByLeftClick)
                    {
                        dgvDirectoryList_DragDrop_DropInfo = dropInfo;
                        if (this != Form.ActiveForm) Activate();
                        cmsDirectoryListRightClickDrop.Show(e.X, e.Y);
                    }
                    else
                    {
                        dgvDirectoryList_DragDrop_core(setNewColor: false, dropInfo: dropInfo);
                    }
                }
            }
            catch (Exception error)
            {
                Program.AlertError(error);
            }
        }

        private void cmsDirectoryListRightClickDrop_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
        }

        private void cmsDirectoryListRightClickDrop_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            if (e.CloseReason != ToolStripDropDownCloseReason.ItemClicked)
            {
                dgvDirectoryList_DragDrop_DropInfo = null;
            }
            AllowFullpower = true;
        }


        private void addToBookmarkWithCurrentProfileColorRightClickDropToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dgvDirectoryList_DragDrop_DropInfo != null)
            {
                try
                {
                    dgvDirectoryList_DragDrop_core(setNewColor: false, dropInfo: dgvDirectoryList_DragDrop_DropInfo);
                    dgvDirectoryList_DragDrop_DropInfo = null;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void addToBookmarkWithNewProfileColorRightClickDropToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (dgvDirectoryList_DragDrop_DropInfo != null)
            {
                try
                {
                    dgvDirectoryList_DragDrop_core(setNewColor: true, dropInfo: dgvDirectoryList_DragDrop_DropInfo);
                    dgvDirectoryList_DragDrop_DropInfo = null;
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void dgvDirectoryList_DragDrop_core(bool setNewColor, Tuple<string[], Point> dropInfo)
        {
            Color newColor;
            if (setNewColor)
            {
                AllowFullpower = false;
                newColor = getNewProfileColorFromDialog(useCurrentAsDefault: false);
                AllowFullpower = true;
                if (newColor.IsEmpty) return;
            }
            else
            {
                newColor = currentProfileColor;
            }

            var bookmarks = new List<ColoredBookmark>();
            foreach (var file in dropInfo.Item1)
            {
                if (Directory.Exists(file))
                {
                    var path = Path.GetFullPath(GetDirectoryPathWithSeparator(file));
                    if (path.EndsWith(Path.DirectorySeparatorChar.ToString())) path = path.Substring(0, path.Length - 1);
                    bookmarks.Add(currentConditionToColoredBookmark(newColor, path));
                }
                else if (IsSupportedByCatalogFormExceptFolder(file) && File.Exists(file))
                {
                    var path = Path.GetFullPath(file);
                    bookmarks.Add(currentConditionToColoredBookmark(newColor, path));
                }
            }

            if (bookmarks.Count > 0)
            {
                var p = dgvDirectoryList.PointToClient(dropInfo.Item2);
                var hit = dgvDirectoryList.HitTest(p.X, p.Y);

                addCatalogBookmarkToList(bookmarks, hit.RowIndex >= 0 ? hit.RowIndex : int.MaxValue);

                // 表示色が変わってしまうので追加された項目の選択は行わない

                saveBookmarkToIni_bookmarkChanged = true;
                saveBookmarkToConfig();
            }
        }

        private void tvCatalog_ShowIndexToDataIndexChanged(object sender, EventArgs e)
        {
            var itemsCount = tvCatalog.ShowIndexToDataIndex.Length;
            itemsCountToolStripStatusLabel.Text = itemsCount >= 0 ? Message._1Items.Replace("$1", itemsCount.ToString()) : "";
        }

        private void letterboxToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                clipModeByControl = ClipMode.Letterbox;
                ChangeThumbnailSize(null);
                UpdatePreview();
            }
        }

        private void panAndScanToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                clipModeByControl = ClipMode.PanAndScan;
                ChangeThumbnailSize(null);
                UpdatePreview();
            }
        }

        private void plaClipToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                clipModeByControl = ClipMode.PlaClip;
                ChangeThumbnailSize(null);
                UpdatePreview();
            }
        }

        private void statusStrip_SizeChanged(object sender, EventArgs e)
        {
            Program.TextBoxShowRight(selectedFileNameToolStripTextBox);
        }

        // private string cbFilter_DropDown_Text = null;
        private void cbFilter_DropDown(object sender, EventArgs e)
        {
            setCurrentFilterToHistory(bringToTop: false);
        }

        private readonly Dictionary<string, SizeF> cbFilter_DrawItem_SizeDictionary = new Dictionary<string, SizeF>();
        private void cbFilter_DrawItem(object sender, DrawItemEventArgs e)
        {
            var index = e.Index;
            if (index < 0) return;
            var items = cbFilter.Items;
            if (index >= items.Count) return;
            var text = items[index].ToString();
            var size = MeasureStringSizeByGraphics(e.Graphics, text, cbFilter.Font, cbFilter_DrawItem_SizeDictionary); //e.Graphics.MeasureString(text, cbFilter.Font);
            var rect = e.Bounds;
            Color color;
            var selected = (e.State & DrawItemState.Selected) == DrawItemState.Selected;

            if (selected)
            {
                color = SystemColors.Highlight;
            }
            else if (aliasesToFilteringStrings != null && aliasesToFilteringStrings.ContainsKey(text))
            {
                color = AliasColor;
            }
            else
            {
                color = SystemColors.Window;
            }
            using (var b = new SolidBrush(color))
            {
                e.Graphics.FillRectangle(b, rect);
            }
            rect.Y += (int)Math.Ceiling((rect.Height - size.Height) / 2);
            e.Graphics.DrawString(text, cbFilter.Font, selected ? SystemBrushes.HighlightText : SystemBrushes.WindowText, rect);
        }


        private void btnGoToBack_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                //showUndoBufferList(0, undoBufferIndex + 1);
                showUndoBufferList(0, undoBuffer.Count);
            }
        }

        private void btnGoToForward_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                //showUndoBufferList(undoBufferIndex, undoBuffer.Count);
                showUndoBufferList(0, undoBuffer.Count);
            }
        }

        private ContextMenuStrip showUndoBufferList_ContextMenuStrip = null;
        private void showUndoBufferList(int fromInclusive, int toExclusive)
        {
            if (fromInclusive < 0 || fromInclusive >= toExclusive || toExclusive > undoBuffer.Count) return;

            ContextMenuStrip cms;
            if (showUndoBufferList_ContextMenuStrip != null)
            {
                cms = showUndoBufferList_ContextMenuStrip;
                foreach (var item in (from ToolStripMenuItem item in cms.Items select item).ToArray())
                {
                    item.Dispose();
                }
            }
            else
            {
                cms = new ContextMenuStrip();
                cms.Closed += (sender2, e2) =>
                {
                    AllowFullpower = true;
                };
                ToolStripDropDownScroller.Enscrollable(cms, ToolStripDropDownScroller.GetGestureListener(cms));
                showUndoBufferList_ContextMenuStrip = cms;
            }
            var items = new ToolStripMenuItem[toExclusive - fromInclusive];
            for (var i = fromInclusive; i < toExclusive; i++)
            {
                var buf = undoBuffer[i];
                var path = buf.Location;
                var item = new ToolStripMenuItem(SimpleBookmark.GetDisplayName(path));

                if (i == undoBufferIndex)
                {
                    item.Font = new Font(item.Font, FontStyle.Bold);
                    item.CheckState = CheckState.Indeterminate;
                }
                else
                {
                    item.Font = new Font(item.Font, FontStyle.Regular);
                    var ii = i;
                    item.Click += (sender2, e2) =>
                    {
                        gotToUnderBuffer(ii, ApplicationProviderUser.MouseClick);
                    };
                }

                var backColor = buf.ProfileColor;
                var foreColor = ZipTag.GetForeColor(backColor);
                item.BackColor = backColor;
                item.ForeColor = foreColor;

                if (ColorEquals(foreColor, Color.White))
                {
                    item.ForeColor = foreColor;
                    ForeColorManager.Set(item);
                    /*
                    EventHandler ev = (sender, e) => SetMenuItemColor(item, foreColor);
                    item.DropDownOpening += ev;
                    item.DropDownClosed += ev;
                    item.MouseEnter += ev;
                    item.MouseLeave += ev;
                    */
                }

                CheckMarkProvider.SetCheckMark(cms, item, DisplayCheckMark.Select);

                items[toExclusive - i - 1] = item;
            }

            cms.Items.AddRange(items);


            var maxSize = cms.MaximumSize;
            var area = Screen.FromControl(btnGoToBack).WorkingArea;
            var buttonBound = RectangleToScreen(btnGoToBack.Bounds);
            cms.MaximumSize = new Size(maxSize.Width, Math.Max(buttonBound.Height * 2 * SystemInformation.MouseWheelScrollLines, area.Bottom - (buttonBound.Bottom - 1)));

            AllowFullpower = false;
            if (this != ActiveForm) Activate();
            cms.Show(new Point(buttonBound.Left, buttonBound.Bottom - 1));
        }

        private void tagEditorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            showTagEditor();
        }

        private void showTagEditor(IReadOnlyList<string> newTags = null, bool needToSaveCurrentTag = false)
        {
            if (CreatingZipPathArray) return;
            AllowFullpower = false;
            var edited = Program.ShowTagEditor(this, newTags);
            AllowFullpower = true;
            if (edited)
            {
                setTagFilteringMenuItems(needToRepairTagsFromBookmark: false, needToSaveCurrentTag: needToSaveCurrentTag);

                if (showTags)
                {
                    tvCatalog.Invalidate();
                }
                setFileListFromThumbnailViewer();
                /*
                if (showTags)
                {
                    UpdatePreview();
                }
                else
                {
                    lock (ZipPathArrayLocker)
                    {
                        setFileListFromThumbnailViewer();
                    }
                }
                */
            }
        }

        //● ロッカージェスチャ
        //● private readonly System.Windows.Forms.ContextMenuStrip cbFilter_MouseDown_DummyCMS = new System.Windows.Forms.ContextMenuStrip();
        private int cbFilter_MouseDown_LastClickTime = Environment.TickCount - SystemInformation.DoubleClickTime;
        private void cbFilter_MouseDown(object sender, MouseEventArgs e)
        {
            //● var leftRight = false;
            if (e.Button == MouseButtons.Middle
                //● || (leftRight = MouseButtons == (MouseButtons.Left | MouseButtons.Right))
                )
            {
                var currentText = cbFilter.Text;
                if (string.IsNullOrEmpty(currentText))
                {
                    var s = GetClipBoardShortString();
                    if (!string.IsNullOrEmpty(s))
                    {
                        cbFilter.Text = s;
                        cbFilter.SelectAll();
                    }
                }
                else
                {
                    cbFilter.Text = "";
                }
            }

            /*●
            if (leftRight)
            {
                cbFilter.ContextMenuStrip = cbFilter_MouseDown_DummyCMS;
            }
            else
            {
                cbFilter.ContextMenuStrip = null;
            }
            */
        }

        private void cbFilter_MouseUp(object sender, MouseEventArgs e)
        {
            //● if (e.Button == MouseButtons.Right) cbFilter.ContextMenuStrip = null;
        }

        private static string GetClipBoardShortString()
        {
            try
            {
                // ファイル優先
                var data = Clipboard.GetDataObject();
                if (data == null) return null;
                if (data.GetDataPresent(DataFormats.FileDrop))
                {
                    var files = (string[])data.GetData(DataFormats.FileDrop);
                    if (files.Length > 0)
                    {
                        return Path.GetFileName(files[0]);
                    }
                    return null;
                }

                if (data.GetDataPresent(NativeMethods.CFSTR_FILEDESCRIPTORW))
                {

                    var descriptorData = data.GetData(NativeMethods.CFSTR_FILEDESCRIPTORW) as Stream;
                    if (descriptorData == null) return null;

                    DataObjectEx.FILEDESCRIPTOR[] fileDescriptors;
                    using (descriptorData)
                    {
                        fileDescriptors = DataObjectEx.FILEDESCRIPTOR.FromStreamToArray(descriptorData);
                    }
                    if (fileDescriptors.Length == 0) return null;

                    return Path.GetFileName(fileDescriptors[0].cFileName);
                }

                if (data.GetDataPresent(DataFormats.UnicodeText))
                {
                    return GetShortString((string)data.GetData(DataFormats.UnicodeText));
                }

                /*
                if (Clipboard.ContainsText())
                {
                    return GetShortString(Clipboard.GetText());
                }*/
                return null;
            }
            catch
            {
                return null;
            }
        }

        //private static readonly char[] GetALineFromString_Spaces = new char[] { ' ', '\t', '　' };
        private static readonly char[] GetShortString_Spaces = new char[] { ' ', '\t', '\r', '\n' };
        //private static Regex GetALineFromString_SpacesReplacer = new Regex("(?:" + string.Join("|", GetALineFromString_Spaces) + ")+", RegexOptions.Compiled);
        private static string GetShortString(string input)
        {
            const int maxLen = 1000;
            var b = new StringBuilder();
            var outOfSpace = false;
            var count = 0;
            var lastSpace = 0;
            foreach (var c in input)
            {
                if (count >= maxLen)
                {
                    if (!GetShortString_Spaces.Contains(c))
                    {
                        b.Remove(lastSpace, maxLen - lastSpace);
                        outOfSpace = true;
                    }
                    break;
                }
                if (GetShortString_Spaces.Contains(c))
                {
                    if (outOfSpace)
                    {
                        outOfSpace = false;
                        b.Append(' ');
                        lastSpace = count;
                        count++;
                    }
                }
                else
                {
                    outOfSpace = true;
                    b.Append(c);
                    count++;
                }
            }
            if (!outOfSpace)
            {
                b.Remove(lastSpace, 1);
            }
            return b.ToString();

            /*
            using (var r = new StringReader(input))
            {
                while (r.Peek() > -1)
                {
                    var line = r.ReadLine().Trim(GetALineFromString_Spaces);
                    if(line != "")
                    {
                        line = GetALineFromString_SpacesReplacer.Replace(line, " ");

                        return line.Length <= maxLen ? line : line.Substring(0, maxLen);
                    }
                }
            }
            return null;
            */
        }

        /*
        private void moveToThisFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (currentLocation != preCurrentLocation) return;
            var selectedIndex = tvCatalog.SelectedIndex;
            if (selectedIndex < 0) return;
            string path;
            string name;
            lock (ZipPathArrayLocker)
            {
                if (selectedIndex >= ZipPathArray.Length) return;
                path = ZipPathArray[selectedIndex];
                name = ZipNameArray[selectedIndex];
            }
            if (!name.EndsWith(Path.DirectorySeparatorChar.ToString())) return;

            zabLocation.Text = path;
            MakePreview();
        }
        */
        public void MoveLocation(ApplicationProviderUser user, string path)
        {
            if (path == null) return;

            if (IsKeyboard(user))
            {
                bmwMakePreviewRunWorkerStartingFinalAction = () =>
                {
                    firstShownItemSelect();
                    bmwMakePreviewRunWorkerStartingFinalAction = null;
                };
            }

            var interval = getSubdivideInterval(path);
            if (interval == null)
            {
                if (IsSupportedByCatalogFormAndExists(path))
                {
                    zabLocation.Text = path;
                    MakePreview();
                }
                else
                {
                    var parent = Program.ItsSelfOrExistingParentDirectory(path, IsSupportedByCatalogFormAndExists);
                    string child = "";
                    try
                    {
                        //child = Path.GetFileName(path);
                        child = getFileName(path); // 動画の Duration を想定
                    }
                    catch { }
                    zabLocation.Text = parent;
                    MakePreview(child);
                }
            }
            else
            {
                var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
                if (altPos < 0) return;
                var parent = path.Substring(0, altPos);
                zabLocation.Text = parent;
                MakePreview(subdivideInterval: interval);
            }
        }

        public bool Subdividable(string path)
        {
            return getSubdivideInterval(path) != null;
        }

        private Tuple<TimeSpan, TimeSpan> getSubdivideInterval(string path)
        {
            if (string.IsNullOrEmpty(path)) return null;
            if (!InMovie) return null;
            var zpa = ZipPathArray;
            if (zpa == null || zpa.Length <= 1) return null;
            var index = Array.IndexOf(zpa, path);
            if (index < 0) return null;
            var path0 = index > 0 ? zpa[index - 1] : null;
            //if (string.IsNullOrEmpty(path0)) return null;
            var path1 = index < zpa.Length - 1 ? zpa[index + 1] : null;
            //if (string.IsNullOrEmpty(path1)) return null;
            var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            if (altPos < 0 || altPos >= path.Length - 1 || path0 != null && altPos >= path0.Length - 1 || path1 != null && altPos >= path1.Length - 1) return null;
            TimeSpan t; if (!TimeSpan.TryParse(path.Substring(altPos + 1), out t)) return null;
            TimeSpan t0; if (path0 == null) t0 = TimeSpan.FromSeconds(-1); else if (!TimeSpan.TryParse(path0.Substring(altPos + 1), out t0)) return null;
            TimeSpan t1; if (path1 == null) t1 = TimeSpan.MaxValue; else if (!TimeSpan.TryParse(path1.Substring(altPos + 1), out t1)) return null;
            t0 += TimeSpan.FromSeconds(1); if (t0 > t) t0 = t;
            t1 -= TimeSpan.FromSeconds(1); if (t1 < t) t1 = t;
            return t - t0 > TimeSpan.FromSeconds(0.5) || t1 - t > TimeSpan.FromSeconds(0.5) ? Tuple.Create(t0, t1) : null;
        }

        private void setTagFilteringMenuItems(bool needToRepairTagsFromBookmark, bool needToSaveCurrentTag, bool loadFromIni = false)
        {
            var config = new ZipTagConfig();
            if (config.ProfileColor == currentProfileColor)
            {
                Tags = config.Tags;
                synchronizeCurrentProfile();
                if (!loadFromIni)
                {
                    saveBookmarkToIni_bookmarkChanged = true;
                    saveBookmarkToConfig();
                }
            }
            else
            {
                if (needToRepairTagsFromBookmark)
                {
                    Tags = null;
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None && bookmark?.Color == currentProfileColor) // セパレーターなら無視される
                        {
                            var tags = bookmark?.Profile?.Tags;
                            if (tags != null)
                            {
                                Tags = tags;
                                break;
                            }
                        }
                    }
                }

                if (Tags == null) Tags = new ZipTag[0];
                if (needToSaveCurrentTag)
                {
                    config.Tags = Tags;
                    config.ProfileColor = currentProfileColor;
                    config.Save();
                }
            }
            setTagFilteringMenuItems(Tags);
        }


        private ToolStripDropDown[] setTagFilteringMenuItems_DropDown;
        private void setTagFilteringMenuItems(ZipTag[] tags)
        {
            if (tags == null) tags = new ZipTag[0];

            var items = menuStripForTagFilter.Items;
            var newCount = tags.Length;


            if (newCount == items.Count - 1)
            {
                var same = true;
                for (var i = 0; i < newCount; i++)
                {
                    var tag = tags[i];
                    var item = items[i + 1];
                    if (tag.Name != getTextForTagToolStripMenuItem(item) || tag.BackColor != item.BackColor)
                    {
                        same = false;
                        break;
                    }
                }
                if (same)
                {
                    setTagFilterLocation();
                    return;
                }
            }

            var newItems = new ToolStripItem[newCount + 1];
            newItems[0] = ratingFilterToolStripMenuItem;

            setTagFilteringMenuItems_DropDown = new ToolStripDropDown[newCount];

            for (var i = 0; i < newCount; i++)
            {
                var tag = tags[i];
                var tagName = tag.Name.Replace("&", "&&");
                var tsmi = new ToolStripMenuItem(tagName);
                tsmi.BackColor = tag.BackColor;
                tsmi.ForeColor = tag.ForeColor;
                tsmi.Overflow = ToolStripItemOverflow.AsNeeded;
                tsmi.MouseDown += Tsmi_MouseDown;
                tsmi.Click += Tsmi_Click;

                var tsmiItems = new ToolStripMenuItem[6];
                tsmiItems[0] = new ToolStripMenuItem(Message.AndInclude1.Replace("$1", tagName));
                tsmiItems[0].Click += tagAndInclude1_Click;
                //tsmiItems[0].ShortcutKeyDisplayString = Message.LeftClick;
                tsmiItems[1] = new ToolStripMenuItem(Message.AndExclude1.Replace("$1", tagName));
                tsmiItems[1].Click += tagAndExclude1_Click;
                //tsmiItems[1].ShortcutKeyDisplayString = "Shift+" + Message.LeftClick;
                tsmiItems[2] = new ToolStripMenuItem(Message.Include1.Replace("$1", tagName));
                tsmiItems[2].Click += tagInclude1_Click;
                //tsmiItems[2].ShortcutKeyDisplayString = Message.MiddleClick;
                tsmiItems[3] = new ToolStripMenuItem(Message.Exclude1.Replace("$1", tagName));
                tsmiItems[3].Click += tagExclude1_Click;
                //tsmiItems[3].ShortcutKeyDisplayString = "Shift+" + Message.MiddleClick;
                tsmiItems[4] = new ToolStripMenuItem(Message.OrInclude1.Replace("$1", tagName));
                tsmiItems[4].Click += tagOrInclude1_Click;
                //tsmiItems[4].ShortcutKeyDisplayString = "Ctrl+" + Message.LeftClick;
                tsmiItems[5] = new ToolStripMenuItem(Message.OrExclude1.Replace("$1", tagName));
                tsmiItems[5].Click += tagOrExclide1_Click;
                //tsmiItems[5].ShortcutKeyDisplayString = "Ctrl+Shift+" + Message.LeftClick;
                tsmi.DropDownItems.AddRange(tsmiItems);

                tsmi.ToolTipText = Message.RightClickDownFlickToOpenContextMenu;

                tsmi.DropDownClosed += Tsmi_DropDownClosed;
                tsmi.MouseEnter += Tsmi_MouseEnter;
                tsmi.MouseLeave += Tsmi_MouseLeave;

                var normalColor = tag.ForeColor;
                if (ColorEquals(normalColor, Color.White))
                {
                    tsmi.ForeColor = normalColor;
                    ForeColorManager.Set(tsmi);
                }

                var dropDown = tsmi.DropDown;
                dropDown.Opened += Tsmi_DropDownOpened;
                setTagFilteringMenuItems_DropDown[i] = dropDown;
                tsmi.DropDown = null;

                ToolStripOverwriter.SquarizeToolStrip(dropDown);

                newItems[i + 1] = tsmi;
            }

            items.Clear();
            menuStripForTagFilter.AutoSize = true;
            items.AddRange(newItems);
            menuStripForTagFilter.AutoSize = false;

            setTagFilterLocation_WidthMemory = (from item in newItems select item.Width).ToArray();

            setTagFilterLocation();
        }

        private void Tsmi_Click(object sender, EventArgs e)
        {
            var mk = ModifierKeys;
            if ((mk & (Keys.Control | Keys.Shift)) == (Keys.Control | Keys.Shift))
            {
                tagOrExclide1_Click(sender, e);
            }
            else if ((mk & Keys.Control) == Keys.Control)
            {
                tagOrInclude1_Click(sender, e);
            }
            else if ((mk & Keys.Shift) == Keys.Shift)
            {
                tagAndExclude1_Click(sender, e);
            }
            else
            {
                tagAndInclude1_Click(sender, e);
            }
        }

        private void Tsmi_MouseDown(object sender, MouseEventArgs e)
        {
            var mk = ModifierKeys;
            if (e.Button == MouseButtons.Middle)
            {
                if ((mk & Keys.Shift) == Keys.Shift)
                {
                    tagExclude1_Click(sender, e);
                }
                else
                {
                    tagInclude1_Click(sender, e);
                }
            }
            else if (e.Button == MouseButtons.Right)
            {
                OpenTagButtonDropdown(sender as ToolStripMenuItem, byTouch: false);
                /*
                var tsmi = sender as ToolStripMenuItem;
                var items = menuStripForTagFilter.Items;
                var dropDown = setTagFilteringMenuItems_DropDown[items.IndexOf(tsmi) - 1];
                tsmi.DropDown = dropDown;
                tagFilterToolStripMenuItem_DropDownOpening(tsmi);
                dropDown.Show();
                */
            }
        }

        private void OpenTagButtonDropdown(ToolStripMenuItem tsmi, bool byTouch)
        {
            var items = menuStripForTagFilter.Items;
            var dropDown = setTagFilteringMenuItems_DropDown[items.IndexOf(tsmi) - 1];
            tsmi.DropDown = dropDown;
            tagFilterToolStripMenuItem_DropDownOpening(tsmi);

            setTagOrRatingButtonShortcutKeyDisplayString(dropDown, byTouch);

            dropDown.Show();
        }

        private void setTagOrRatingButtonShortcutKeyDisplayString(ToolStripDropDown dropDown, bool byTouch)
        {
            var items = dropDown.Items;
            var os = items.Count - 6;
            if (os >= 0)
            {
                if (byTouch)
                {
                    (items[os + 0] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.Tap;
                    (items[os + 1] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.UpFlick;
                    (items[os + 2] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.LeftFlick;
                    (items[os + 3] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.LeftUpFlick;
                    (items[os + 4] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.RightFlick;
                    (items[os + 5] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.RightUpFlick;
                }
                else
                {
                    (items[os + 0] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.LeftClick;
                    (items[os + 1] as ToolStripMenuItem).ShortcutKeyDisplayString = "Shift+" + Message.LeftClick;
                    (items[os + 2] as ToolStripMenuItem).ShortcutKeyDisplayString = Message.MiddleClick;
                    (items[os + 3] as ToolStripMenuItem).ShortcutKeyDisplayString = "Shift+" + Message.MiddleClick;
                    (items[os + 4] as ToolStripMenuItem).ShortcutKeyDisplayString = "Ctrl+" + Message.LeftClick;
                    (items[os + 5] as ToolStripMenuItem).ShortcutKeyDisplayString = "Ctrl+Shift+" + Message.LeftClick;
                }
            }
        }

        private void tagOrExclide1_Click(object sender, EventArgs e)
        {
            filterAdd("+-" + SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender), stopwords: null), weak: false);
        }

        private void tagOrInclude1_Click(object sender, EventArgs e)
        {
            filterAdd("+" + SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender), stopwords: null), weak: false);
        }

        private void tagAndExclude1_Click(object sender, EventArgs e)
        {
            filterAdd("-" + SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender), stopwords: null), weak: true);
        }

        private void tagAndInclude1_Click(object sender, EventArgs e)
        {
            filterAdd(SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender),
                string.IsNullOrEmpty(cbFilter.Text) ? aliasesToFilteringStrings?.Keys : null // 別名に空白は含まれないので。
                ), weak: true);
        }

        private void tagExclude1_Click(object sender, EventArgs e)
        {
            cbFilter.Text = "-" + SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender), stopwords: null);
            cbFilter.SelectAll();
        }

        private void tagInclude1_Click(object sender, EventArgs e)
        {
            cbFilter.Text = SearchManager.TrimAndPutQuotationIfNeeded(getTextForTagToolStripMenuItem(sender), aliasesToFilteringStrings?.Keys);
            cbFilter.SelectAll();
        }

        private string getTextForTagToolStripMenuItem(object sender)
        {
            var tsmi = sender as ToolStripMenuItem;
            if (tsmi == null) return "";
            var owner = tsmi.OwnerItem;
            string result;
            if (owner == null)
            {
                result = tsmi.Text.Replace("&&", "&");
            }
            else
            {
                result = owner.Text.Replace("&&", "&");
            }
            return result;
        }

        private void Tsmi_MouseLeave(object sender, EventArgs e)
        {
            GeneralMouseLeave(sender);
        }

        private void Tsmi_MouseEnter(object sender, EventArgs e)
        {
            GeneralMouseEnter(sender);
        }

        private void Tsmi_DropDownOpened(object sender, EventArgs e)
        {
            setFilterDropDownLocation(sender as ToolStripDropDownMenu);
        }

        private void Tsmi_DropDownClosed(object sender, EventArgs e)
        {
            AllowFullpower = true;
            var tsmi = sender as ToolStripMenuItem;
            tsmi.DropDown = null;
        }

        private void tagFilterToolStripMenuItem_DropDownOpening(ToolStripMenuItem tsmi)
        {
            var str = getTextForTagToolStripMenuItem(tsmi);
            var addableWeak = filterAddable(str, weak: true);
            var addableStrong = filterAddable(str, weak: false);
            var items = tsmi.DropDownItems;
            items[0].Enabled = addableWeak;
            items[1].Enabled = addableWeak;
            items[4].Enabled = addableStrong;
            items[5].Enabled = addableStrong;

            AllowFullpower = false;
        }

        private FormWindowState CatalogForm_SizeChanged_PreState = FormWindowState.Normal;
        private FormWindowState CatalogForm_SizeChanged_BeforeMinimizedState = FormWindowState.Normal;
        private void CatalogForm_SizeChanged(object sender, EventArgs e)
        {
            var state = WindowState;
            if (state != FormWindowState.Minimized)
            {
                setCbFilterWidth();
                setTagFilterLocation();
                setMainPanelWidth();
            }
            else if (CatalogForm_SizeChanged_PreState != FormWindowState.Minimized)
            {
                CatalogForm_SizeChanged_BeforeMinimizedState = CatalogForm_SizeChanged_PreState;
            }

            if (CatalogForm_SizeChanged_PreState != state)
            {
                if (CatalogForm_SizeChanged_PreState == FormWindowState.Minimized && state != FormWindowState.Minimized)
                {
                    CatalogForm_Activated(this, e);
                }

                CatalogForm_SizeChanged_PreState = state;
            }
        }

        private bool getShouldBeShowTagFilter()
        {
            // visible のチェック方法は saveSetting に倣う
            return showRating && thumbnailListToolStripMenuItem.Checked || tbcRating.Visible && fileListToolStripMenuItem.Checked;
        }

        private void setTagfilterLocationIfRatingFilterVisibleChanged()
        {
            var newRatingFilterVisible = getShouldBeShowTagFilter();
            if (ratingFilterToolStripMenuItem.Visible != newRatingFilterVisible)
            {
                setTagFilterLocation(newRatingFilterVisible);
            }
        }

        private int[] setTagFilterLocation_WidthMemory = new int[1]; // rating の分
        private ToolStripMenuItem setTagFilterLocation_rightSideToolStripMenuItem = null;
        private void setTagFilterLocation(bool? ratingFilterVisible = null)
        {
            if (!IsShown) return;
            /*
            if (WindowState == FormWindowState.Normal)
            {
                SaveSettings_WindowSizeWhenNotMaximized = Size;
                SaveSettings_WindowLocationWhenNotMaximized = Location;
            }
            */

            if (setTagFilterLocation_rightSideToolStripMenuItem == null)
            {
                setTagFilterLocation_rightSideToolStripMenuItem = (ToolStripMenuItem)(from ToolStripItem item in menuStrip.Items select item).Last(item => item.Visible);
            }

            var ratingFilterVisible_ = ratingFilterVisible != null ? (bool)ratingFilterVisible : getShouldBeShowTagFilter();
            ratingFilterToolStripMenuItem.Visible = ratingFilterVisible_;

            var ofb = menuStripForTagFilter.OverflowButton;
            var ofbWidth = ofb.Width + 1;
            var allowedWidth = menuStrip.Right - setTagFilterLocation_rightSideToolStripMenuItem.Bounds.Right - ofbWidth;
            var items = menuStripForTagFilter.Items;
            var count = items.Count;
            if (setTagFilterLocation_WidthMemory.Length != count) return;
            var padding = menuStripForTagFilter.Padding;
            var width = padding.Left + padding.Right;
            var left = items[0].Bounds.Left;
            var fullShow = false;
            for (var i = 0; i < count; i++)
            {
                var testWidth = width + (i == 0 ? ratingFilterVisible_ ? ratingFilterToolStripMenuItem.Width : 0 : setTagFilterLocation_WidthMemory[i]);
                if (testWidth <= allowedWidth)
                {
                    width = testWidth;
                }
                else
                {
                    if (i == count - 1 && testWidth <= allowedWidth + ofbWidth)
                    {
                        width = testWidth;
                        fullShow = true;
                    }
                    break;
                }
                if (i == count - 1) fullShow = true;
            }
            if (!fullShow)
            {
                menuStripForTagFilter.CanOverflow = true;
                width += ofbWidth;
            }
            else
            {
                menuStripForTagFilter.CanOverflow = false;
            }

            SuspendLayout();
            menuStripForTagFilter.Width = width;
            menuStripForTagFilter.Left = menuStrip.Right - width;
            ResumeLayout();
        }

        // これは実際には登録していない
        // Show で開いた場合 Opening は呼ばれない
        private void ratingFilterToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
        {
            const string rateStrPrototype = "r=5";
            var addableWeak = filterAddable(rateStrPrototype, weak: true);
            var addableStrong = filterAddable(rateStrPrototype, weak: false);
            var stars = getRatingReverenceStars();
            equalToXToolStripMenuItem.Text = Message.EqualTo1.Replace("$1", stars);
            greaterThanOrEqualToXToolStripMenuItem.Text = Message.GreaterThanOrEqualTo1.Replace("$1", stars);
            andEqualToXToolStripMenuItem.Text = Message.AndEqualTo1.Replace("$1", stars);
            andGreaterThanOrEqualToXToolStripMenuItem.Text = Message.AndGreaterThanOrEqualTo1.Replace("$1", stars);
            orEqualToXToolStripMenuItem.Text = Message.OrEqualTo1.Replace("$1", stars);
            orGreaterThanOrEqualToXToolStripMenuItem.Text = Message.OrGreaterThanOrEqualTo1.Replace("$1", stars);
            andEqualToXToolStripMenuItem.Enabled = addableWeak;
            andGreaterThanOrEqualToXToolStripMenuItem.Enabled = addableWeak;
            orEqualToXToolStripMenuItem.Enabled = addableStrong;
            orGreaterThanOrEqualToXToolStripMenuItem.Enabled = addableStrong;
            ratingFilterToolStripMenuItemDropDown.AutoClose = true;
            var value = ratingReferenceValue;
            increaseReferenceValueToolStripMenuItem.Enabled = value < 5;
            decreaseReferenceValueToolStripMenuItem.Enabled = value > 1;
            AllowFullpower = false;
        }

        private void ratingFilterToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {
            AllowFullpower = true;
            ratingFilterToolStripMenuItem_Dropdowned = false;
            ratingFilterToolStripMenuItem.DropDown = null;
        }

        private void ratingFilterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var mk = ModifierKeys;
            if ((mk & (Keys.Control | Keys.Shift)) == (Keys.Control | Keys.Shift))
            {
                orEqualToXToolStripMenuItem_Click(null, null);
            }
            else if ((mk & Keys.Control) == Keys.Control)
            {
                orGreaterThanOrEqualToXToolStripMenuItem_Click(null, null);
            }
            else if ((mk & Keys.Shift) == Keys.Shift)
            {
                andEqualToXToolStripMenuItem_Click(null, null);
            }
            else
            {
                andGreaterThanOrEqualToXToolStripMenuItem_Click(null, null);
            }
        }

        private void ratingFilterToolStripMenuItem_MouseDown(object sender, MouseEventArgs e)
        {
            var mk = ModifierKeys;
            if (e.Button == MouseButtons.Middle)
            {
                if ((mk & Keys.Shift) == Keys.Shift)
                {
                    equalToXToolStripMenuItem_Click(null, null);
                }
                else
                {
                    greaterThanOrEqualToXToolStripMenuItem_Click(null, null);
                }
            }
            else if (e.Button == MouseButtons.Right)
            {
                OpenRateButtonDropdown(byTouch: false);
            }
        }

        private void OpenRateButtonDropdown(bool byTouch)
        {
            ratingFilterToolStripMenuItem.DropDown = ratingFilterToolStripMenuItemDropDown;
            ratingFilterToolStripMenuItem_DropDownOpening(null, null);

            setTagOrRatingButtonShortcutKeyDisplayString(ratingFilterToolStripMenuItemDropDown, byTouch);

            ratingFilterToolStripMenuItemDropDown.Show();
        }

        /*
        private void MenuStripForTagFilter_MouseWheel(object sender, MouseEventArgs e)
        {
            if (ratingFilterToolStripMenuItem.Bounds.Contains(e.Location))
            {
                var v = ratingReferenceValue;
                var d = e.Delta / 120;
                if (v <= 1 && d <= 0 || v >= 5 && d >= 0) return;
                ratingReferenceValue = v + d;
                //setTagFilterLocation();
                ratingFilterToolStripMenuItem_DropDownOpening(null, null);
                setFilterDropDownLocation(ratingFilterToolStripMenuItemDropDown); // ratingReferenceValue の書き換えで位置が戻る＋フィルタ避け必要性の有無変化の可能性
            }
        }
        */

        private void increaseReferenceValueToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ratingReferenceValue++;
            //setTagFilterLocation();
            ratingFilterToolStripMenuItem_DropDownOpening(null, null);
            setFilterDropDownLocation(ratingFilterToolStripMenuItemDropDown);
        }

        private void decreaseReferenceValueToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ratingReferenceValue--;
            //setTagFilterLocation();
            ratingFilterToolStripMenuItem_DropDownOpening(null, null);
            setFilterDropDownLocation(ratingFilterToolStripMenuItemDropDown);
        }

        private int ratingReferenceValue_field = 3;
        private int ratingReferenceValue
        {
            get
            {
                return Math.Max(1, Math.Min(5, ratingReferenceValue_field));
            }
            set
            {
                ratingReferenceValue_field = Math.Max(1, Math.Min(5, value));

                ratingFilterToolStripMenuItem.Invalidate();
            }
        }
        private string getRatingReverenceStars()
        {
            if (ratingReferenceValue_field <= 1) return "★";
            else if (ratingReferenceValue_field == 2) return "★★";
            else if (ratingReferenceValue_field == 3) return "★★★";
            else if (ratingReferenceValue_field == 4) return "★★★★";
            else return "★★★★★";
        }

        private bool filterAddable(string str, bool weak, out bool isRate, out string[] currents, out string trim, out string[] trims) =>
            filterAddable(str, weak, true, out isRate, out currents, out trim, out trims);

        private bool filterAddable(string str, bool weak) =>
            filterAddable(str, weak, false, out var dummy0, out var dummy1, out var dummy2, out var dummy3);
        private bool filterAddable(string str, bool weak, bool currentsRateAndTrimsAreNeededIfReturnTrue, out bool isRate, out string[] currents, out string trim, out string[] trims)
        {
            isRate = false;
            trim = null;
            currents = null;
            trims = null;
            var text = cbFilter.Text;
            if (text == null) text = "";
            text = text.Trim();
            if (SearchManager.IsRegex.IsMatch(text)) return false;
            if (weak)
            {
                if (currentsRateAndTrimsAreNeededIfReturnTrue && str != null)
                {
                    isRate = SearchManager.IsRatingFilterWithOrWithoutOperator.IsMatch(str);
                    trim = SearchManager.TrimOperatorAndDoubleQuotations(str);
                    currents = SearchManager.Split(text, out trims);
                }
                return true;
            }
            else
            {
                if (string.IsNullOrEmpty(text))
                {
                    return false;
                }
                else
                {
                    isRate = SearchManager.IsRatingFilterWithOrWithoutOperator.IsMatch(str);
                    var trim_ = trim = SearchManager.TrimOperatorAndDoubleQuotations(str);
                    currents = SearchManager.Split(text, out trims);
                    return isRate ? trims.Any(t => !SearchManager.IsRatingFilterWithOrWithoutOperator.IsMatch(t)) : trims.Any(t => t != trim_);
                }
            }
        }

        private void filterAdd(string str, bool weak)
        {
            string trim;
            string[] trims;
            string[] currents;
            bool strIsRate;
            if (str == null) str = "";
            if (filterAddable(str, weak, out strIsRate, out currents, out trim, out trims))
            {
                var text = cbFilter.Text;
                if (text == null) text = "";

                //var trim = SearchManager.TrimOperatorAndDoubleQuotations(str);

                //string[] trims;
                //var currents = SearchManager.Split(text, out trims);
                //var strIsRate = SearchManager.IsRatingFilterWithOrWithoutOperator.IsMatch(str);

                var b = new StringBuilder(Math.Max(1, text.Length + str.Length + 1));
                var replaced = false;
                var sleStart = -1;
                var selLength = 0;
                for (var i = 0; i < currents.Length; i++)
                {
                    var current = currents[i];
                    if (strIsRate ? !SearchManager.IsRatingFilterWithOrWithoutOperator.IsMatch(current) : trims[i] != trim)
                    {
                        b.Append(current);
                        b.Append(' ');
                    }
                    else
                    {
                        replaced = true;
                        if (current != str)
                        {
                            if (sleStart < 0)
                            {
                                sleStart = b.Length;
                                selLength = str.Length;
                                b.Append(str);
                                b.Append(' ');
                            }
                        }
                    }
                }

                if (replaced)
                {
                    cbFilter.Text = b.ToString();
                    if (sleStart >= 0)
                    {
                        cbFilter.Select(sleStart, selLength);
                    }
                }
                else
                {
                    if (text.EndsWith(" ") || text == "") cbFilter.Text = text + str;
                    else cbFilter.Text = text + " " + str;
                    //cbFilter.SelectionStart = cbFilter.Text.Length;
                    cbFilter.Select(cbFilter.Text.Length - str.Length, str.Length);
                }


                /*
                if (trims.Contains(trim))
                {
                    //var start = -1;
                    var b = new StringBuilder(Math.Max(1, text.Length - str.Length - 1));
                    for(var i = 0; i < currents.Length; i++)
                    {
                        var current = currents[i];
                        var ctrim = trims[i];
                        if (ctrim != trim)
                        {
                            b.Append(current);
                            b.Append(' ');
                        }
                        else if (current != str)
                        {
                            b.Append(str);
                            b.Append(' ');
                        }
                    }
                    if (b.Length > 0) b.Remove(b.Length - 1, 1);
                    cbFilter.Text = b.ToString();
                    //cbFilter.Select(Math.Max(0, start), 0);
                }
                else
                {
                    var match = SearchManager.IsRatingFilterWithOrWithoutOperator.Match(str);
                    var replaced = false;
                    if (match.Success)
                    {
                        var ope = match.Groups[1].Value;
                        var b = new StringBuilder(Math.Max(1, text.Length - str.Length - 1));
                        for (var i = 0; i < currents.Length; i++)
                        {
                            var current = currents[i];
                            var m2 = SearchManager.IsRatingFilterWithOrWithoutOperator.Match(current);
                            if (m2.Success)
                            {
                                if (m2.Groups[1].Value == ope)
                                {
                                    replaced = true;
                                    break;
                                }
                            }
                            else
                            {
                                b.Append(current);
                                b.Append(' ');
                            }
                        }
                        if (replaced)
                        {
                            b.Append(str);
                            cbFilter.Text = b.ToString();
                            cbFilter.Select(cbFilter.Text.Length - str.Length, str.Length);
                        }

                    }

                    if (!replaced)
                    {
                        if (text.EndsWith(" ") || text == "") cbFilter.Text = text + str;
                        else cbFilter.Text = text + " " + str;
                        //cbFilter.SelectionStart = cbFilter.Text.Length;
                        cbFilter.Select(cbFilter.Text.Length - str.Length, str.Length);
                    }
                }
                */
            }
        }

        private void increaseReferenceValueToolStripMenuItem_MouseDown(object sender, MouseEventArgs e)
        {
            ratingFilterToolStripMenuItemDropDown.AutoClose = false;
        }

        private void decreaseReferenceValueToolStripMenuItem_MouseDown(object sender, MouseEventArgs e)
        {
            ratingFilterToolStripMenuItemDropDown.AutoClose = false;
        }

        [System.Runtime.InteropServices.DllImport("user32.dll")]
        private static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);

        private void setFilterDropDownLocation(ToolStripDropDown dropDown)
        {
            if (dropDown == null || !dropDown.Visible) return;
            var owner = dropDown.OwnerItem;
            var bounds = owner.Bounds;
            var owner2 = owner.Owner;
            var overflowDropDown = owner2?.OverflowButton?.DropDown;
            Point point;
            bool overflow;
            if (overflowDropDown != null && overflowDropDown.Visible)
            {
                overflow = true;
                point = overflowDropDown.PointToScreen(new Point(bounds.Left, bounds.Bottom - 1));
            }
            else
            {
                overflow = false;
                point = owner2.PointToScreen(new Point(bounds.Left, bounds.Bottom - 1));
            }
            var width = dropDown.Width;
            var height = dropDown.Height;
            var x = point.X;
            var y = point.Y;

            var wa = Screen.FromControl(this).WorkingArea;

            // フィルタ領域を避ける処理
            if (!overflow)
            {
                if (x < wa.Left) x = wa.Left;
                else if (x + width > wa.Right) x = wa.Right - width;
                var filterRectangle = cbFilter.RectangleToScreen(cbFilter.DisplayRectangle);
                if (x + width > filterRectangle.Left && x < filterRectangle.Right)
                {
                    y = filterRectangle.Bottom - 1;
                }
            }

            //var wa = Screen.FromControl(this).WorkingArea;
            if (x < wa.Left) x = wa.Left;
            else if (x + width > wa.Right) x = wa.Right - width;
            if (y < wa.Top) y = wa.Top;
            else if (y + height > wa.Bottom) y = wa.Bottom - height;

            MoveWindow(dropDown.Handle, x, y, width, height, false);
        }

        private void ratingFilterToolStripMenuItem_DropDownOpened(object sender, EventArgs e)
        {
            ratingFilterToolStripMenuItem_Dropdowned = true;
            setFilterDropDownLocation(ratingFilterToolStripMenuItemDropDown);
        }

        private void equalToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cbFilter.Text = "r=" + ratingReferenceValue;
            cbFilter.SelectAll();
        }

        private void greaterThanOrEqualToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cbFilter.Text = "r>=" + ratingReferenceValue;
            cbFilter.SelectAll();
        }

        private void andEqualToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            filterAdd("r=" + ratingReferenceValue, weak: true);
        }

        private void andGreaterThanOrEqualToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            filterAdd("r>=" + ratingReferenceValue, weak: true);
        }

        private void orEqualToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            filterAdd("+r=" + ratingReferenceValue, weak: true);
        }

        private void orGreaterThanOrEqualToXToolStripMenuItem_Click(object sender, EventArgs e)
        {
            filterAdd("+r>=" + ratingReferenceValue, weak: true);
        }

        private void setColors()
        {
            BackColor = Color.Black;

            dgvDirectoryList.BackgroundColor = Color.Black;
            dgvDirectoryList.DefaultCellStyle.BackColor = dgvDirectoryList.BackgroundColor;
            dgvDirectoryList.DefaultCellStyle.ForeColor = ZipTag.GetForeColor(dgvDirectoryList.BackgroundColor);


            tvCatalog.SetBackAndForeColor(Color.Black);
            MaskBrush = new SolidBrush(Color.FromArgb(MaskAlpha, tvCatalog.BackColor));

            dgvFileList.BackgroundColor = Color.Black;
            dgvFileList.DefaultCellStyle.BackColor = dgvFileList.BackgroundColor;
            dgvFileList.DefaultCellStyle.ForeColor = ZipTag.GetForeColor(dgvFileList.BackgroundColor);


            //ratingFilterToolStripMenuItem.BackColor = Color.Black;
        }

        private void editDropdownOfFiltersToolStripMenuItem_Click(object sender, EventArgs e)
        {
            openFilterEditForm();
        }

        private void openFilterEditForm()
        {
            var temp = AllowFullpower;
            AllowFullpower = false;
            var filteringList = (from object item in cbFilter.Items select item.ToString()).ToList();
            if (aliasesToFilteringStrings == null) aliasesToFilteringStrings = new Dictionary<string, string>();
            using (var filterEditForm = new FilterEditForm(filteringList, aliasesToFilteringStrings, invariantFilteringList, currentProfileColor))
            {
                filterEditForm.Icon = Icon;
                filterEditForm.ShowDialog(this);

                if (filterEditForm.Edited)
                {
                    var cbFilterText = cbFilter.Text;
                    if (!filteringList.Contains(cbFilterText))
                    {
                        if (aliasesToFilteringStrings.ContainsValue(cbFilterText))
                        {
                            cbFilter.Text = aliasesToFilteringStrings.FirstOrDefault(pair => pair.Value == cbFilterText).Key;
                        }
                        else
                        {
                            cbFilter.Text = "";
                        }
                    }
                    var array = new object[filteringList.Count + 1];
                    array[0] = "";
                    for (var i = 1; i < array.Length; i++) array[i] = filteringList[i - 1];
                    cbFilter.Items.Clear();
                    cbFilter.Items.AddRange(array);
                    invariantFilteringList = filterEditForm.invariantOut;
                }
            }
            AllowFullpower = temp;
        }

        private double[] setAspectRatioOption_Ratios;
        private void setAspectRatioOption(IReadOnlyList<Tuple<string, double>> options, IReadOnlyList<Tuple<string, double>> allOptions = null)
        {
            var items = thumbnailSizeToolStripMenuItem.DropDownItems;
            var start = items.IndexOf(thumbnailSizeBottomSeparator) + 1;
            while (items[start] != allRatiosToolStripMenuItem)
            {
                items.RemoveAt(start);
            }
            var count = 0;
            setAspectRatioOption_Ratios = new double[options.Count + (allOptions == null ? 0 : allOptions.Count)];

            var optionsCount = options.Count;
            var itemsCount = items.Count;
            var copy = new ToolStripItem[itemsCount + optionsCount];
            items.CopyTo(copy, 0);
            items.Clear();
            //Array.Copy(copy, start, copy, start + optionsCount, items.Count - start);
            for (var i = itemsCount - 1; i >= start; i--) copy[i + optionsCount] = copy[i];

            foreach (var option in options)
            {
                copy[start++] = setAspectRatioOption_GetToolStripMenuItem(option, count++);
            }
            items.AddRange(copy);
            /*
            foreach (var option in options)
            {
                items.Insert(start++, setAspectRatioOption_GetToolStripMenuItem(option, count++));
            }
            */
            var allItems = allRatiosToolStripMenuItem.DropDownItems;
            allItems.Clear();
            if (allOptions != null)
            {
                var toolStripItems = new ToolStripItem[allOptions.Count];
                var k = 0;
                foreach (var option in allOptions)
                {
                    toolStripItems[k++] = setAspectRatioOption_GetToolStripMenuItem(option, count++);
                }
                allItems.AddRange(toolStripItems);
                allRatiosToolStripMenuItem.Visible = true;
            }
            else
            {
                allRatiosToolStripMenuItem.Visible = false;
            }
        }

        private ToolStripMenuItem setAspectRatioOption_GetToolStripMenuItem(Tuple<string, double> option, int count)
        {
            var cmsi = new ToolStripMenuItem(option.Item1);
            var aspect = option.Item2;

            setAspectRatioOption_Ratios[count] = aspect;

            /*
            switch (count + 1)
            {
                case 1: cmsi.ShortcutKeys = Keys.Alt | Keys.D1; break;
                case 2: cmsi.ShortcutKeys = Keys.Alt | Keys.D2; break;
                case 3: cmsi.ShortcutKeys = Keys.Alt | Keys.D3; break;
                case 4: cmsi.ShortcutKeys = Keys.Alt | Keys.D4; break;
                case 5: cmsi.ShortcutKeys = Keys.Alt | Keys.D5; break;
                case 6: cmsi.ShortcutKeys = Keys.Alt | Keys.D6; break;
                case 7: cmsi.ShortcutKeys = Keys.Alt | Keys.D7; break;
                case 8: cmsi.ShortcutKeys = Keys.Alt | Keys.D8; break;
                case 9: cmsi.ShortcutKeys = Keys.Alt | Keys.D9; break;
            }
            */

            cmsi.Checked = aspect == aspectRatio;

            cmsi.Click += (sender, e) =>
            {
                //if (clipModeByControl == ClipMode.PlaClip) return;
                var toolStripMenuItem = sender as ToolStripMenuItem;
                if (!toolStripMenuItem.Checked)
                {
                    aspectRatio = aspect;
                    setAspectRatioCheckState();
                    ChangeThumbnailSize(null);
                    UpdatePreview();
                }
            };

            return cmsi;
        }

        private void setAspectRatioCheckState()
        {
            var items = getAspectRatioToolStripMenuItems();
            if (setAspectRatioOption_Ratios != null && setAspectRatioOption_Ratios.Length == items.Length)
            {
                var found1 = false;
                var found2 = false;
                var count = items.Length - allRatiosToolStripMenuItem.DropDownItems.Count;
                for (var i = 0; i < items.Length; i++)
                {
                    if (Math.Abs(setAspectRatioOption_Ratios[i] - aspectRatio) < 0.00000000001)
                    {
                        items[i].Checked = true;
                        //items[i].Enabled = false;
                        if (i < count)
                        {
                            found1 = true;
                        }
                        else
                        {
                            found2 = true;
                        }
                    }
                    else
                    {
                        items[i].Checked = false;
                        //items[i].Enabled = true;
                    }
                }
                allRatiosToolStripMenuItem.Checked = !found1 && found2;
            }
        }

        private ToolStripMenuItem[] getAspectRatioToolStripMenuItems()
        {
            var items = thumbnailSizeToolStripMenuItem.DropDownItems;
            var start = items.IndexOf(thumbnailSizeBottomSeparator) + 1;
            var result = new List<ToolStripMenuItem>();
            while (items[start] != allRatiosToolStripMenuItem)
            {
                result.Add(items[start++] as ToolStripMenuItem);
            }
            foreach (ToolStripMenuItem item in allRatiosToolStripMenuItem.DropDownItems)
            {
                result.Add(item);
            }
            return result.ToArray();
        }

        private void ratingFilterToolStripMenuItem_MouseMove(object sender, MouseEventArgs e)
        {
            if (ratingFilterToolStripMenuItem_Paint_StarRectangle == Rectangle.Empty) return;

            var s = e.X - ratingFilterToolStripMenuItem_Paint_StarRectangle.Left;
            var r = (5 * s / ratingFilterToolStripMenuItem_Paint_StarRectangle.Width) + 1;
            ratingReferenceValue = r;

            ratingFilterToolStripMenuItem_DropDownOpening(null, null);
            setFilterDropDownLocation(ratingFilterToolStripMenuItemDropDown); // ratingReferenceValue の書き換えで位置が戻る＋フィルタ避け必要性の有無変化の可能性

        }

        // 呼び出し回数が少なく、また標準ライブラリの機能を多用しているので SizeDictionary は使わない
        Rectangle ratingFilterToolStripMenuItem_Paint_StarRectangle = Rectangle.Empty;
        bool ratingFilterToolStripMenuItem_Paint_SizeFixed = false;
        bool ratingFilterToolStripMenuItem_Dropdowned = false;
        private void ratingFilterToolStripMenuItem_Paint(object sender, PaintEventArgs e)
        {
            //var rectP = e.ClipRectangle; // この方法だと他のウインドウに隠れた部分がなくなる
            var rectP = new Rectangle(0, 0, ratingFilterToolStripMenuItem.Width, ratingFilterToolStripMenuItem.Height);



            var r = ratingReferenceValue;
            var p = "★★★★★".Substring(0, r);
            var s = "★★★★★".Substring(r);
            var size5 = TextRenderer.MeasureText(e.Graphics, "★★★★★", ratingFilterToolStripMenuItem.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding);
            var w5 = size5.Width;
            var h = size5.Height;
            var wr = TextRenderer.MeasureText(e.Graphics, p, ratingFilterToolStripMenuItem.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;

            rectP.X += (rectP.Width - w5) / 2;
            rectP.Y += (rectP.Height - h) / 2;
            var rectS = rectP;
            rectS.X += wr;

            var pw = TextRenderer.MeasureText(e.Graphics, ".", ratingFilterToolStripMenuItem.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding).Width;
            ratingFilterToolStripMenuItem_Paint_StarRectangle = rectP;
            ratingFilterToolStripMenuItem_Paint_StarRectangle.X += pw;
            ratingFilterToolStripMenuItem_Paint_StarRectangle.Size = new Size(w5, h);

            Color gold, gray;
            //if (ratingFilterToolStripMenuItem.DropDown.Visible || ratingFilterToolStripMenuItem.Bounds.Contains(menuStripForTagFilter.PointToClient(Cursor.Position)))
            if (ratingFilterToolStripMenuItem_Dropdowned || ratingFilterToolStripMenuItem.Selected)
            {
                gold = Color.DarkGoldenrod;
                gray = Color.LightGray;
                //gold = Color.Gold;
                //gray = Color.LightSlateGray;
            }
            else
            {
                gold = Color.Gold;
                gray = Color.LightSlateGray;

                if (!ratingFilterToolStripMenuItem_Paint_SizeFixed)
                {
                    // ハイライト状態でなければ塗りつぶすメリットの方が大きい
                    e.Graphics.FillRectangle(Brushes.Black, rectP);
                }
            }


            if (!ratingFilterToolStripMenuItem_Paint_SizeFixed)
            {
                ratingFilterToolStripMenuItem.AutoSize = false;
                ratingFilterToolStripMenuItem.Text = "";
                ratingFilterToolStripMenuItem_Paint_SizeFixed = true;
            }

            TextRenderer.DrawText(e.Graphics, p, ratingFilterToolStripMenuItem.Font, rectP, gold, TextFormatFlags.NoPadding);
            TextRenderer.DrawText(e.Graphics, s, ratingFilterToolStripMenuItem.Font, rectS, gray, TextFormatFlags.NoPadding);
        }

        private int CenterPanellMinWidth;
        private int SidePanellMinWidth;

        private int pnlRight_NormalWidth;

        private void pnlRight_SizeChanged(object sender, EventArgs e)
        {
            var splDock = getFileListDock();
            var splVertical = !(splDock == DockStyle.Top || splDock == DockStyle.Bottom);
            if (pnlCenter.Visible && pnlRight.Visible)
            {
                pnlRight_NormalWidth = splVertical ? pnlRight.Width : pnlRight.Height;
                if (splVertical)
                {
                    splLeft.MinExtra = CenterPanellMinWidth + splRight.Width + pnlRight.Width;
                }
                else
                {
                    splLeft.MinExtra = CenterPanellMinWidth;
                }
            }
            else if (pnlCenter.Visible)
            {
                splLeft.MinExtra = CenterPanellMinWidth;
            }
            else
            {
                splLeft.MinExtra = splVertical ? SidePanellMinWidth : CenterPanellMinWidth;
            }
        }

        private void setFileListDock(DockStyle dockStyle, bool keepWidth, bool fixWidth)
        {
            var nextVertical = dockStyle == DockStyle.Left || dockStyle == DockStyle.Right;
            if (!(nextVertical ||
                dockStyle == DockStyle.Top || dockStyle == DockStyle.Bottom)) return;
            var splDock = getFileListDock();
            if (splDock != dockStyle)
            {
                var currentVertical = splDock == DockStyle.Left || splDock == DockStyle.Right;
                var dualVisible = pnlRight.Visible && pnlCenter.Visible;
                keepWidth = keepWidth && dualVisible;
                if (!keepWidth || currentVertical == nextVertical)
                {
                    splRight.Dock = dockStyle;
                    if (dualVisible) pnlRight.Dock = dockStyle;
                    if (fixWidth) setMainPanelWidth();
                }
                else
                {
                    var currentWidth = currentVertical ? pnlRight.Width : pnlRight.Height;
                    splRight.Dock = dockStyle;
                    if (dualVisible) pnlRight.Dock = dockStyle;
                    if (nextVertical) pnlRight.Width = currentWidth;
                    else pnlRight.Height = currentWidth;
                    if (fixWidth) setMainPanelWidth();
                }

                verticalToolStripMenuItem.Checked = dockStyle == DockStyle.Bottom;
                alternativeVerticalToolStripMenuItem.Checked = dockStyle == DockStyle.Top;
                horizontalToolStripMenuItem.Checked = dockStyle == DockStyle.Right;
                alternativeHorizontalToolStripMenuItem.Checked = dockStyle == DockStyle.Left;
            }
        }

        private void setFileListWidthWithoutSettingWidth(int width)
        {
            switch (getFileListDock())
            {
                case DockStyle.Left:
                case DockStyle.Right:
                    pnlRight.Width = width;
                    break;
                case DockStyle.Top:
                case DockStyle.Bottom:
                    pnlRight.Height = width;
                    break;
            }
        }

        private DockStyle getFileListDock()
        {
            return splRight.Dock; // pnlRight.Dock は非表示のときに期待通りの値を返さない
        }

        private int getFileListWidth()
        {
            switch (getFileListDock())
            {
                case DockStyle.Top:
                case DockStyle.Bottom:
                    return pnlRight.Height;
                default:
                    return pnlRight.Width;
            }
        }

        private void setMainPanelWidth()
        {
            var splDock = getFileListDock();
            var verticalSeparator = splDock == DockStyle.Left || splDock == DockStyle.Right;

            var t = verticalSeparator ? pnlMain.Width : pnlMain.Height;
            int wl, wr;
            if (verticalSeparator && pnlLeft.Visible)
            {
                wl = pnlLeft.Width;
                t -= splLeft.Width;
            }
            else
            {
                wl = 0;
            }
            var pnlCenterVisible = pnlCenter.Visible;
            if (pnlCenterVisible)
            {
                t -= CenterPanellMinWidth;
            }
            if (pnlRight.Visible)
            {
                wr = verticalSeparator ? pnlRight.Width : pnlRight.Height;
                if (pnlCenterVisible) t -= verticalSeparator ? splRight.Width : splRight.Height;
            }
            else
            {
                wr = 0;
            }
            var n = wl + wr - t;
            if (n > 0)
            {
                if (wr > SidePanellMinWidth)
                {
                    if (wr - SidePanellMinWidth >= n)
                    {
                        wr -= n;
                        n = 0;
                    }
                    else
                    {
                        n -= wr - SidePanellMinWidth;
                        wr = SidePanellMinWidth;
                    }
                }
                if (wl > SidePanellMinWidth)
                {
                    if (wl - SidePanellMinWidth >= n)
                    {
                        wl -= n;
                        n = 0;
                    }
                    else
                    {
                        n -= wl - SidePanellMinWidth;
                        wl = SidePanellMinWidth;
                    }
                }
                if (verticalSeparator)
                {
                    pnlLeft.Width = wl;
                    pnlRight.Width = wr;
                }
                else
                {
                    pnlLeft.Height = wl;
                    pnlRight.Height = wr;
                }
            }
        }

        private const int MaskAlpha = 160;
        private static Brush MaskBrush = new SolidBrush(Color.FromArgb(MaskAlpha, SystemColors.Window));
        /*
        public Brush GetMaskBrush(string path)
        {
            if (cutFilePathSetInLower != null)
            {
                if (cutFilePathSetInLower.Contains(path.ToLower()))
                {
                    return MilkMaskBrush;
                }
            }
            return null;
        }
        */

        public int GetMaskAlpha(string path)
        {
            if (cutFilePathSetInLower != null)
            {
                if (cutFilePathSetInLower.Contains(path.ToLower()))
                {
                    return MaskAlpha;
                }
            }
            return 0;
        }

        // 初期状態では辞書は Cover と 表紙 しか登録されないが、言語ファイルを追加すれば増えていく
        private readonly Dictionary<string, Size> tvCatalog_ThumbnailPaint_CoverStringWidthDictionary = new Dictionary<string, Size>();
        private void tvCatalog_ThumbnailPaint(ThumbViewer sender, ThumbViewer.ThumbnailPaintEventArgs e)
        {
            var zpa = ZipPathArray;
            var zna = ZipNameArray;
            var lra = LoadResultArray;
            var mta = ModifiedTimeArray;
            var zga = ZipPageArray;
            var fca = FileCountArray;
            var count = zpa == null ? -1 : zpa.Length;
            if (zpa != null && zna != null && lra != null && mta != null && zga != null && fca != null &&
                count == sender.Count && zna.Length == count && lra.Length == count && mta.Length == count && zga.Length == count && fca.Length == count)
            {
                var name = zna[e.DataIndex];
                if (!string.IsNullOrEmpty(name)) // && cond != LoadResult.NotYet) ファイル名と統一
                {
                    var cond = lra[e.DataIndex];
                    var lastWriteTime = mta[e.DataIndex];

                    var path = zpa[e.DataIndex];
                    if (path == null) return;

                    var isDir = name.EndsWith(Path.DirectorySeparatorChar.ToString());

                    var iconSize = new Size(0, 0);
                    var IsVirtualPath = InMovie || InDocument || path.Contains(Path.AltDirectorySeparatorChar);
                    var thumbRect = e.ThumbnailRectangle;
                    if (LoadLastViewedPageFromHistory)
                    {
                        var totalPage = fca[e.DataIndex];
                        var currentPage = zga[e.DataIndex];
                        if (totalPage > 0 && currentPage >= 0 && currentPage < totalPage)
                        {
                            var dh = Program.DpiScalingY(3);
                            var w = ((2 * currentPage + 1) * thumbRect.Width - totalPage) / (2 * totalPage);
                            e.Graphics.FillRectangle(Brushes.Chartreuse, new Rectangle(thumbRect.X, thumbRect.Bottom - dh, w, dh));
                            e.Graphics.FillRectangle(Brushes.Black, new Rectangle(thumbRect.X + w, thumbRect.Bottom - dh, thumbRect.Width - w, dh));
                            thumbRect.Height -= dh;
                        }
                    }
                    if (cond == LoadResult.FileNotFound || cond == LoadResult.LoadError || cond == LoadResult.NotYet)
                    {
                        var str = showFilenameToolStripMenuItem.Checked ? null : name;
                        var iconPath = !IsVirtualPath ? path : null;
                        if (cond != LoadResult.LoadError)
                        {
                            //using (var b = GetFileDirectoryForeBrush(path))
                            var b = GetFileDirectoryForeBrush(path);
                            {
                                drawFileImage(e.Graphics, thumbRect, tvCatalog.Font, b/*Brushes.Black*/, str, iconPath, lastWriteTime, null, isDir, isExist: InDirectoryVirtualDirectoryOrSmartDirectory);
                            }
                        }
                        else
                        {
                            drawFileImage(e.Graphics, thumbRect, tvCatalog.Font, Brushes.Blue, str, iconPath, lastWriteTime, Brushes.Yellow, isDir, isExist: InDirectoryVirtualDirectoryOrSmartDirectory);
                        }
                    }
                    else
                    {
                        if (showIcon && !IsVirtualPath)
                            iconSize = drawFileIconImage(e.Graphics, thumbRect, path, lastWriteTime, isDir, isExist: InDirectoryVirtualDirectoryOrSmartDirectory);
                    }

                    var maskAlpha = GetMaskAlpha(path);
                    if (maskAlpha > 0)
                    {
                        e.Graphics.FillRectangle(MaskBrush, e.ThumbnailRectangle); // 元の Rectangle
                    }

                    var localShowRating = showRating && InDirectoryVirtualDirectoryOrSmartDirectory;
                    if (showTags || localShowRating)
                    {
                        var zipPlaInfo = new ZipPlaInfo(name);
                        if (showTags) drawTags(e.Graphics, thumbRect, zipPlaInfo, iconSize);
                        if (localShowRating) drawRating(e.Graphics, thumbRect, zipPlaInfo); // レートが手前
                    }
                    if ((InMovie || InArchive) && LocationZipPlaInfo != null)
                    {
                        if (
                            InMovie && getMoviePostionTuple(name)?.Equals(LocationZipPlaInfo.ThumbnailInfo) == true ||
                            InArchive && e.DataIndex == LocationZipPlaInfo.ThumbnailInfo?.Item1)
                        {
                            //e.Graphics.DrawString(Message.Cover, tvCatalog.Font, Brushes.Black, thumbRect);
                            var font = new Font(tvCatalog.Font, FontStyle.Bold);
                            drawSimpleString(e.Graphics, Message.Cover, font, thumbRect, Color.Black, Brushes.Pink, tvCatalog_ThumbnailPaint_CoverStringWidthDictionary);
                        }
                    }

                }
            }
        }

        int tvCatalog_MouseMove_RatingChangePart_TempIndex = -1;
        Guid tvCatalog_MouseMove_RatingChangePart_ShownTooltipGuid = Guid.Empty;
        private void tvCatalog_MouseMove_RatingChangePart()//(int mouseDataIndex)
        {
            if (!showRating) return;
            //if (mgCatalog.InGesturing) return;
            if (!InDirectoryVirtualDirectoryOrSmartDirectory) return;
            if (CreatingZipPathArray) return;
            if (drawRating_Bound.IsEmpty) return;
            var clientCursorPosition = tvCatalog.PointToClient(Cursor.Position);
            var dataIndex = mgCatalog.InGesturing || cmsRightClick.Visible ? -1 : tvCatalog.PointToIndex(clientCursorPosition);
            //var dataIndex = mgCatalog.InGesturing ? -1 : mouseDataIndex;

            Graphics g = null;

            if (tvCatalog_MouseMove_RatingChangePart_TempIndex > 0 && dataIndex != tvCatalog_MouseMove_RatingChangePart_TempIndex)
            {
                if (tvCatalog_MouseMove_RatingChangePart_TempIndex < tvCatalog.Count)
                {
                    var zna = ZipNameArray;
                    if (zna != null && zna.Length == tvCatalog.Count)
                    {
                        var name = zna[tvCatalog_MouseMove_RatingChangePart_TempIndex];
                        if (!string.IsNullOrEmpty(name))
                        {
                            var rect = tvCatalog.IndexToContainerImageRectangle(tvCatalog_MouseMove_RatingChangePart_TempIndex);
                            if (!rect.IsEmpty)
                            {
                                var zipPlaInfo = new ZipPlaInfo(name);
                                g = tvCatalog.CreateGraphics();
                                drawRating(g, rect, zipPlaInfo);
                            }
                        }
                    }
                }
                tvCatalog_MouseMove_RatingChangePart_TempIndex = -1;
                //tvCatalog_MouseMove_RatingChangePart_MouseEnterTime = DateTime.MaxValue;
                toolTip.Hide(tvCatalog);
            }

            if (dataIndex < 0)
            {
                g?.Dispose();
                return;
            }

            var imageRectangle = tvCatalog.PointToContainerImageRectangle(clientCursorPosition);
            var backRectangle = drawRating_Bound;
            backRectangle.X += imageRectangle.X;
            backRectangle.Y += imageRectangle.Y;
            if (backRectangle.Contains(clientCursorPosition))
            {
                var r = Math.Max(1, Math.Min(5, 5 * (clientCursorPosition.X - (imageRectangle.X + drawRating_StarsBound.Left)) / drawRating_StarsBound.Width + 1));
                if (g == null) g = tvCatalog.CreateGraphics();
                drawRating(g, imageRectangle, r);
                if (tvCatalog_MouseMove_RatingChangePart_TempIndex != dataIndex)
                {
                    var offset = Cursor.Current is Cursor cursor ? cursor.Size.Height - cursor.HotSpot.Y : 0; // Run の中で取得すると Wait になってしまうことがある
                    tvCatalog_MouseMove_RatingChangePart_TempIndex = dataIndex;

                    toolTip.Hide(tvCatalog);
                    Task.Run(() =>
                    {
                        Thread.Sleep(toolTip.InitialDelay);
                        Point point = default(Point);
                        try
                        {
                            Invoke((MethodInvoker)(() =>
                            {
                                point = tvCatalog.PointToClient(Cursor.Position);
                            }));
                        }
                        catch (ObjectDisposedException) { }
                        if (backRectangle.Contains(point))
                        {
                            if (offset > 0)
                            {
                                point.Y += offset;
                            }
                            if (backRectangle.Right > point.X && backRectangle.Bottom > point.Y) point.Y = backRectangle.Bottom;
                            var guid = Guid.NewGuid();
                            try
                            {
                                Invoke((MethodInvoker)(() =>
                                {
                                    toolTip.Show(Message.MiddleClickLeftFlickToResetRating, tvCatalog, point);
                                    tvCatalog_MouseMove_RatingChangePart_ShownTooltipGuid = guid;
                                }));
                            }
                            catch (ObjectDisposedException) { }
                            Thread.Sleep(toolTip.AutoPopDelay);
                            try
                            {
                                Invoke((MethodInvoker)(() =>
                                {
                                    if (guid == tvCatalog_MouseMove_RatingChangePart_ShownTooltipGuid)
                                    {
                                        toolTip.Hide(tvCatalog);
                                    }
                                }));
                            }
                            catch (ObjectDisposedException) { }
                        }
                    });

                }
            }
            else
            {
                if (dataIndex == tvCatalog_MouseMove_RatingChangePart_TempIndex)
                {
                    if (tvCatalog_MouseMove_RatingChangePart_TempIndex < tvCatalog.Count)
                    {
                        var zna = ZipNameArray;
                        if (zna != null && zna.Length == tvCatalog.Count)
                        {
                            var name = zna[tvCatalog_MouseMove_RatingChangePart_TempIndex];
                            if (!string.IsNullOrEmpty(name))
                            {
                                var zipPlaInfo = new ZipPlaInfo(name);
                                g = tvCatalog.CreateGraphics();
                                drawRating(g, imageRectangle, zipPlaInfo);
                            }
                        }
                    }
                    tvCatalog_MouseMove_RatingChangePart_TempIndex = -1;
                    //tvCatalog_MouseMove_RatingChangePart_MouseEnterTime = DateTime.MaxValue;
                    toolTip.Hide(tvCatalog);
                }
            }

            g?.Dispose();
        }

        private void tagToolStripMenuItem_Paint(object sender, PaintEventArgs e)
        {
            var rect = e.ClipRectangle;
            //var rect = (sender as ToolStripMenuItem).Bounds;
            rect.Width -= rect.Height * 3 / 2;// selectedFileNameToolStripTextBox.ContentRectangle.Width;// - cmsRightClick.Left;

            rect.Y -= 1; // Windows 10 64bit 2016/09 100%, 175%, 225% でドットレベルでの一致を確認

            string strLong;
            string strShort;
            if (MiddleClickContextMenu == CatalogFormConetxtMenu.Tag)
            {
                strLong = Message.MiddleClickTwoFingerTap;
                strShort = Message.MiddleClick;
            }
            else if (ControlRightClickContextMenu == CatalogFormConetxtMenu.Tag)
            {
                strLong = "Ctrl+" + Message.MiddleClick;
                strShort = null;
            }
            else if (RightClickContextMenu == CatalogFormConetxtMenu.Tag)
            {
                strLong = Message.RightClickPressAndTap;
                strShort = Message.RightClick;
            }
            else return;

            foreach (var str in new string[] { strLong, strShort })
            {
                if (str == null) break;
                if (rect.Width - rect.Height * 2 >= TextRenderer.MeasureText(Message.Tag + "  " + str,
                    tagToolStripMenuItem.Font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.Right | TextFormatFlags.VerticalCenter | TextFormatFlags.NoPrefix).Width)
                {
                    TextRenderer.DrawText(e.Graphics, str, tagToolStripMenuItem.Font, rect, tagToolStripMenuItem.Enabled ? tagToolStripMenuItem.ForeColor : SystemColors.GrayText,
                        TextFormatFlags.Right | TextFormatFlags.VerticalCenter | TextFormatFlags.NoPrefix);
                    break;
                }
            }

        }

        private void ToggleItemLoadLevelAndUpdatePreview(ref ItemLoadLevel itemLoadLevel, ToolStripMenuItem toolStripMenuItem)
        {
            var changed = SetItemLoadLevel(ref itemLoadLevel, toolStripMenuItem,
                itemLoadLevel == ItemLoadLevel.Full ? ItemLoadLevel.Header : itemLoadLevel == ItemLoadLevel.Header ? ItemLoadLevel.Ignore : ItemLoadLevel.Full, // エクスプローラーのプロパティと同じ順
                                                                                                                                                                //itemLoadLevel == ItemLoadLevel.Ignore ? ItemLoadLevel.Full : ItemLoadLevel.Ignore,
                checkAllLoadLevel: true);
            if (changed && InDirectoryVirtualDirectoryOrSmartDirectory) UpdatePreview();
        }

        private void archivesFilesPDFFielsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ToggleItemLoadLevelAndUpdatePreview(ref archiveLoadLevel, archivesFilesPDFFielsToolStripMenuItem);

            /*
            var tsmi = sender as ToolStripMenuItem;
            tsmi.Checked = !tsmi.Checked;
            if (!archivesFilesPDFFielsToolStripMenuItem.Checked && !imageFilesToolStripMenuItem.Checked && !videoFilesToolStripMenuItem.Checked && !otherFilesToolStripMenuItem.Checked)
            {
                tsmi.Checked = !tsmi.Checked;
                AllowFullpower = false;
                MessageBox.Show(this, Message.AtLeastOneKindOfFilesMustBeSelected, Message.Information, MessageBoxButtons.OK, MessageBoxIcon.Information);
                AllowFullpower = true;
                return;
            }
            UpdatePreview();
            */
        }

        private void imageFilesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ToggleItemLoadLevelAndUpdatePreview(ref imageLoadLevel, imageFilesToolStripMenuItem);
        }

        private void otherFilesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ToggleItemLoadLevelAndUpdatePreview(ref otherLoadLevel, otherFilesToolStripMenuItem);
        }
        private void videoFilesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ToggleItemLoadLevelAndUpdatePreview(ref videoLoadLevel, videoFilesToolStripMenuItem);
        }

        private void displayFoldersToolStripMenuItem_Click(object sender, EventArgs e)
        {
            switch (SubfolderMode)
            {
                case SubfolderMode.Display: SubfolderMode = SubfolderMode.DisplayHeader; break;
                case SubfolderMode.DisplayHeader: SetSubfolderMode(SubfolderMode.Ignore, checkAllLoadLevel: true); break; //SubfolderMode = SubfolderMode.Ignore; break;
                case SubfolderMode.Ignore: SubfolderMode = SubfolderMode.Display; break;
                case SubfolderMode.DisplayAndSearch: SubfolderMode = SubfolderMode.DisplayHeaderAndSearch; break;
                case SubfolderMode.DisplayHeaderAndSearch: SetSubfolderMode(SubfolderMode.Search, checkAllLoadLevel: true); break; // SubfolderMode = SubfolderMode.Search; break;
                case SubfolderMode.Search: SubfolderMode = SubfolderMode.DisplayAndSearch; break;
            }
            if (InDirectoryVirtualDirectoryOrSmartDirectory) UpdatePreview();

            // Display(Header)AndSearch を禁止する実装
            /*
            if (SubfolderMode == SubfolderMode.Display)
            {
                SubfolderMode = SubfolderMode.DisplayHeader;
            }
            else if (SubfolderMode == SubfolderMode.DisplayHeader)
            {
                SubfolderMode = SubfolderMode.Ignore;
            }
            else
            {
                SubfolderMode = SubfolderMode.Display;
            }
            if (InDirectoryVirtualDirectoryOrSmartDirectory) UpdatePreview();
            */
        }

        private void searchSubfoldersAsWellToolStripMenuItem_Click(object sender, EventArgs e)
        {
            switch (SubfolderMode)
            {
                case SubfolderMode.Display: SubfolderMode = SubfolderMode.DisplayAndSearch; break;
                case SubfolderMode.DisplayHeader: SubfolderMode = SubfolderMode.DisplayHeaderAndSearch; break;
                case SubfolderMode.Ignore: SubfolderMode = SubfolderMode.Search; break;
                case SubfolderMode.DisplayAndSearch: SubfolderMode = SubfolderMode.Display; break;
                case SubfolderMode.DisplayHeaderAndSearch: SubfolderMode = SubfolderMode.DisplayHeader; break;
                case SubfolderMode.Search: SubfolderMode = SubfolderMode.Ignore; break;
            }
            if (InDirectoryVirtualDirectoryOrSmartDirectory) UpdatePreview();

            // Display(Header)AndSearch を禁止する実装
            /*
            if (SubfolderMode == SubfolderMode.Search)
            {
                SubfolderMode = SubfolderMode.Ignore;
            }
            else
            {
                SubfolderMode = SubfolderMode.Search;
            }
            if (InDirectoryVirtualDirectoryOrSmartDirectory) UpdatePreview();
            */
        }

        private readonly Dictionary<string, Size> dgvDirectoryList_CellPainting_SizeDictionary = new Dictionary<string, Size>();
        private void dgvDirectoryList_CellPainting(object sender, DataGridViewCellPaintingEventArgs e)
        {
            var cell = dgvDirectoryList.Rows[e.RowIndex].Cells[e.ColumnIndex];
            var bookmark = cell.Value as ColoredBookmark;
            if (bookmark == null) return;

            var text = bookmark.SimpleBookmark?.GetDisplayString() ?? "";
#if SCREENCAPTCHA // スクリーンショット作成用
            if (Message.CurrentLanguage.ToString() == "en-US")
            {
                switch (text)
                {
                    case "スクリーンショット": text = "Screenshot(Jpn)"; break;
                    case "動画": text = "Movie"; break;
                    case "コメディ": text = "Comedy"; break;
                    case "ゲーム攻略": text = "Playing guide"; break;
                    case "参考書": text = "Textbook"; break;
                    case "仮想フォルダ1.sor": text = "VirtualFolder1.sor"; break;
                    case "仮想フォルダ2.sor": text = "VirtualFolder2.sor"; break;
                }
            }
#endif
            var font = e.CellStyle.Font;
            //var size = TextRenderer.MeasureText(text, font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
            var size = MeasureStringSizeByTextRenderer(e.Graphics, text, font, dgvDirectoryList_CellPainting_SizeDictionary);

            var rect = e.CellBounds;
            rect.Y += (rect.Height - size.Height + 1) / 2;
            var backColor = bookmark.Color;

            Color foreColor;
            bool isSelected =
                   (e.State & DataGridViewElementStates.Selected) ==
                   DataGridViewElementStates.Selected;
            if (isSelected)
            {
                foreColor = e.CellStyle.SelectionForeColor;
                e.Paint(e.CellBounds, e.PaintParts & ~DataGridViewPaintParts.ContentForeground);


                /*
                var textBack = new Rectangle(rect.X, rect.Y, size.Width, size.Height);
                
                using (var b = new SolidBrush(backColor))
                {
                    e.Graphics.FillRectangle(b, textBack);
                }
                */
            }
            else
            {
                foreColor = ZipTag.GetForeColor(backColor);
                using (var b = new SolidBrush(backColor))
                {
                    e.Graphics.FillRectangle(b, e.CellBounds);
                }
            }

            var simpleBookmark = bookmark.SimpleBookmark;
            var role = simpleBookmark.SpecialRole;
            if (role == SimpleBookmarkSpecialRole.None)
            {
                TextRenderer.DrawText(e.Graphics, text, font, rect, foreColor, TextFormatFlags.EndEllipsis/* | TextFormatFlags.NoPrefix*/);
            }
            else if (role == SimpleBookmarkSpecialRole.Separator)
            {
                var margin = e.CellBounds.Height / 4;
                var vCenter = (e.CellBounds.Top + e.CellBounds.Bottom) / 2;

                e.Graphics.DrawLine(/*isSelected ? Pens.White : foreColor == Color.White ? Pens.White :*/isSelected ? Pens.Gray : Pens.LightGray,
                    e.ClipBounds.Left + margin, vCenter, e.ClipBounds.Right - margin, vCenter);

                //rect.X = Math.Max(rect.X, rect.X + (e.CellBounds.Width - rect.Width) / 2) - margin;
                //rect.Width = Math.Min(rect.Width + 2 * margin, e.CellBounds.Right - rect.Left);

                rect.X = e.CellBounds.X;
                rect.Width = e.CellBounds.Width;

                TextRenderer.DrawText(e.Graphics, text, font, rect, foreColor, isSelected ? e.CellStyle.SelectionBackColor : backColor,
                    TextFormatFlags.EndEllipsis | TextFormatFlags.NoPrefix | TextFormatFlags.HorizontalCenter);
            }

            e.Handled = true;

        }

        //private ToolStripMenuItem[] setMenuItemEventHandler_menuItemArray = null;
        private void setMenuItemEventHandler()
        {
            var list = new List<ToolStripMenuItem>();
            foreach (var info in typeof(CatalogForm).GetFields(BindingFlags.NonPublic | BindingFlags.Instance))
            {
                if (info.FieldType == typeof(ToolStripMenuItem))
                {
                    var item = info.GetValue(this) as ToolStripMenuItem;
                    if (item?.Owner == menuStrip)
                    {
                        /*
                        item.DropDownOpening += ForeColorChanger;
                        item.DropDownClosed += ForeColorChanger;
                        item.MouseEnter += ForeColorChanger;
                        item.MouseLeave += ForeColorChanger;
                        */
                        list.Add(item);
                    }
                }
            }
            //setMenuItemEventHandler_menuItemArray = list.ToArray();

            /*
            blackToolStripMenuItem.MouseEnter += ForeColorChanger2;
            blackToolStripMenuItem.MouseLeave += ForeColorChanger2;
            grayToolStripMenuItem.MouseEnter += ForeColorChanger2;
            grayToolStripMenuItem.MouseLeave += ForeColorChanger2;
            selectColorToolStripMenuItem.MouseEnter += ForeColorChanger2;
            selectColorToolStripMenuItem.MouseLeave += ForeColorChanger2;
            
            backgroundColorOfBuiltinViewerToolStripMenuItem.DropDownOpening += BackgroundColorOfBuiltinViewerToolStripMenuItem_DropDownOpening;
            */

            ForeColorManager.Set(blackToolStripMenuItem, grayToolStripMenuItem, selectColorToolStripMenuItem);
            ForeColorManager.Set(list);

            //ToolStripManager.Renderer = new ToolStripProfessionalRenderer(new SuitableForeColorProfessionalColorTable());
        }

        /*
        private void ForeColorChanger(object sender, EventArgs e)
        {
            setMenuItemColor(sender as ToolStripMenuItem);
        }

        private void ForeColorChanger2(object sender, EventArgs e)
        {
            setMenuItemColor2(sender as ToolStripMenuItem);
        }


        private void setMenuItemColor()
        {
            foreach (var item in setMenuItemEventHandler_menuItemArray)
            {
                setMenuItemColor(item);
            }
        }

        public static void SetMenuItemColor(ToolStripMenuItem item, Color normalColor)
        {
            if (item.DropDown.Visible || item.Bounds.Contains(item.Owner.PointToClient(Cursor.Position)))
            //if (item.Selected || item.DropDown.Visible || item.Bounds.Contains(item.Owner.PointToClient(Cursor.Position)))
            {
                item.ForeColor = Color.Black;
            }
            else
            {
                item.ForeColor = normalColor;
            }
        }

        private void setMenuItemColor2(ToolStripMenuItem item)
        {
            SetMenuItemColor(item, ZipTag.GetForeColor(item.BackColor));
        }

        private void setMenuItemColor(ToolStripMenuItem item)
        {
            SetMenuItemColor(item, currentProfileColor_ForeColor);
        }
        */

        private void addToolStripMenuItem_Click(object sender, EventArgs e)
        {
            currentLocationToolStripMenuItem_Click(null, null);
        }

        private void addToolStripMenuItem_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                addToolStripMenuItem.DropDown = addToolStripMenuItemDropDown;
                addToolStripMenuItem_DropDownOpening(null, null);

                var bounds = addToolStripMenuItem.Bounds;

                addToolStripMenuItemDropDown.Show(menuStripLeft.PointToScreen(new Point(bounds.Left, bounds.Bottom - 1)));
            }
        }

        private void openbuiltinBookReaderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            Process.Start(Application.ExecutablePath, "-v");
        }

        private void removeCoverSettingFromCurrentLocation()
        {
            if (!InMovie && !InArchive) return; // 対応を増やす場合 StopReloadAndRenameCurrentLocation で先読みプロセスの処理をすること
            var cl = currentLocation;
            var info = new ZipPlaInfo(cl);
            info.ThumbnailInfo = null;
            var newPath = info.GetPathOfCurrentInfo(isDir: false); // InMovie または InArchive なら親は動画または圧縮ファイルでありフォルダではない
            //StopReloadAndRenameCurrentLocation(cl, info.GetPathOfCurrentInfo(), (success) =>
            StopReloadAndRenameCurrentLocation(cl, newPath, (success) =>
            {
                string preloc;
                int prelen;
                if (success && undoBufferIndex > 0 && newPath.StartsWith(preloc = undoBuffer[undoBufferIndex - 1].Location + Path.DirectorySeparatorChar) &&
                    // cl.Substring(prelen = preloc.Length).ToLower() == undoBuffer[undoBufferIndex - 1].SelectedFileName.ToLower())
                    newPath.Substring(prelen = preloc.Length).ToLower() == undoBuffer[undoBufferIndex - 1].SelectedFileName.ToLower())
                {
                    //currentLocation = newPath;
                    //undoBuffer[undoBufferIndex - 1].SelectedFileName = newPath.Substring(prelen);
                    UpdatePreview(renamedLocation: newPath);
                }
                else if (success)
                {
                    //UpdatePreview(renamedLocation: newPath);
                    changeCurrentAndGoUpFromCurrentLocation(newPath);
                }
                else
                {
                    UpdatePreview();
                }
            });
        }

        private void setCoverToThisToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!InMovie) return;
            var index = tvCatalog.SelectedIndex;
            if (index < 0) return;
            var zna = ZipNameArray;
            if (zna == null || zna.Length <= index) return;
            var timeString = zna[index];

            var cl = currentLocation;
            var info = new ZipPlaInfo(cl);

            info.ThumbnailInfo = getMoviePostionTuple(timeString);

            var newPath = info.GetPathOfCurrentInfo(isDir: false); // InMovie なら親は動画ファイルでありフォルダではない
            string oldName;
            try { oldName = Path.GetFileName(cl); } catch { oldName = cl; }
            string preloc;
            int prelen;
            //StopReloadAndRenameCurrentLocation(cl, info.GetPathOfCurrentInfo(), (success) =>
            StopReloadAndRenameCurrentLocation(cl, newPath, (success) =>
            {
                if (success && undoBufferIndex > 0 && newPath.StartsWith(preloc = undoBuffer[undoBufferIndex - 1].Location + Path.DirectorySeparatorChar) &&
                    //cl.Substring(prelen = preloc.Length).ToLower() == undoBuffer[undoBufferIndex - 1].SelectedFileName.ToLower())
                    newPath.Substring(prelen = preloc.Length).ToLower() == undoBuffer[undoBufferIndex - 1].SelectedFileName.ToLower())
                {
                    //currentLocation = newPath;
                    //undoBuffer[undoBufferIndex - 1].SelectedFileName = newPath.Substring(prelen);
                    btnGoToBack.PerformClick();
                }
                else if (success)
                {
                    //UpdatePreview(renamedLocation: newPath);
                    changeCurrentAndGoUpFromCurrentLocation(newPath);
                }
                else
                {
                    UpdatePreview();
                }
            });
        }

        private Tuple<int, double> getMoviePostionTuple(string timeString)
        {
            TimeSpan time;
            try
            {
                time = TimeSpan.Parse(timeString);
            }
            catch
            {
                time = TimeSpan.Zero;
            }

            var ts = time.TotalSeconds;
            var its = (int)ts;
            var rem = ts - its;

            return Tuple.Create(its, rem);
        }

        private void StopReloadAndRenameCurrentLocation(string oldPath, string newPath, Action<bool> leftAction)
        {
            MakePreview_Que = false;
            bwMakePreviewPrepare.CancelAsync();

            BackgroundMultiWorker.AllRunWorkerCompletedEventHandler eh = null;

            var bwBusy = bmwMakePreview.IsBusy;

            eh = (sender, e) =>
            {
                if (oldPath == currentLocation)
                {
                    var success = false;
                    if (oldPath != newPath)
                    {

                        try
                        {
                            // Archive でも使うように変更する場合先読みプロセスに気をつけること
                            var stopLookAhead = PackedImageLoader.Supports(oldPath);
                            if (stopLookAhead)
                            {
                                StopLookAheadProcess();
                            }

                            //if (bwBusy)
                            /*
                            if (!bwBusy)
                            {
                                Program.FileOrDirectoryMove(oldPath, newPath);
                            }*/
                            else
                            {
                                try
                                {
                                    Program.FileOrDirectoryMove(oldPath, newPath);
                                }
                                catch (IOException)
                                {
                                    Thread.Sleep(14 * MovieThumbnailLoader.FfmpegCancelCheckInterval / 10);
                                    Program.FileOrDirectoryMove(oldPath, newPath);
                                }
                            }

                            if (stopLookAhead)
                            {
                                PrepareLookAheadProcess();
                            }


                            // swapPathAndNameInSorBookmarkUndoBuff が例外を投げるのは currentLocation が sor のときだけだが
                            // ここでその条件は満たされないのでこの try は将来の変更に備えたもの
                            try
                            {
                                swapPathAndNameInSorBookmarkUndoBuff(oldPath, newPath, needToSaveBookmark: false);
                                // CurrentLocation をリネームした後 makePreview を呼び出さない使い方は想定されないので needToSaveBookmark = false
                            }
                            catch { }
                            success = true;
                        }
                        catch (Exception error)
                        {
                            Task.Run(() => Invoke((MethodInvoker)(() => CloseVisibleContextMenuStrips())));
                            MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                            Task.Run(() => Invoke((MethodInvoker)(() => tvCatalog.DoMouseUp())));
                        }
                    }

                    bmwMakePreview.AllRunWorkersCompleted -= eh;
                    leftAction(success);
                }
                else
                {
                    bmwMakePreview.AllRunWorkersCompleted -= eh;
                }
            };

            //if (bmwMakePreview.IsBusy)
            if (bwBusy)
            {
                MakePreview_Que = false;
                bmwMakePreview.AllRunWorkersCompleted += eh;
                bmwMakePreview.CancelAsync();
            }
            else
            {
                eh(null, null);
            }
        }
        
        private void fileSystemWatcher_Deleted(object sender, FileSystemEventArgs e)
        {
            var fullPath = e.FullPath;
            GPSizeThumbnail.TryMove(thumbnailCache, e.FullPath, null);
            if (CreatingZipPathArray)
            {
                BackgroundMultiWorker.RunWorkerStartingEventHandler eh = null;
                eh = (s2, e2) =>
                {
                    if (!fileSystemWatcherStopper(ref e)) removeItem(fullPath);
                    bmwMakePreview.RunWorkerStarting -= eh;
                };
                bmwMakePreview.RunWorkerStarting += eh;
            }
            else
            {
                removeItem(fullPath);
            }
        }

        private bool isCacheFolder(string path)
        {
            var c = thumbnailCache;
            if (c == null || c == GPSizeThumbnail.AlternateDataStream) return false;
            try
            {
                return Path.GetFileName(path).ToLower() == Path.GetFileName(thumbnailCache).ToLower();
            }
            catch
            {
                return false;
            }
        }

        private bool fileSystemWatcherStopper(ref FileSystemEventArgs e)
        {
            // FileSystemWatcher は以下の２行が意味を持つという期待されない仕様を持つ
            if (!fileSystemWatcher.EnableRaisingEvents) return true;
            var path = fileSystemWatcher.Path;

            if (string.IsNullOrEmpty(path)) return true;
            try
            {
                var pathToLower = path.ToLower();
                if (!string.IsNullOrEmpty(pathToLower) && pathToLower.Last() == ':') pathToLower += Path.DirectorySeparatorChar;
                var dirName = Path.GetDirectoryName(e.FullPath);
                var dirNameInLower = dirName.ToLower();
                if (pathToLower == dirNameInLower)
                {
                    return false;
                }

                var subfolderIsSearched = SubfolderIsSearched();
                if (subfolderIsSearched && !IsDisplay(SubfolderMode))
                {
                    var pathInLowerYen = pathToLower.Last() == Path.DirectorySeparatorChar ? pathToLower : (pathToLower + Path.DirectorySeparatorChar);
                    return !dirNameInLower.StartsWith(pathInLowerYen);
                }
                else
                {
                    if (!subfolderIsSearched && ((e.ChangeType & WatcherChangeTypes.Changed) != WatcherChangeTypes.Changed || !IsDisplay(SubfolderMode)))
                    {
                        return true;
                    }
                    var pathInLowerYen = pathToLower.Last() == Path.DirectorySeparatorChar ? pathToLower : (pathToLower + Path.DirectorySeparatorChar);
                    if (!dirNameInLower.StartsWith(pathInLowerYen))
                    {
                        return true;
                    }
                    var pathYenLen = pathInLowerYen.Length;
                    var pos = dirNameInLower.IndexOf(Path.DirectorySeparatorChar, pathYenLen + 1);
                    if (pos < 0) pos = dirNameInLower.Length;
                    var depth = dirName.Substring(pos).Count(c => c == Path.DirectorySeparatorChar);
                    int depthBound;
                    switch (ArchivesInArchiveMode)
                    {
                        case ArchivesInArchiveMode.Ignore: depthBound = 0; break;
                        case ArchivesInArchiveMode.IfNoOther1Level:
                        case ArchivesInArchiveMode.Always1Level: depthBound = 1; break;
                        default: depthBound = 2; break;
                    }
                    if (depth <= depthBound || depth - 1 == depthBound && Directory.Exists(dirName.Substring(0, pos)))
                    {
                        var childName = dirName.Substring(pathYenLen, pos - pathYenLen);
                        e = new FileSystemEventArgs(e.ChangeType, path, childName);
                        return false;
                    }
                    else return true;
                }
            }
            catch
            {
                return false;
            }
        }

        private void fileSystemWatcher_Created(object sender, FileSystemEventArgs e)
        {
            if (fileSystemWatcherStopper(ref e)) return;
            var fullPath = e.FullPath;
            var startingGuid = loadingGuid;
            if (CreatingZipPathArray)
            {
                BackgroundMultiWorker.RunWorkerStartingEventHandler eh = null;
                eh = (s2, e2) =>
                {
                    //addOrReloadItem(fullPath, thumbnailChanged: null);
                    if (!fileSystemWatcherStopper(ref e)) addOrReloadItem(fullPath, thumbnailChanged: true, startingGuid: startingGuid);
                    bmwMakePreview.RunWorkerStarting -= eh;
                };
                bmwMakePreview.RunWorkerStarting += eh;
            }
            else
            {
                //addOrReloadItem(fullPath, thumbnailChanged: null);
                addOrReloadItem(fullPath, thumbnailChanged: true, startingGuid: startingGuid);
            }
        }

        private void fileSystemWatcher_Changed(object sender, FileSystemEventArgs e)
        {
            if (isCacheFolder(e.FullPath)) return;
            fileSystemWatcher_Created(sender, e);
        }

        private void fileSystemWatcher_Renamed(object sender, RenamedEventArgs e)
        {
            FileSystemEventArgs alt = e;
            if (fileSystemWatcherStopper(ref alt)) return;
            var startingGuid = loadingGuid;

            // https://connect.microsoft.com/VisualStudio/feedback/details/520436/renamedeventargs-oldfullpath-throws-pathtoolongexception の問題に対処
            string oldFullPath;
            try { oldFullPath = e.OldFullPath; } catch (PathTooLongException) { return; }

            GPSizeThumbnail.TryMove(thumbnailCache, oldFullPath, e.FullPath);
            if (GPSizeThumbnail.Editing(e.FullPath)) return;

            if (CreatingZipPathArray)
            {
                BackgroundMultiWorker.RunWorkerStartingEventHandler eh = null;
                eh = (s2, e2) =>
                {
                    if (!fileSystemWatcherStopper(ref alt)) renameItem(e.FullPath, oldFullPath, startingGuid);
                    bmwMakePreview.RunWorkerStarting -= eh;
                };
                bmwMakePreview.RunWorkerStarting += eh;
            }
            else
            {
                renameItem(e.FullPath, oldFullPath, startingGuid);
            }
        }

        private int QuickReloadProcessingCount = 0;
        private void enterQuickReload()
        {
            QuickReloadProcessingCount++;
        }

        private void exitQuickReload(Guid startingGuid)
        {
            QuickReloadProcessingCount--;
            if (QuickReloadProcessingCount <= 0 && loadingGuid == startingGuid)
            {
                lock (loadingPackedImageLoaderLocker)
                {
                    var sp = tvCatalog.ScrollBarPercentage;
                    tvCatalog.ShowIndexToDataIndex = GetSortArray(preSortArray: tvCatalog.ShowIndexToDataIndex);
                    tvCatalog.ScrollBarPercentage = sp;
                    setFileListFromThumbnailViewer(tryToKeepScroll: true);
                }
            }
        }

        private void removeItem(string path)
        {
            if (CreatingZipPathArray) return;
            var zpa = ZipPathArray;
            var zma = ZipMaskArray;
            if (zpa != null && zma != null && zpa.Length == zma.Length && zpa.Length == tvCatalog.Count)
            {
                var idx = Array.IndexOf(zpa, path);
                if (idx >= 0)
                {
                    enterQuickReload();
                    zma[idx] = false;
                    zpa[idx] = null;
                    var item = tvCatalog[idx];
                    if (item != null)
                    {
                        if (idx != tvCatalog.FocusedIndex)
                        {
                            item.Dispose();
                            tvCatalog[idx] = null;
                        }
                        else
                        {
                            var d2s = tvCatalog.DataIndexToShowIndex;
                            var s2d = tvCatalog.ShowIndexToDataIndex;
                            item.Dispose();
                            tvCatalog[idx] = null;
                            if (idx < d2s.Length)
                            {
                                var sIdx = Math.Min(s2d.Length - 2, d2s[idx]);
                                if (sIdx >= 0)
                                {
                                    tvCatalog.FocusedIndex = s2d[sIdx + 1];
                                }
                            }
                        }
                    }
                    exitQuickReload(loadingGuid);
                }
            }
        }

        private static bool hasSameType(string pathA, string pathB)
        {
            try
            {
                return Path.GetExtension(pathA).ToLower() == Path.GetExtension(pathB).ToLower();
            }
            catch
            {
                return false;
            }
        }

        private void renameItem(string newPath, string oldPath, Guid startingGuid)
        {
            if (newPath == null || oldPath == null) return;
            if (ShouldBeSkippedForFileAndDirWithCheckAttributes(newPath, ffmpeExists: null))
            {
                removeItem(oldPath);
                return;
            }
            if (CreatingZipPathArray) return;
            var zpa = ZipPathArray;
            var zma = ZipMaskArray;
            var zna = ZipNameArray;
            var lra = LoadResultArray;
            var mta = ModifiedTimeArray;
            var d2s = tvCatalog.DataIndexToShowIndex;
            if (zpa != null && zma != null && zna != null && mta != null &&
                zpa.Length == zma.Length && zpa.Length == zna.Length && zpa.Length == mta.Length &&
                zpa.Length == tvCatalog.Count && d2s != null && d2s.Length == zpa.Length
                && lra != null && lra.Length == zpa.Length)
            {
                var idx = Array.IndexOf(zpa, oldPath);
                var needNotToReload = idx >= 0;
                bool? thumbnailChanged = null;
                if (needNotToReload)
                {
                    if (!hasSameType(oldPath, newPath))
                    {
                        needNotToReload = false;
                    }
                    else
                    {
                        var oldInfo = new ZipPlaInfo(oldPath);
                        var newInfo = new ZipPlaInfo(newPath);
                        needNotToReload = oldInfo.ThumbnailInfo == newInfo.ThumbnailInfo;
                    }
                    thumbnailChanged = !needNotToReload;
                    needNotToReload = needNotToReload && lra[idx] == LoadResult.Success;
                }
                if (needNotToReload)
                {
                    zma[idx] = true;
                    zpa[idx] = newPath;
                    var name = getRelativePath(newPath, zna[idx]);
                    zna[idx] = name;
                    //enterQuickReload();
                    //await Task.Run(() => ReloadOneThumbnailForSubThread(idx, newPath, newPath, silent: true));

                    swapPathAndNameInSorBookmarkUndoBuff(oldPath, newPath, needToSaveBookmark: true);

                    var item = tvCatalog[idx];
                    item.SilentSet(name);
                    item.DrawItem(onlyFrame: false);
                    var showIndex = d2s[idx];
                    if (showIndex >= 0 && showIndex < dgvFileList.Rows.Count)
                    {
                        try
                        {
                            setFileListRowStaticGlobalPart(dgvFileList.Rows[showIndex], newPath, name, mta[idx]);
                        }
                        catch (Exception e)
                        {
#if DEBUG
                            MessageBox.Show(this, e.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                            MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                            return;
                        }
                        ShowStatusBar();
                    }
                    //exitQuickReload();
                }
                else if (Array.IndexOf(zpa, newPath) < 0) // ZipPla 自身がリネームを行った場合既に更新されている
                {
                    addOrReloadItem(newPath, zpa, zma, lra, idx, thumbnailChanged, startingGuid);
                }
            }
        }

        //public static readonly HashSet<string> addOrReloadItem_OneTimeBlackList = new HashSet<string>(); // スレッドセーフ
        //volatile private bool addOrReloadItem_Excuting = false;
        private void addOrReloadItem(string path, bool? thumbnailChanged, Guid startingGuid)
        {
            if (GPSizeThumbnail.Editing(path))
            {
                return;
            }

            //MessageBox.Show($"getzpa");
            //Application.DoEvents(); // fileSystemWatcher のイベントのスレッドの特殊な振る舞いに対処
            //while (addOrReloadItem_Excuting) Application.DoEvents();
            //addOrReloadItem_Excuting = true;
            if (CreatingZipPathArray) return;
            var zpa = ZipPathArray;
            if (zpa == null) return;
            var count = zpa.Length;

            var zma = ZipMaskArray;
            if (zma == null || zma.Length != count) return;

            var lra = LoadResultArray;
            if (lra == null || lra.Length != count) return;

            if (ShouldBeSkippedForFileAndDirWithCheckAttributes(path, ffmpeExists: null)) return;

            var idx = Array.IndexOf(zpa, path);
            addOrReloadItem(path, zpa, zma, lra, idx, thumbnailChanged, startingGuid);
        }
        
        private HashSet<string> addOrReloadItem_UserAddFileInLower = null;
        private async void addOrReloadItem(string path, string[] zpa, bool[] zma, LoadResult[] lra, int idx, bool? thumbnailChanged, Guid startingGuid)
        {
            var count = zpa.Length;
            if (idx >= 0) // reload
            {
                var oldPath = zpa[idx];
                bool tc;
                if (thumbnailChanged != null) tc = (bool)thumbnailChanged;
                else if (oldPath != null)
                {
                    var oldInfo = new ZipPlaInfo(oldPath);
                    var newInfo = new ZipPlaInfo(path);
                    tc = oldInfo.ThumbnailInfo != newInfo.ThumbnailInfo;
                }
                else
                {
                    tc = false;
                }
                var silentMode = tc ? SilentMode.Never : lra[idx] == LoadResult.Success ? SilentMode.Always : SilentMode.OnlyIfNotSuccess;
                zma[idx] = true;
                zpa[idx] = path;
                //enterQuickReload();
                await Task.Run(() => ReloadOneThumbnailForSubThread(idx, path, startingGuid, path, silentMode));
                //exitQuickReload();
                return;
            }
            else // add
            {
                //MessageBox.Show($"{InvokeRequired}, {count}");
                const SilentMode silentModeForAdd = SilentMode.Never;

                for (var i = 0; i < count; i++)
                {
                    if (!zma[i])
                    {
                        zma[i] = true;
                        zpa[i] = path;

                        addOrReloadItem_Add(i, path, silentModeForAdd);
                        return;

                        /*
                        enterQuickReload();
                        await Task.Run(() => ReloadOneThumbnailForSubThread(i, path, path, silentModeForAdd));
                        exitQuickReload();
                        return;
                        */
                    }
                }

                var zipPathArray = zpa;
                var zipNameArray = ZipNameArray; if (zipNameArray == null || zipNameArray.Length != count) return;
                var zipPageArray = ZipPageArray; if (zipPageArray == null || zipPageArray.Length != count) return;
                var createTimeArray = CreateTimeArray; if (createTimeArray == null || createTimeArray.Length != count) return;
                var lastAccessTimeArray = LastAccessTimeArray; if (lastAccessTimeArray == null || lastAccessTimeArray.Length != count) return;
                var modifiedTimeArray = ModifiedTimeArray; if (modifiedTimeArray == null || modifiedTimeArray.Length != count) return;
                var fileCountArray = FileCountArray; if (fileCountArray == null || fileCountArray.Length != count) return;
                var imageInfoArray = ImageInfoArray; if (imageInfoArray == null || imageInfoArray.Length != count) return;
                var movieInfoArray = MovieInfoArray; if (movieInfoArray == null || movieInfoArray.Length != count) return;
                var loadResultArray = LoadResultArray; if (loadResultArray == null || loadResultArray.Length != count) return;
                var zipSizeArray = ZipSizeArray; if (zipSizeArray == null || zipSizeArray.Length != count) return;
                var zipMaskArray = zma;

                var count21 = Math.Max(count * 2 + 1, count + (addOrReloadItem_UserAddFileInLower?.Count ?? 0));
                //var count21 = count * 2 + 1;

                var zipPathArray2 = new string[count21]; Array.Copy(zipPathArray, zipPathArray2, count);
                var zipNameArray2 = new string[count21]; Array.Copy(zipNameArray, zipNameArray2, count);
                var zipPageArray2 = new int[count21]; Array.Copy(zipPageArray, zipPageArray2, count);
                var createTimeArray2 = new DateTime[count21]; Array.Copy(createTimeArray, createTimeArray2, count);
                var lastAccessTimeArray2 = new DateTime[count21]; Array.Copy(lastAccessTimeArray, lastAccessTimeArray2, count);
                var modifiedTimeArray2 = new DateTime[count21]; Array.Copy(modifiedTimeArray, modifiedTimeArray2, count);
                var fileCountArray2 = new int[count21]; Array.Copy(fileCountArray, fileCountArray2, count);
                var imageInfoArray2 = new ImageInfo[count21]; Array.Copy(imageInfoArray, imageInfoArray2, count);
                var movieInfoArray2 = new MovieInfo[count21]; Array.Copy(movieInfoArray, movieInfoArray2, count);
                var loadResultArray2 = new LoadResult[count21]; Array.Copy(loadResultArray, loadResultArray2, count);
                var zipSizeArray2 = new long[count21]; Array.Copy(zipSizeArray, zipSizeArray2, count);
                var zipMaskArray2 = new bool[count21]; Array.Copy(zipMaskArray, zipMaskArray2, count);

                for (var i = count; i < count21; i++)
                {
                    zipPageArray2[i] = -1;
                }

                lock (ZipPathArrayLocker)
                {
                    ZipPathArray = zipPathArray2;
                    ZipNameArray = zipNameArray2;
                    ZipPageArray = zipPageArray2;
                    CreateTimeArray = createTimeArray2;
                    LastAccessTimeArray = lastAccessTimeArray2;
                    ModifiedTimeArray = modifiedTimeArray2;
                    FileCountArray = fileCountArray2;
                    ImageInfoArray = imageInfoArray2;
                    MovieInfoArray = movieInfoArray2;
                    LoadResultArray = loadResultArray2;
                    ZipSizeArray = zipSizeArray2;
                    ZipMaskArray = zipMaskArray2;
                }
                //MessageBox.Show($"{ZipPathArray.Length}");
                tvCatalog.ItemBuffSizeChange(count21);

                ZipMaskArray[count] = true;
                ZipPathArray[count] = path;

                addOrReloadItem_Add(count, path, silentModeForAdd);
            }
        }
        private async void addOrReloadItem_Add(int index, string path, SilentMode silentModeForAdd)
        {
            enterQuickReload();
            //var selectedCount = addOrReloadItem_UserAddFileInLower != null ? tvCatalog.SelectedIndicesCount : 0;
            var startingGuid = loadingGuid;

            // Add が呼ばれるということはそれ以前はそのパスのファイルが存在しなかったとういこと
            // 従ってファイルの追従に失敗していなければ履歴にそのパスは存在しない
            // 失敗している場合は残っているが、そのケースでだけ情報が復元される仕様は不適切
            const bool reloadPage = false;

            await Task.Run(() =>
            {
                ReloadOneThumbnailForSubThread(index, path, startingGuid, path, silentModeForAdd, reloadPage);
            });
            exitQuickReload(startingGuid);
            if (startingGuid != loadingGuid) return;
            if (QuickReloadProcessingCount <= 0 && addOrReloadItem_UserAddFileInLower != null)
            {
                if (CreatingZipPathArray) return;
                var s2d = tvCatalog.ShowIndexToDataIndex;
                if (s2d == null || s2d.Length <= 0) return;
                var zpa = ZipPathArray;
                if (zpa == null || zpa.Length <= 0) return;

                var count = zpa.Length;
                var path2indexPair = new Dictionary<string, Tuple<int, int>>();
                for (var i = 0; i < s2d.Length; i++)
                {
                    var si = s2d[i];
                    if (si >= 0 && si < count)
                    {
                        var p = zpa[si];
                        if (p != null) path2indexPair[p] = Tuple.Create(si, i);
                    }
                }
                
                var currentSelected = tvCatalog.SelectedIndices;
                HashSet<int> selectedIndices;
                if (currentSelected != null && currentSelected.Length > 0)
                {
                    selectedIndices = new HashSet<int>(currentSelected);
                }
                else
                {
                    selectedIndices = new HashSet<int>();
                }
                
                var deleteList = new List<string>();
                var topShowIndex = selectedIndices.Count == 0 ? int.MaxValue : -1;
                foreach (var p in addOrReloadItem_UserAddFileInLower)
                {
                    Tuple<int, int> i;
                    if (path2indexPair.TryGetValue(p, out i))
                    {
                        var si = i.Item1;
                        deleteList.Add(p);
                        selectedIndices.Add(si);
                        if (topShowIndex > i.Item2)
                        {
                            topShowIndex = i.Item2;
                        }
                    }
                }
                foreach (var d in deleteList) addOrReloadItem_UserAddFileInLower.Remove(d);
                if (addOrReloadItem_UserAddFileInLower.Count == 0) addOrReloadItem_UserAddFileInLower = null;

                tvCatalog.SelectedIndices = selectedIndices.ToArray();
                if (0 <= topShowIndex && topShowIndex < int.MaxValue)
                {
                    tvCatalog.ScrollBarToIndexWithMinimalMove(showIndex: topShowIndex);
                }
                /*
                if (addOrReloadItem_UserAddFileInLower.Contains(path))
                {
                    addOrReloadItem_UserAddFileInLower.Remove(path);
                    if (addOrReloadItem_UserAddFileInLower.Count == 0) addOrReloadItem_UserAddFileInLower = null;

                    var selectedIndices = tvCatalog.SelectedIndices;
                    var d2s = tvCatalog.ShowIndexToDataIndex;
                    if (index >= 0 && index < d2s.Length)
                    {
                        var showIndex = d2s[index];
                        if (showIndex >= 0)
                        {
                            if (selectedIndices == null) selectedIndices = new int[0];
                            var newSelected = new int[selectedIndices.Length + 1];
                            Array.Copy(selectedIndices, newSelected, selectedIndices.Length);
                            newSelected[selectedIndices.Length] = showIndex;
                            tvCatalog.SelectedIndices = newSelected;
                            if (tvCatalog.SelectedIndicesCount == 1)
                            {
                                tvCatalog.ScrollBarToIndexWithMinimalMove(showIndex: showIndex);
                            }
                        }
                    }
                }
                */
            }
        }

        private void addToUserAddFileList(IEnumerable<string> paths)
        {
            if (paths == null || !paths.Any()) return;
            tvCatalog.SelectedIndex = -1;
            if (addOrReloadItem_UserAddFileInLower == null)
            {
                addOrReloadItem_UserAddFileInLower = new HashSet<string>(from path in paths where path != null select path/*.ToLower()*/);
                if (addOrReloadItem_UserAddFileInLower.Count == 0) addOrReloadItem_UserAddFileInLower = null;
            }
            else
            {
                foreach (var path in paths)
                {
                    if (path != null)
                    {
                        addOrReloadItem_UserAddFileInLower.Add(path/*.ToLower()*/);
                    }
                }
            }
        }

        private void setFileListDockForUser(DockStyle dock)
        {
            if (!thumbnailListToolStripMenuItem.Checked) thumbnailListToolStripMenuItem.Checked = true;
            if (!fileListToolStripMenuItem.Checked) fileListToolStripMenuItem.Checked = true;
            setFileListDock(dock, keepWidth: true, fixWidth: true);
        }

        private void verticalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setFileListDockForUser(DockStyle.Bottom);
        }

        private void alternativeVerticalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setFileListDockForUser(DockStyle.Top);
        }

        private void horizontalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setFileListDockForUser(DockStyle.Right);
        }

        private void alternativeHorizontalToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setFileListDockForUser(DockStyle.Left);
        }

        private void reloadAllItemsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            userReload();
        }

        private void userReload()
        {
            SmartStaticIconProvider.ClearIconCache();
            UpdatePreview();
        }



        // マウスダウンイベントに InDirectoryOrVirtualDirectory のイベントが割り当ててある
        private void clearThumbnailSettingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (InMovie || InArchive) removeCoverSettingFromCurrentLocation();
        }

        private void addToolStripMenuItem_DropDownClosed(object sender, EventArgs e)
        {

            addToolStripMenuItem.DropDown = null;
            AllowFullpower = true;
        }

        /*
        private void changeCurrentProfileColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            using (var cd = new ColorDialog())
            {

                //cd.CustomColors = new int[] { currentProfileColor.R | currentProfileColor.G << 8 | currentProfileColor.B << 16 };

                var cc = cd.CustomColors;
                cc[cc.Length - 1] = currentProfileColor.R | currentProfileColor.G << 8 | currentProfileColor.B << 16;
                cd.CustomColors = cc;

                cd.Color = currentProfileColor;
                cd.AllowFullOpen = true;
                cd.SolidColorOnly = false;
                while (cd.ShowDialog() == DialogResult.OK)
                {
                    var newColor = cd.Color;

                    if (ColorEquals(currentProfileColor, newColor)) break;

                    var sameColorBookmarks = "";
                    var existingColors = new HashSet<Color>();
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (bookmark == null || bookmark.SimpleBookmark.SpecialRole != SimpleBookmarkSpecialRole.None) continue; // セパレーターなら無視される
                        existingColors.Add(bookmark.Color);
                        if (ColorEquals(bookmark.Color, newColor))
                        {
                            sameColorBookmarks += "\n" + bookmark;
                        }
                    }

                    if (sameColorBookmarks != "")
                    {
                        if (MessageBox.Show(this, Message.SelectedColorIsUsedByFollowingBookmarks + "\n" + sameColorBookmarks, null, MessageBoxButtons.OKCancel, MessageBoxIcon.Error) == DialogResult.OK)
                        {
                            continue;
                        }
                        else
                        {
                            break;
                        }
                    }

                    newColor = (SerializableRGB)newColor;

                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (bookmark != null && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None && bookmark.Color == currentProfileColor)// セパレーターなら無視される
                        {
                            bookmark.Color = newColor;
                        }
                    }

                    foreach (var buf in undoBuffer)
                    {
                        if (buf.ProfileColor == currentProfileColor)
                        {
                            buf.ProfileColor = newColor;
                        }
                    }


                    saveBookmarkToIni_bookmarkChanged = true;
                    saveBookmarkToConfig();

                    currentProfileColor = newColor;

                    dgvDirectoryList.Invalidate();

                    // if (Tags == null) Tags = new ZipTag[0]; // currentConditionToColoredBookmark で行われる
                    //var config = new ZipTagConfig();
                    //config.Tags = Tags;
                    //config.ProfileColor = currentProfileColor;
                    //config.Save();

                    break;
                }
            }

            AllowFullpower = true;
        }
        */

        private void changeCurrentProfileColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            var bookmarksWithCurrentColor = GetBookmarksStringColoredBy(currentProfileColor);
            var message = bookmarksWithCurrentColor != null ?
                $"{Message.WillChangeCurrentProfileColor}\n{Message.ThisChangeAlsoAffectsFollowingBookmarks}\n\n{bookmarksWithCurrentColor}\n\n{Message.HowToCreateNewColorDescription}" :
                $"{Message.WillChangeCurrentProfileColor}\n\n{Message.HowToCreateNewColorDescription}";


            var result = MessageBox.Show(this, message, Message.ChangeCurrentProfileColor, MessageBoxButtons.OKCancel, MessageBoxIcon.Information);
            if (result == DialogResult.OK)
            {
                AllowFullpower = false;
            }
            else
            {
                AllowFullpower = true;
                return;
            }
            
            var newColor = getNewProfileColorFromDialog(useCurrentAsDefault: true);
            if (!newColor.IsEmpty)
            {
                foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                {
                    var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                    if (bookmark != null && bookmark.SimpleBookmark.SpecialRole == SimpleBookmarkSpecialRole.None && bookmark.Color == currentProfileColor)// セパレーターなら無視される
                    {
                        bookmark.Color = newColor;
                    }
                }

                foreach (var buf in undoBuffer)
                {
                    if (buf.ProfileColor == currentProfileColor)
                    {
                        buf.ProfileColor = newColor;
                    }
                }

                saveBookmarkToIni_bookmarkChanged = true;
                saveBookmarkToConfig();

                currentProfileColor = newColor;

                dgvDirectoryList.Invalidate();
            }

            AllowFullpower = true;
        }

        private Color getNewProfileColorFromDialog(bool useCurrentAsDefault)
        {
            using (var cd = new ColorDialog())
            {
                Color dc;
                bool defaultExists = useCurrentAsDefault;
                if (defaultExists)
                {
                    dc = currentProfileColor;
                    var cc = cd.CustomColors;
                    cc[cc.Length - 1] = dc.R | dc.G << 8 | dc.B << 16;
                    cd.CustomColors = cc;
                    cd.Color = dc;
                }
                else
                {
                    dc = Color.Empty;
                }

                cd.AllowFullOpen = true;
                cd.SolidColorOnly = false;
                AllowFullpower = false;
                while (cd.ShowDialog(this) == DialogResult.OK)
                {
                    var newColor = cd.Color;

                    if (defaultExists && ColorEquals(dc, newColor))
                    {
                        AllowFullpower = false;
                        return Color.Empty;
                    }

                    /*
                    var sameColorBookmarks = "";
                    var existingColors = new HashSet<Color>();
                    var showLimit = 5;
                    foreach (DataGridViewRow row in dgvDirectoryList.Rows)
                    {
                        var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                        if (bookmark == null || bookmark.SimpleBookmark.SpecialRole != SimpleBookmarkSpecialRole.None) continue; // セパレーターなら無視される
                        existingColors.Add(bookmark.Color);
                        if (ColorEquals(bookmark.Color, newColor))
                        {
                            //sameColorBookmarks += "\n" + bookmark;

                            sameColorBookmarks += "\n" + bookmark;
                            showLimit--;
                            if (showLimit == 0)
                            {
                                sameColorBookmarks += "\n...";
                                break;
                            }
                        }
                    }
                    */
                    var sameColorBookmarks = GetBookmarksStringColoredBy(newColor);

                    if (!string.IsNullOrEmpty(sameColorBookmarks))
                    {
                        // ウインドウが切り替わると AllowFullpower が復帰する
                        AllowFullpower = false;
                        if (MessageBox.Show(this, Message.SelectedColorIsUsedByFollowingBookmarks + "\n\n" + sameColorBookmarks
                            + (useCurrentAsDefault ? "" : ("\n\n" + Message.HowToAddUsedColorDescription)), null, MessageBoxButtons.OKCancel, MessageBoxIcon.Error) == DialogResult.OK)
                        {
                            AllowFullpower = false;
                            continue;
                        }
                        else
                        {
                            AllowFullpower = false;
                            return Color.Empty;
                        }
                    }

                    return (SerializableRGB)newColor;
                }
                return Color.Empty;
            }
        }

        private string GetBookmarksStringColoredBy(Color color)
        {
            var sb = new StringBuilder();
            string lastLine = null;
            const int showLimit = 10;
            var lineCount = 0;
            foreach (DataGridViewRow row in dgvDirectoryList.Rows)
            {
                var bookmark = row.Cells[tbcDirectoryName.Index].Value as ColoredBookmark;
                if (bookmark == null || bookmark.SimpleBookmark.SpecialRole != SimpleBookmarkSpecialRole.None) continue; // セパレーターなら無視される
                if (ColorEquals(bookmark.Color, color))
                {
                    var line = bookmark.SimpleBookmark?.GetDisplayString() ?? "";
                    if (lineCount == 0)
                    {
                        sb.Append(line);
                    }
                    else if (lineCount < showLimit - 1)
                    {
                        sb.AppendLine().Append(line);
                    }
                    else if (lastLine == null)
                    {
                        lastLine = line;
                    }
                    else
                    {
                        sb.AppendLine().Append("...");
                        lastLine = null;
                        break;
                    }
                    lineCount++;
                }
            }
            if (lineCount == 0) return null;
            if (lastLine != null) sb.AppendLine().Append(lastLine);
            return sb.ToString();
        }

        private void newSmartFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            openSmartFolderSettingForm(null); // AllowFullpower 込み
        }

        private void openSmartFolderSettingForm(string smartFolderPath)
        {
            AllowFullpower = false;

            string output;
            using (var smartFolderSettingForm = new SmartFolderSettingForm(smartFolderPath))
            {
                smartFolderSettingForm.ShowDialog(this);
                output = smartFolderSettingForm.Edited ? smartFolderSettingForm.TargetSmartFolderPath : null;
            }
            if (output != null)
            {
                zabLocation.Text = output;
                MakePreview();
            }

            AllowFullpower = true;
        }

        private void setEraserAndSearchIcon()
        {
            var iconSize = cmsRightClick.ImageScalingSize;
            SelectionToFilterToolStripMenuItem.Icon = getIcon(drawInvertSearchIcon, iconSize.Width, iconSize.Height);

            SelectionToClipBoardToolStripMenuItem.Icon = getIcon(drawClipboardIcon, iconSize.Width, iconSize.Height);

            btnLocationCommands.FlatStyle = FlatStyle.Flat;
            btnLocationCommands.FlatAppearance.BorderColor = BackColor;
            btnLocationCommands.Text = null;
            btnLocationCommands.Image = getIcon(drawEraserIcon, btnLocationCommands.ClientRectangle.Width, btnLocationCommands.ClientRectangle.Height);

            btnFilterCommands.FlatStyle = FlatStyle.Flat;
            btnFilterCommands.FlatAppearance.BorderColor = BackColor;
            btnFilterCommands.Text = null;
            //btnFilterCommands.Paint += btnFilterCommands_Paint;
            btnFilterCommands.Image = getIcon(drawInvertSearchIcon, btnFilterCommands.ClientRectangle.Width, btnFilterCommands.ClientRectangle.Height);

            //pbSearch.Image = getSearchIcon(pbSearch.ClientRectangle.Width, pbSearch.ClientRectangle.Height);
        }

        /*
        private void btnFilterCommands_Paint(object sender, PaintEventArgs e)
        {
            var control = btnFilterCommands;
            var g = e.Graphics;
            var b = control.Enabled ? SystemBrushes.ControlText : Brushes.LightGray; //SystemBrushes.GrayText;
            var rect = control.ClientRectangle;

            drawSearchIcon(g, rect);
        }
        */

        private Bitmap getIcon(Action<Graphics, RectangleF> drawer, int width, int height)
        {
            var result = new Bitmap(width, height, PixelFormat.Format32bppArgb);
            using (var g = Graphics.FromImage(result))
            {
                drawer(g, new Rectangle(0, 0, width, height));
            }
            return result;
        }

        private void drawEraserIcon(Graphics g, RectangleF rect)
        {
            var x = rect.X;
            var y = rect.Y;
            var width = rect.Width;
            var height = rect.Height;

            const double upperTop = 0.15;
            const double upperBottom = 0.35;
            const double upperWidth = 0.45;

            const double lowerTop = 0.45;
            const double lowerBottom = 0.85;
            const double lowerWidth = 0.55;

            var ut = (int)Math.Round(y + lowerTop * height);
            var ub = (int)Math.Round(y + lowerBottom * height);
            var ul = (int)Math.Round(x + (1 - lowerWidth) * height / 2);
            var ur = (int)Math.Round(rect.Right - (ul - rect.Left));

            var lt = (int)Math.Round(y + upperTop * height);
            var lb = (int)Math.Round(y + upperBottom * height);
            var ll = (int)Math.Round(x + (1 - upperWidth) * height / 2);
            var lr = (int)Math.Round(rect.Right - (ll - rect.Left));

            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.None;
            g.FillRectangle(Brushes.Black, ul - 1, ut - 1, ur - ul, ub - ut);
            g.FillRectangle(Brushes.Black, ll - 1, lt - 1, lr - ll, lb - lt);

        }

        private void drawInvertSearchIcon(Graphics g, RectangleF rect)
        {
            drawSearchIcon(g, new RectangleF(rect.Right, rect.Y, -rect.Width, rect.Height));
        }

        private void drawSearchIcon(Graphics g, RectangleF rect)
        {
            var x = rect.X;
            var y = rect.Y;
            var width = rect.Width;
            var height = rect.Height;

            const double thk = 0.15;

            const double rectX0 = 0.20;
            const double rectX1 = 0.65;

            const double lineX1 = 0.8;
            const double lineY1 = 0.8;

            const double rectY0 = rectX0;
            const double rectY1 = rectX1;
            const double lineX0 = (rectX0 + rectX1) / 2 + (rectX1 - rectX0) / (2 * 1.41421356237309504880168872421);
            const double lineY0 = lineX0;

            using (var p = new Pen(Color.Black, (float)((thk / 2) * (Math.Abs(width) + Math.Abs(height)))))
            {
                g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;

                g.DrawEllipse(p, new RectangleF((float)(x + rectX0 * width) - 1, (float)(y + rectY0 * height) - 1, (float)((rectX1 - rectX0) * width), (float)((rectY1 - rectY0) * height)));

                p.EndCap = System.Drawing.Drawing2D.LineCap.Round;
                g.DrawLine(p, new PointF((float)(x + lineX0 * width) - 1, (float)(y + lineY0 * height) - 1), new PointF((float)(x + lineX1 * width) - 1, (float)(y + lineY1 * height) - 1));
            }
        }

        private void drawClipboardIcon(Graphics g, RectangleF rect)
        {
            var x = rect.X;
            var y = rect.Y;
            var width = rect.Width;
            var height = rect.Height;

            const double thk = 0.1;
            const double thk2 = thk / 2;

            const double rectX = 0.20;
            const double rectY = 0.10;
            const double strnX = 0.35;
            const double strnY = 0.32;

            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;

            using (var p = new Pen(Color.Black, (float)((thk / 2) * (Math.Abs(width) + Math.Abs(height)))))
            {
                g.DrawRectangle(p, (float)(x + rectX * width) - 1, (float)(y + rectY * height) - 1, (float)((1 - 2 * rectX) * width), (float)((1 - 2 * rectY) * height));
            }

            using (var p = new Pen(Color.Black, (float)((thk2 / 2) * (Math.Abs(width) + Math.Abs(height)))))
            {
                var px1 = (float)(x + strnX * width) - 1;
                var px2 = (float)(x + (1 - strnX) * width) - 1;
                float py;

                py = (float)(y + strnY * height) - 1;
                g.DrawLine(p, new PointF(px1, py), new PointF(px2, py));

                py = (float)(y + 0.5 * height) - 1;
                g.DrawLine(p, new PointF(px1, py), new PointF(px2, py));

                py = (float)(y + (1 - strnY) * height) - 1;
                g.DrawLine(p, new PointF(px1, py), new PointF(px2, py));
            }
        }

        private void editSmartFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectedRows = dgvDirectoryList.SelectedRows;
            if (selectedRows.Count != 1) return;
            var path = (selectedRows[0].Cells[tbcDirectoryName.Index].Value as ColoredBookmark)?.SimpleBookmark?.Location;
            if (path == null) return;
            openSmartFolderSettingForm(path); // AllowFullpower 込み
        }

        private void cutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            cutSelection(ModifierKeys);
        }

        private void copyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            copySelection(ModifierKeys);
        }

        private void pasteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var targetChildFolder = null as string;
            while (InRealDirectory)
            {
                var selectedIndex = tvCatalog.SelectedIndex; if (selectedIndex < 0) break;
                var zpa = ZipPathArray; if (zpa == null) break;
                var count = zpa.Length; if (count <= selectedIndex) break;
                var zna = ZipNameArray; if (zna == null || zna.Length != count) break;
                var name = zna[selectedIndex]; if (name == null || !name.Any() || name.Last() != Path.DirectorySeparatorChar) break;
                targetChildFolder = zpa[selectedIndex];
                if (targetChildFolder == "") targetChildFolder = null;
                break;
            }

            if (targetChildFolder == null)
            {
                pasteToCurrentLocation();
            }
            else
            {
                pasteToTarget(targetChildFolder);
            }
        }

        private void selectionToClipboard(DragDropEffects effects, Keys modifierKeys)//, out string[] selectedPaths)
        {
            if (InMovie)
            {
                selectedMovieCaptchaToClipboard();
            }
            else
            {
                selectedItemsToClipboard(effects, modifierKeys);
            }
        }

        private void selectedMovieCaptchaToClipboard()
        {
            if (CreatingZipPathArray || !InMovie) return;

            string[] selectedPaths;
            bool[] isDirs;
            getSelectedPathArray(-1, out selectedPaths, out isDirs);
            if (selectedPaths == null || selectedPaths.Length != 1)
            {
                return;
            }
            var longPath = selectedPaths[0];
            try
            {
                var altPos = longPath.IndexOf(Path.AltDirectorySeparatorChar);
                if (altPos < 0 || altPos >= longPath.Length - 1) throw new FormatException();
                var entity = longPath.Substring(0, altPos);
                var posString = longPath.Substring(altPos + 1);
                var pos = TimeSpan.Parse(posString);

                if (!MovieThumbnailLoader.ffmpegExists())
                {
                    RecentFfmpegExists = false;
                    throw new FileNotFoundException(null, MovieThumbnailLoader.ffmpegPath);
                }
                else
                {
                    RecentFfmpegExists = true;
                }

                if (!File.Exists(entity))
                {
                    throw new FileNotFoundException(null, entity);
                }
                MovieInfo dummy = null;
                using (var bmp = MovieThumbnailLoader.GetThumbnail(entity, sizeProviderForOriginalSizeAsPossible,
                    t => pos, backgroundWorker: null, timeOut: TimeSpan.FromSeconds(10), movieInfo: ref dummy))
                {
                    Clipboard.SetImage(bmp);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }


        }

        private void selectedItemsToClipboard(DragDropEffects effects, Keys modifierKeys)//, out string[] selectedPaths)
        {
            if (CreatingZipPathArray) return;

            string[] selectedPaths;
            if (!InDirectoryVirtualDirectoryOrSmartDirectory && !InArchive)
            {
                selectedPaths = null;
                return;
            }
            bool[] isDirs;
            getSelectedPathArray(-1, out selectedPaths, out isDirs);
            if (selectedPaths == null || selectedPaths.Length <= 0)
            {
                selectedPaths = null;
                return;
            }

            try
            {
                //selectedPaths = selectedPaths.Where(path => !path.Contains(Path.AltDirectorySeparatorChar)).ToArray();

                if (selectedPaths.Length <= 0)
                {
                    selectedPaths = null;
                    return;
                }

                //var data = new DataObject(DataFormats.FileDrop, selectedPaths);

                var data = GetSelectedDataObject(forClipboard: true);
                if (data == null) return;

                if (!InArchive)
                {
                    for (var i = 0; i < selectedPaths.Length; i++)
                    {
                        var path = selectedPaths[i];
                        var isDir = isDirs[i];
                        if (isDir && !Directory.Exists(path) || !isDir && !File.Exists(path))
                        {
                            throw new FileNotFoundException(null, selectedPaths[i]);
                        }
                    }
                }

                //DragDropEffects.Moveを設定する（DragDropEffects.Move は 2）
                byte[] bs = new byte[] { (byte)effects, 0, 0, 0 };
                System.IO.MemoryStream ms = new System.IO.MemoryStream(bs);
                data.SetData("Preferred DropEffect", ms);

                string strPath;
                if ((modifierKeys & Keys.Shift) == Keys.Shift)
                {
                    // 一つの場合だけ例外的に処理
                    //strPath = selectedPaths.Length == 1 ? $"\"{selectedPaths[0].Replace("\\", "\\\\")}\"" :
                    //    string.Join("", from path in selectedPaths select $"\"{path.Replace("\\", "\\\\")}\",\n");

                    // 一貫性重視
                    strPath = string.Join("\n", from path in selectedPaths select $"\"{path.Replace(@"\", @"\\")}\"");
                }
                else
                {
                    // 一つの場合だけ例外的に処理
                    //strPath = selectedPaths.Length == 1 ? selectedPaths[0] : string.Join("\n", selectedPaths) + "\n";

                    // 一貫性重視
                    strPath = string.Join("\n", selectedPaths);
                }

                data.SetData(DataFormats.UnicodeText, strPath);

                //クリップボードに切り取る
                ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose = data is DataObjectEx;

                if (effects == DragDropEffects.Move && !ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose && data.GetDataPresent(DataFormats.FileDrop))
                {
                    var files = data.GetData(DataFormats.FileDrop, autoConvert: false) as string[];
                    if (files != null)
                    {
                        ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose = true;
                        StopLookAheadProcess();
                        OpendByExternalApplication_Dictionary[GetSelectedDataObject_ClipboardGuid] = new HashSet<string>(from path in files where !string.IsNullOrEmpty(path) select path.ToLower());
                        PrepareLookAheadProcess();
                    }
                }

                Clipboard.SetDataObject(data);
                ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose = false;
            }
            catch (Exception e)
            {
                selectedPaths = null;
                MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void cutSelection(Keys modifierKeys)
        {
            if (!InRealDirectory) return;
            //string[] selectedPaths;
            ClipboardViewer_ClipboardHandler_StopRedrawCutFile = true;
            selectionToClipboard(DragDropEffects.Move, modifierKeys);//, out selectedPaths);
            setCutFiles(); // 明示的に
            tvCatalog.Refresh();
            dgvFileList.Refresh();

            ClipboardViewer_ClipboardHandler_StopRedrawCutFile = false;
        }

        private void clearCutItemInClipBoard()
        {
            if (cutFilePathSetInLower == null)
            {
                setCutFiles();
            }
            if (cutFilePathSetInLower != null)
            {
                ClipboardViewer_ClipboardHandler_StopRedrawCutFile = true;
                try
                {
                    Clipboard.Clear();
                }
                catch
                {
                }
                ClipboardViewer_ClipboardHandler_StopRedrawCutFile = false;
            }
            setCutFiles(null);
            tvCatalog.Refresh();
            dgvFileList.Refresh();
        }

        private bool ClipboardViewer_ClipboardHandler_StopRedrawCutFile = false;
        private bool ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose = false;
        private void ClipboardViewer_ClipboardHandler(object sender, ClipboardEventArgs ev)
        {
            if (!ClipboardViewer_ClipboardHandler_StopRedrawCutFile)
            {
                var preNull = cutFilePathSetInLower == null;

                setCutFiles(); // 明示的に


                //var data = setCutFiles(); // 明示的に
                /*
                if (data != null)
                {
                    try
                    {
                        // 貼り付け操作で使う Clipboard.GetText はどちらも取得する
                        if (data.GetDataPresent(DataFormats.UnicodeText) || data.GetDataPresent(DataFormats.Text))
                        {
                            cbFilter_PasteMode = true;
                        }
                    }
                    catch { }
                }
                */

                if (!preNull || cutFilePathSetInLower != null)
                {
                    tvCatalog.Refresh();
                    dgvFileList.Refresh();
                }
            }

            if (!ClipboardViewer_ClipboardHandler_StopLoaderForClipboardDispose)
            {
                packedImageLoaderForClipboard_Dispose();

                OpendByExternalApplication_Dictionary.Remove(GetSelectedDataObject_ClipboardGuid);
            }
        }


        private HashSet<string> cutFilePathSetInLower = null;
        private void setCutFiles()
        {
            //IDataObject data = null;
            try
            {
                var data = Clipboard.GetDataObject();

                if (!data.GetDataPresent(DataFormats.FileDrop) || GetPreferredDropEffect(data) != DragDropEffects.Move)
                {
                    setCutFiles(null);
                }
                else
                {
                    setCutFiles(data.GetData(DataFormats.FileDrop) as string[]);
                }
            }
            catch
            {
                setCutFiles(null);
            }
            //return data;
        }
        private void setCutFiles(string[] cutFiles)
        {
            if (cutFiles != null && cutFiles.Length > 0)
            {
                cutFilePathSetInLower = new HashSet<string>(from path in cutFiles where !string.IsNullOrEmpty(path) select path.ToLower());
                if (cutFilePathSetInLower.Count == 0) cutFilePathSetInLower = null;
            }
            else
            {
                cutFilePathSetInLower = null;
            }
        }

        private void copySelection(Keys modifierKeys)
        {
            //string[] dummy;
            selectionToClipboard(DragDropEffects.Copy | DragDropEffects.Link, modifierKeys);//, out dummy);
            /*
            string[] selectedPaths;
            bool[] isDirs;
            getSelectedPathArray(out selectedPaths, out isDirs);
            if (selectedPaths == null || selectedPaths.Length <= 0) return;

            try
            {
                for (var i = 0; i < selectedPaths.Length; i++)
                {
                    var isDir = isDirs[i];
                    if (isDir && !Directory.Exists(selectedPaths[i]) || !isDir && !File.Exists(selectedPaths[i]))
                    {
                        throw new FileNotFoundException(null, selectedPaths[i]);
                    }
                }

                System.Collections.Specialized.StringCollection files =
                    new System.Collections.Specialized.StringCollection();

                files.AddRange(selectedPaths);
                Clipboard.SetFileDropList(files);
            }
            catch (Exception e)
            {
                MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            */
        }

        private void pasteToCurrentLocation()
        {
            if (CreatingZipPathArray || !(InRealDirectory || InVirtualDirectory) || string.IsNullOrEmpty(currentLocation)) return; // 無駄な GetDataObject をしないように
            try
            {
                pasteToCurrentLocation(Clipboard.GetDataObject(), dragDropEffects: null);
            }
            catch { }
            clearCutItemInClipBoard();
        }

        /// <summary>
        /// いつでも実行可能、ただし currentLocation を指定してもペースト後にそこまでスクロールしない
        /// </summary>
        /// <param name="target"></param>
        private void pasteToTarget(string target)
        {
            // 不要
            //if (CreatingZipPathArray || !(InRealDirectory || InVirtualDirectory) || string.IsNullOrEmpty(currentLocation)) return; // 無駄な GetDataObject をしないように
            try
            {
                pasteToTarget(this, target, Clipboard.GetDataObject(), dragDropEffects: null);
            }
            catch { }
            clearCutItemInClipBoard();
        }

        private void newVirtualFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var temp = AllowFullpower;
            try
            {
                AllowFullpower = false;
                string sorPath;
                addToNewListSaveFileDialog.FileName = "";
                if (addToNewListSaveFileDialog.ShowDialog(this) == DialogResult.OK)
                {
                    sorPath = addToNewListSaveFileDialog.FileName;
                    if (File.Exists(sorPath)) File.Delete(sorPath);
                }
                else return;
                if (sorPath != null)
                {
                    VirtualFolder.AddBookmarkData(sorPath, new string[0], new int[0]);
                    MoveLocation(ApplicationProviderUser.OpenFileDialog, sorPath);
                }
            }
            catch (Exception error)
            {
#if DEBUG
                MessageBox.Show(this, error.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
            }
            finally
            {
                AllowFullpower = temp;
            }
        }

        private void cmsRightClickOnBackground_Opening(object sender, CancelEventArgs e)
        {
            msSortBy.Stop = msFilter.Stop = msCatalog.Stop = msFileList.Stop = true;
            AllowFullpower = false;
        }

        private void cmsRightClickOnBackground_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            msSortBy.Stop = msFilter.Stop = msCatalog.Stop = msFileList.Stop = false;
            AllowFullpower = true;
        }

        /// <summary>
        /// 名前の末尾に Path.DirectorySeparateChar があるかどうかでフォルダかどうかを判定
        /// ffmpeg の有無が作成されるファイルの表示に影響を与える使い方をする場合修正が必要
        /// </summary>
        /// <param name="names"></param>
        private void createNewToCurrentLocation(params string[] names)
        {
            createNewToCurrentLocation(names as IEnumerable<string>);
        }

        /// <summary>
        /// 名前の末尾に Path.DirectorySeparateChar があるかどうかでフォルダかどうかを判定
        /// 単一のフォルダー作成以外に使う場合は表示メッセージの修正が必要
        /// ffmpeg の有無が作成されるファイルの表示に影響を与える使い方をする場合はロジックの修正が必要
        /// </summary>
        /// <param name="names"></param>
        private void createNewToCurrentLocation(IEnumerable<string> names)
        {
            if (CreatingZipPathArray || !InRealDirectory || names == null || !names.Any()) return;
            var cl = currentLocation;
            if (string.IsNullOrEmpty(cl)) return;

            try
            {
                if (cl.Last() == ':') cl += Path.DirectorySeparatorChar;

                //using (var fo = new MsdnMag.FileOperation(callbackSink: null, owner: this))
                {
                    int dummy;
                    /*
                    var archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
                    var imageSkip = !imageFilesToolStripMenuItem.Checked;
                    var videoSkip = !videoFilesToolStripMenuItem.Checked;
                    var otherSkip = !otherFilesToolStripMenuItem.Checked;
                    */
                    var archiveSkip = ArchiveLoadLevel == ItemLoadLevel.Ignore;
                    var imageSkip = ImageLoadLevel == ItemLoadLevel.Ignore;
                    var videoSkip = VideoLoadLevel == ItemLoadLevel.Ignore;
                    var otherSkip = OtherLoadLevel == ItemLoadLevel.Ignore;

                    var invisibleExists = false;

                    //var moveOrCopy = move ? (Action<string, string, string>)fo.MoveItem : fo.CopyItem;
                    var creates = new List<string>();
                    var isDirs = new List<bool>();
                    foreach (var name in names)
                    {
                        if (string.IsNullOrEmpty(name)) throw new ArgumentException(nameof(name));
                        var isDir = name.Last() == Path.DirectorySeparatorChar;
                        var plain = isDir ? name.Substring(0, name.Length - 1) : name;

                        var path = Path.Combine(cl, plain);
                        if (File.Exists(path) || Directory.Exists(path))
                        {
                            var ext = Path.GetExtension(path);
                            var baseName = Path.GetFileNameWithoutExtension(plain);
                            var digit = 2;
                            do
                            {
                                path = Path.Combine(cl, baseName + " (" + digit++ + ")" + ext);
                            }
                            while (File.Exists(path) || Directory.Exists(path));
                        }

                        if (!invisibleExists)
                        {
                            if (isDir)
                            {
                                if (!IsDisplay(SubfolderMode)) invisibleExists = true;
                            }
                            else
                            {
                                invisibleExists = ShouldBeSkipForFile(out dummy, path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpegExists: false); // ffmpeg の存在が結果に影響を与えるデータは扱わない
                            }
                        }

                        creates.Add(path);
                        isDirs.Add(isDir);
                    }

                    // 先にパスでチェックするためここで行う
                    if (invisibleExists && MessageBox.Show(this, Message.NewFolderCanBeCreatedButSomeOfThemWillNotBeDisplayedBecauseOfViewSetting,
                            Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) != DialogResult.OK)
                    {
                        return;
                    }

                    // 追加されたら選択する
                    addToUserAddFileList(creates);

                    for (var i = 0; i < creates.Count; i++)
                    {
                        if (isDirs[i])
                        {
                            Directory.CreateDirectory(creates[i]);
                        }
                        else
                        {
                            using (var fs = File.Create(creates[i])) fs?.Close();
                        }
                    }
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void pasteToCurrentLocation(System.Windows.Forms.IDataObject data, DragDropEffects? dragDropEffects = null)
        {
            if (data == null || CreatingZipPathArray || !(InRealDirectory || InVirtualDirectory)) return;
            var startingGuid = loadingGuid;
            var cl = currentLocation;
            if (string.IsNullOrEmpty(cl)) return;

            try
            {
                if (data.GetDataPresent(DataFormats.FileDrop))
                {

                    var files = (string[])data.GetData(DataFormats.FileDrop);
                    if (files.Length <= 0) return;

                    tvCatalog.SelectedIndices = new int[0];

                    if (InRealDirectory)
                    {

                        DragDropEffects dde = dragDropEffects == null ? GetPreferredDropEffect(data) : (DragDropEffects)dragDropEffects;
                        bool move = dde == DragDropEffects.Move; // 他のプログラムとの互換性を考慮し (DragDropEffects.Copy | DragDropEffects.Link) でなくともコピーとみなす

                        using (var fo = new MsdnMag.FileOperation(callbackSink: null, owner: this))
                        {
                            var moveOrCopy = move ? (Action<string, string, string>)fo.MoveItem : fo.CopyItem;
                            var movedFiles = new List<string>();
                            foreach (var file in files)
                            {
                                string name = Path.GetFileName(file);
                                var path = Path.Combine(cl, name);
                                if (!move && file == path)
                                {
                                    if (File.Exists(path) || Directory.Exists(path))
                                    {
                                        var ext = Path.GetExtension(path);
                                        name = Path.GetFileNameWithoutExtension(file) + " - " + Message.Copy + ext;
                                        path = Path.Combine(cl, name);
                                        var digit = 2;
                                        while (File.Exists(path) || Directory.Exists(path))
                                        {
                                            name = Path.GetFileNameWithoutExtension(file) + " - " + Message.Copy + " (" + digit++ + ")" + ext;
                                            path = Path.Combine(cl, name);
                                        }
                                    }
                                }
                                movedFiles.Add(path);

                                moveOrCopy(file, cl, name);
                            }

                            //if (!alertInvisibleItemsOnPaste(movedFiles, checkAttribute: true)) // 誤り

                            // 先にパスでチェックするためここで行う
                            if (!alertInvisibleItemsOnPaste(files, checkPath: true, checkAttribute: true))
                            {
                                return;
                            }

                            addToUserAddFileList(movedFiles);
                            fo.PerformOperations();
                        }

                    }
                    else if (InVirtualDirectory)
                    {
                        if (cl.ToLower().EndsWith(".sor"))
                        {
                            if (!alertInvisibleItemsOnPaste(files, checkPath: true, checkAttribute: true))
                            {
                                return;
                            }

                            // 多くの項目を addOrReloadItem で読み込もうとすると
                            // その分だけ Task がたまりそれが終わるまで画面が更新されない
                            // その場合は単純にリロードを行う
                            var callAddOrReloadItem = files.Length <= Environment.ProcessorCount;
                            if (callAddOrReloadItem) addToUserAddFileList(files);

                            addToList(files, append: true, sorPath: cl, addToBookmark: false);

                            //UpdatePreview();
                            if (callAddOrReloadItem)
                            {
                                foreach (var file in files) addOrReloadItem(file, thumbnailChanged: true, startingGuid: startingGuid);
                            }
                            else
                            {
                                UpdatePreview();
                            }
                        }
                    }
                }
                else
                {
                    if (!InRealDirectory || !data.GetDataPresent(NativeMethods.CFSTR_FILEDESCRIPTORW) || !data.GetDataPresent(NativeMethods.ZIPPLA_FILECONTENTS)) return;
                    //var dataEx = data as DataObjectEx;
                    //if (dataEx == null) return;

                    var ZipPlaPERFORMEDDROPEFFECTExists = data.GetDataPresent(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);

                    try
                    {
                        if (ZipPlaPERFORMEDDROPEFFECTExists)
                        {
                            data.GetData(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);
                        }

                        var descriptorData = data.GetData(NativeMethods.CFSTR_FILEDESCRIPTORW) as Stream;
                        if (descriptorData == null) return;

                        DataObjectEx.FILEDESCRIPTOR[] fileDescriptors;
                        using (descriptorData)
                        {
                            fileDescriptors = DataObjectEx.FILEDESCRIPTOR.FromStreamToArray(descriptorData);
                        }
                        if (fileDescriptors.Length == 0) return;

                        /*
                        var message = Message.DoYouOverwriteFollowing1Items;
                        var existinigs = (from desc in fileDescriptors let path = Path.Combine(cl, desc.cFileName) where File.Exists(path) select path).ToArray();
                        if (!await showshowConfirmationDialogDialogAlways(message, existinigs)) return;
                        */

                        //var ienumFormat = idata.EnumFormatEtc(DATADIR.DATADIR_GET);


                        //var rgelt = new System.Runtime.InteropServices.ComTypes.FORMATETC[1];
                        //if (ienumFormat.Next(fileDescriptors.Length, rgelt, null) != 0) return; // S_OK = 0

                        //const int S_OK = 0;
                        //while (ienumFormat.Next(1, rgelt, null) == S_OK)

                        var dstPaths = new string[fileDescriptors.Length];

                        for (var i = 0; i < fileDescriptors.Length; i++)
                        {
                            var desc = fileDescriptors[i];

                            var name = desc.cFileName;
                            var path = Path.Combine(cl, name);

                            if (File.Exists(path) || Directory.Exists(path))
                            {
                                var baseName = Path.GetFileNameWithoutExtension(name);
                                var ext = Path.GetExtension(name);
                                name = baseName + " - " + Message.Copy + ext;
                                path = Path.Combine(cl, name);
                                var digit = 2;
                                while (File.Exists(path) || Directory.Exists(path))
                                {
                                    name = baseName + " - " + Message.Copy + " (" + digit++ + ")" + ext;
                                    path = Path.Combine(cl, name);
                                }
                            }
                            dstPaths[i] = path;
                        }

                        if (!alertInvisibleItemsOnPaste(dstPaths, checkPath: true, checkAttribute: false))
                        {
                            return;
                        }

                        for (var i = 0; i < fileDescriptors.Length; i++)
                        {
                            var desc = fileDescriptors[i];

                            var path = dstPaths[i];

                            // iStream の read は size が int なので使用しない
                            //using (var content = data.GetData(NativeMethods.CFSTR_FILECONTENTS) as Stream)
                            using (var ms = data.GetData(NativeMethods.ZIPPLA_FILECONTENTS) as Stream)
                            using (var file = new FileStream(path, FileMode.CreateNew))
                            {
                                ms.CopyTo(file);
                            }

                            System.Runtime.InteropServices.ComTypes.FILETIME fileTime;

                            fileTime = desc.ftCreationTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)fileTime.dwLowDateTime);
                                    File.SetCreationTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }

                            fileTime = desc.ftLastAccessTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)fileTime.dwLowDateTime);
                                    File.SetLastAccessTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }

                            fileTime = desc.ftLastWriteTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)fileTime.dwLowDateTime);
                                    File.SetLastWriteTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }
                        }
                    }
                    finally
                    {
                        if (data.GetDataPresent(NativeMethods.CFSTR_FILEDESCRIPTORW))
                        {
                            data.GetData(NativeMethods.CFSTR_FILEDESCRIPTORW);
                        }
                        if (ZipPlaPERFORMEDDROPEFFECTExists)
                        {
                            data.GetData(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);
                        }
                    }


                }
            }
            catch (System.Runtime.InteropServices.COMException) { } // fo がエラーを表示するのでこちらでは不要
            catch (Exception e)
            {
                MessageBox.Show(this, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // bool alertInvisibleItemsOnPaste(IEnumerable<string> dsts, bool checkPath, bool checkAttribute)

        public static void pasteToTarget(CatalogForm owner, string target, System.Windows.Forms.IDataObject data, DragDropEffects? dragDropEffects = null)
        {
            try
            {
                if (target != null && !target.Any() && target.Last() == ':') target += Path.DirectorySeparatorChar;
                if (data.GetDataPresent(DataFormats.FileDrop))
                {

                    var files = (string[])data.GetData(DataFormats.FileDrop);
                    if (files.Length <= 0) return;

                    DragDropEffects dde = dragDropEffects == null ? GetPreferredDropEffect(data) : (DragDropEffects)dragDropEffects;
                    bool move = dde == DragDropEffects.Move; // 他のプログラムとの互換性を考慮し (DragDropEffects.Copy | DragDropEffects.Link) でなくともコピーとみなす

                    using (var fo = new MsdnMag.FileOperation(callbackSink: null, owner: owner))
                    {
                        var moveOrCopy = move ? (Action<string, string, string>)fo.MoveItem : fo.CopyItem;
                        var movedFiles = new List<string>();
                        foreach (var file in files)
                        {
                            string name = Path.GetFileName(file);
                            var path = Path.Combine(target, name);
                            if (!move && file == path)
                            {
                                if (File.Exists(path) || Directory.Exists(path))
                                {
                                    var ext = Path.GetExtension(path);
                                    name = Path.GetFileNameWithoutExtension(file) + " - " + Message.Copy + ext;
                                    path = Path.Combine(target, name);
                                    var digit = 2;
                                    while (File.Exists(path) || Directory.Exists(path))
                                    {
                                        name = Path.GetFileNameWithoutExtension(file) + " - " + Message.Copy + " (" + digit++ + ")" + ext;
                                        path = Path.Combine(target, name);
                                    }
                                }
                            }
                            movedFiles.Add(path);

                            moveOrCopy(file, target, name);
                        }
                        fo.PerformOperations();
                    }
                }
                else
                {
                    if (!data.GetDataPresent(NativeMethods.CFSTR_FILEDESCRIPTORW) || !data.GetDataPresent(NativeMethods.ZIPPLA_FILECONTENTS)) return;

                    var ZipPlaPERFORMEDDROPEFFECTExists = data.GetDataPresent(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);

                    try
                    {
                        if (ZipPlaPERFORMEDDROPEFFECTExists)
                        {
                            data.GetData(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);
                        }

                        var descriptorData = data.GetData(NativeMethods.CFSTR_FILEDESCRIPTORW) as Stream;
                        if (descriptorData == null) return;

                        DataObjectEx.FILEDESCRIPTOR[] fileDescriptors;
                        using (descriptorData)
                        {
                            descriptorData.Seek(0, SeekOrigin.Begin); // ペーストでは元側が行っているため省略しているが通常はこれが必要
                            fileDescriptors = DataObjectEx.FILEDESCRIPTOR.FromStreamToArray(descriptorData);
                        }
                        if (fileDescriptors.Length == 0) return;

                        var dstPaths = new string[fileDescriptors.Length];

                        for (var i = 0; i < fileDescriptors.Length; i++)
                        {
                            var desc = fileDescriptors[i];

                            var name = desc.cFileName;
                            var path = Path.Combine(target, name);

                            if (File.Exists(path) || Directory.Exists(path))
                            {
                                var baseName = Path.GetFileNameWithoutExtension(name);
                                var ext = Path.GetExtension(name);
                                name = baseName + " - " + Message.Copy + ext;
                                path = Path.Combine(target, name);
                                var digit = 2;
                                while (File.Exists(path) || Directory.Exists(path))
                                {
                                    name = baseName + " - " + Message.Copy + " (" + digit++ + ")" + ext;
                                    path = Path.Combine(target, name);
                                }
                            }
                            dstPaths[i] = path;
                        }

                        for (var i = 0; i < fileDescriptors.Length; i++)
                        {
                            var desc = fileDescriptors[i];

                            var path = dstPaths[i];

                            // iStream の read は size が int なので使用しない
                            //using (var content = data.GetData(NativeMethods.CFSTR_FILECONTENTS) as Stream)
                            using (var ms = data.GetData(NativeMethods.ZIPPLA_FILECONTENTS) as Stream)
                            using (var file = new FileStream(path, FileMode.CreateNew))
                            {
                                ms.Seek(0, SeekOrigin.Begin); // ペーストでは元側が行っているため省略しているが通常はこれが必要
                                ms.CopyTo(file);
                            }

                            System.Runtime.InteropServices.ComTypes.FILETIME fileTime;

                            fileTime = desc.ftCreationTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)(uint)fileTime.dwLowDateTime);
                                    File.SetCreationTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }

                            fileTime = desc.ftLastAccessTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)(uint)fileTime.dwLowDateTime);
                                    File.SetLastAccessTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }

                            fileTime = desc.ftLastWriteTime;
                            if (fileTime.dwLowDateTime != 0 || fileTime.dwHighDateTime != 0)
                            {
                                try
                                {
                                    var dateTime = DateTime.FromFileTime(((long)fileTime.dwHighDateTime) << 32 | (long)(uint)fileTime.dwLowDateTime);
                                    File.SetLastWriteTime(path, dateTime);
                                }
                                catch (ArgumentOutOfRangeException)
                                {
                                }
                            }
                        }
                    }
                    finally
                    {
                        if (data.GetDataPresent(NativeMethods.CFSTR_FILEDESCRIPTORW))
                        {
                            data.GetData(NativeMethods.CFSTR_FILEDESCRIPTORW);
                        }
                        if (ZipPlaPERFORMEDDROPEFFECTExists)
                        {
                            data.GetData(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT);
                        }
                    }
                }
            }
            catch (System.Runtime.InteropServices.COMException) { } // fo がエラーを表示するのでこちらでは不要
            catch (Exception e)
            {
                MessageBox.Show(owner, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void setCoverOfParentFolderToThisToolStripMenuItem_Click(object sender, EventArgs e)
        {
            string[] paths;
            bool[] isDirs;
            if (CreatingZipPathArray) return;
            getSelectedPathArray(-1, out paths, out isDirs);
            if (paths == null || paths.Length != 1) return;
            var path = paths[0];
            var isDir = isDirs[0];

            try
            {
                var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
                string parent;
                if (altPos < 0) parent = Path.GetDirectoryName(path);
                else parent = Path.GetDirectoryName(path.Substring(0, altPos));

                //var filePath = Path.Combine(parent, ZipPlaCoverImageFileWithoutExtension + ".jpg");
                var filePath = Path.Combine(parent, ZipPlaCoverImageFileWithExtension);

                //if (File.Exists(filePath)) File.Delete(filePath);


                if (isDir && altPos < 0)
                {
                    var oldFilePath = Path.Combine(path, ZipPlaCoverImageFileWithExtension);
                    File.Copy(oldFilePath, filePath);
                }
                else if (isZipPlaCoverImageType(path) && File.Exists(path) && new FileInfo(path).Length <= 5 * 1024 * 1024) // getFullSizeThumbnail 内での実験の結果より
                {
                    filePath = Path.ChangeExtension(filePath, Path.GetExtension(path));
                    File.Copy(path, filePath);
                }
                else
                {
                    using (var bmp = getFullSizeThumbnail(path)) bmp.Save(filePath);
                }

                File.SetAttributes(filePath, HideZipPlaCoverImageFile ? FileAttributes.Hidden : FileAttributes.Normal);

                if (thumbnailCache == GPSizeThumbnail.AlternateDataStream)
                {
                    GPSizeThumbnail.TryDeleteAlternateDataStream(parent);
                }
                else if (thumbnailCache != null)
                {
                    GPSizeThumbnail.TryDelete(thumbnailCache, parent);
                }

                if (undoBufferIndex > 0)
                {
                    var preloc = undoBuffer[undoBufferIndex - 1].Location + Path.DirectorySeparatorChar;
                    if (path.StartsWith(preloc) &&
                        parent.Length >= preloc.Length && parent.Substring(preloc.Length).ToLower() + Path.DirectorySeparatorChar == undoBuffer[undoBufferIndex - 1].SelectedFileName.ToLower())
                    {
                        btnGoToBack.PerformClick();
                    }
                }
            }
            catch (Exception ex)
            {
#if DEBUG
                MessageBox.Show(this, ex.ToString(), null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#else
                MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
            }
        }

        // 「GDI+ で一般的なエラーが発生しました」の回避
        private Bitmap bitmapRefresh(Bitmap bmp)
        {
            using (bmp) return new Bitmap(bmp);
        }

        private Bitmap getFullSizeThumbnail(string path)
        {
            const int maxWidth = 1280;
            const int maxHeight = 1280;
            var needToRefresh = false;
            Bitmap result = null;
            try
            {
                bool? ffmpegExists = null;
                if (ImageLoader.SupportsImageAtLeastThumbnailReading(path, ref ffmpegExists))
                {
                    ImageInfo info;
                    result = ImageLoader.GetAtLeastThumbnailBitmap(path, new Size(maxWidth, maxHeight), ref ffmpegExists, out info, out needToRefresh);
                }
                else if (PackedImageLoader.Supports(path))
                {
                    result = GetArchiveThumbnail(path, ratio: Math.Sqrt(0.5)); // このオーバーロードは例外を投げる
                }
                else if (MovieThumbnailLoader.Supports(path))
                {
                    MovieInfo dummy = null;
                    needToRefresh = true;
                    result = MovieThumbnailLoader.GetThumbnail(path, sizeProviderForOriginalSizeAsPossible, getpositionProvider(path), backgroundWorker: null, timeOut: TimeSpan.FromSeconds(10), movieInfo: ref dummy);
                }
                else
                {
                    var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
                    if (altPos < 0) throw new NotSupportedException();
                    var moviePath = path.Substring(0, altPos);

                    var innerName = path.Substring(altPos + 1);

                    var pos = TimeSpan.Parse(innerName);

                    MovieInfo dummy = null;
                    needToRefresh = true;
                    result = MovieThumbnailLoader.GetThumbnail(moviePath, sizeProviderForOriginalSizeAsPossible, t => pos, backgroundWorker: null, timeOut: TimeSpan.FromSeconds(10), movieInfo: ref dummy);
                }

                // ファイルサイズ確認
                // これで 4.8 MB 程度
                /*
                result.Dispose();
                result = new Bitmap(1280, 1280, PixelFormat.Format24bppRgb);
                var data = result.LockBits(new Rectangle(0, 0, 1280, 1280), ImageLockMode.WriteOnly, result.PixelFormat);
                var random = new Random();
                unsafe
                {
                    var scan = (byte*)data.Scan0;
                    for (var i = 0; i < 1280 * 1280 * 3; i++) scan[i] = (byte)random.Next(0, 256);
                }
                result.UnlockBits(data);
                */

                if (result.Width > maxWidth || result.Height > maxHeight)
                {
                    using (result)
                    {
                        var zoom = Math.Min((double)maxWidth / result.Width, (double)maxHeight / result.Height);
                        var width = (int)Math.Round(zoom * result.Width);
                        var height = (int)Math.Round(zoom * result.Height);

                        return BitmapResizer.CreateNew(result, width, height);
                        /*
                        var result2 = new Bitmap(width, height);
                        try
                        {
                            using (var g = Graphics.FromImage(result2))
                            {
                                g.DrawImage(result, new Rectangle(0, 0, width, height));
                                return result2;
                            }
                        }
                        catch
                        {
                            result2.Dispose();
                            throw;
                        }
                        */
                    }
                }
                else
                {
                    return needToRefresh ? bitmapRefresh(result) : result;
                }
            }
            catch
            {
                result?.Dispose();
                throw;
            }
        }

        /*
        private void createCacheInADSInNTFSToolStripMenuItem_Click(object sender, EventArgs e)
        {
            //thumbnailCache = !thumbnailCache;
            //createCacheInADSInNTFSToolStripMenuItem.Checked = thumbnailCache;
        }
        */


        private void zeroToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void veryThinToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void thinToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void normalThicknessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void thickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void veryThickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setCurrentMinimumFrameThickness(sender as ToolStripMenuItem);
        }

        private void totallyUniformedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            currentAligning = ThumbViewerAligningMode.TotallyUniformedGrid;
        }

        private void horizontallyUniformedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            currentAligning = ThumbViewerAligningMode.HorizontallyUniformedGrid;
        }

        private void alignedLeftToolStripMenuItem_Click(object sender, EventArgs e)
        {
            currentAligning = ThumbViewerAligningMode.LeftAlignedGrid;
        }

        private void alignedOnCenterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            currentAligning = ThumbViewerAligningMode.CenteredGrid;
        }

        private void defaultLeftToRightToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                currentBindingMode = bindingModeByControl = BindingMode.LeftToRight;
                if (SenseBindingMode()) UpdatePreview();
            }
        }

        private void defaultRightToLeftToolStripMenuItem1_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                currentBindingMode = bindingModeByControl = BindingMode.RightToLeft;
                if (SenseBindingMode()) UpdatePreview();
            }
        }

        private void defaultSinglePageToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                var fromSingle = currentBindingMode == BindingMode.SinglePageWithoutScalingUp;

                currentBindingMode = bindingModeByControl = BindingMode.SinglePage;
                if (!fromSingle && SenseBindingMode()) UpdatePreview();
            }
        }

        private void singlePageWithoutScalingUpToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (!(sender as ToolStripMenuItem).Checked)
            {
                var fromSingle = currentBindingMode == BindingMode.SinglePage;

                currentBindingMode = bindingModeByControl = BindingMode.SinglePageWithoutScalingUp;
                if (!fromSingle && SenseBindingMode()) UpdatePreview();
            }

        }


        private void thumbnailCacheToolStripMenuItem_Click(object sender, EventArgs e)
        {
            thumbnailToolStripMenuItem.DropDown.Close();
            if (CreatingZipPathArray) return;
            AllowFullpower = false;
            using (var thumbnailCacheSettingForm = new ThumbnailCacheSettingForm(thumbnailCache, currentProfileColor))
            {
                thumbnailCacheSettingForm.ShowDialog(this);
                thumbnailCache = thumbnailCacheSettingForm.CacheRoot;
            }
            AllowFullpower = true;
        }

        private void addSeparatorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            addSeparatorToBookmarkList(insertToSelected: true);
        }

        private void blackToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BackColorOfBuiltInViewer = Color.Black;
        }

        private void grayToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BackColorOfBuiltInViewer = Color.Gray;
        }

        private void whiteToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BackColorOfBuiltInViewer = Color.White;
        }

        private void selectColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            using (var cd = new ColorDialog())
            {
                var cc = cd.CustomColors;
                var current = SelectedColorForBackColorOfBuiltInViewer;
                cc[cc.Length - 1] = current.R | current.G << 8 | current.B << 16;
                cd.CustomColors = cc;

                cd.Color = current;
                cd.AllowFullOpen = true;
                cd.SolidColorOnly = false;
                if (cd.ShowDialog(this) == DialogResult.OK)
                {
                    BackColorOfBuiltInViewer = cd.Color;
                }
            }

            AllowFullpower = true;
        }

        private void changeMaxCaptchaCountByUser(int maxCaptcha)
        {
            changeMaxCaptchaCount(maxCaptcha, out var shouldBeUpdate);
            if (shouldBeUpdate) UpdatePreview();
        }

        private void changeMaxCaptchaCount(int maxCaptcha, out bool shouldBeUpdate)
        {
            shouldBeUpdate = false;

            if (MaxCaptchaCountInAVideo == maxCaptcha) return;

            if (!InMovie)
            {
                MaxCaptchaCountInAVideo = maxCaptcha;
                return;
            }

            int currentViewCount;
            var zpa = ZipPathArray;
            if (zpa == null)
            {
                MaxCaptchaCountInAVideo = maxCaptcha;
                return;
            }
            currentViewCount = zpa.Length;

            MovieInfo info;
            try
            {
                info = MovieInfo.FromFile(currentLocation);
            }
            catch
            {
                MaxCaptchaCountInAVideo = maxCaptcha;
                return;
            }

            int nextMovieLengthCount;
            if (maxCaptcha != 0 && currentViewCount >= maxCaptcha)
            {
                nextMovieLengthCount = currentViewCount;
            }
            else
            {
                var duration = info.Duration;
                if (duration == null)
                {
                    MaxCaptchaCountInAVideo = maxCaptcha;
                    return;
                }
                nextMovieLengthCount = (int)duration.TotalSeconds;
                if (nextMovieLengthCount == 0) nextMovieLengthCount = 1;
            }
            int nextBound;
            if (maxCaptcha > 0)
            {
                nextBound = maxCaptcha;
            }
            else
            {
                nextBound = GetThumbnailCountInTvCatalogOrFileList(info);
            }
            var nextViewCount = Math.Min(nextMovieLengthCount, nextBound);

            MaxCaptchaCountInAVideo = maxCaptcha;

            if (currentViewCount != nextViewCount) shouldBeUpdate = true;
        }

        private void fitOnTheScreenToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(0); }
        private void thumb6ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(6); }
        private void thumb12ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(12); }
        private void thumb24ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(24); }
        private void thumb60ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(60); }
        private void thumb120ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(120); }
        private void thumb240ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(240); }
        private void thumb600ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(600); }
        private void thumb1200ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(1200); }
        private void thumb2400ToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(2400); }
        private void everySecondsToolStripMenuItem_Click(object sender, EventArgs e) { changeMaxCaptchaCountByUser(int.MaxValue); }

        private void cmsRightClick_MouseDown(object sender, MouseEventArgs e)
        {
            cmsRightClick.Focus(); // テキストボックスに奪われたフォーカスを取り戻す
        }

        private void alwaysStartInWindowModeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BuiltInViewerInitialFullscreenMode = InitialFullscreenMode.ForceWindow;
        }

        private void startInPreviousFullscreenModeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BuiltInViewerInitialFullscreenMode = InitialFullscreenMode.Default;
        }

        private void openInFullscreenToolStripMenuItem_Click(object sender, EventArgs e)
        {
            BuiltInViewerInitialFullscreenMode = InitialFullscreenMode.ForceFullscreen;
        }

        private void forceFirstPageToBeSingleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            CoverBindingMode = CoverBindingMode == CoverBindingMode.Default ? CoverBindingMode.ForceSingle : CoverBindingMode.Default;
        }

        private void hilightSelectedItemsWhenMouseLeavaesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SelectionHilightMode = SelectionHilightMode == SelectionHighlightMode.None ?
                SelectionHighlightMode.WhenMouseLeaves : SelectionHighlightMode.None;
        }

        private void tinyScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(30, ThumbViewerScrollUnit.AbsolutePixel);
        }

        private void smallScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(60, ThumbViewerScrollUnit.AbsolutePixel);
        }

        private void normalScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(120, ThumbViewerScrollUnit.AbsolutePixel);
        }

        private void largeScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(240, ThumbViewerScrollUnit.AbsolutePixel);
        }

        private void hugeScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(480, ThumbViewerScrollUnit.AbsolutePixel);
        }

        private void _1lineScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(1, ThumbViewerScrollUnit.GridCeiling);
        }

        private void _2lineScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(2, ThumbViewerScrollUnit.GridCeiling);
        }

        private void _3lineScrollToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setMouseWheelScrollAmount(3, ThumbViewerScrollUnit.GridCeiling);
        }

        private void setMouseWheelScrollAmount(int amount, ThumbViewerScrollUnit unit)
        {
            tvCatalog.MouseWheelScrollAmount = amount;
            tvCatalog.MouseWheelScrollUnit = unit;
            tinyScrollToolStripMenuItem.Checked = amount == 30 && unit == ThumbViewerScrollUnit.AbsolutePixel;
            smallScrollToolStripMenuItem.Checked = amount == 60 && unit == ThumbViewerScrollUnit.AbsolutePixel;
            normalScrollToolStripMenuItem.Checked = amount == 120 && unit == ThumbViewerScrollUnit.AbsolutePixel;
            largeScrollToolStripMenuItem.Checked = amount == 240 && unit == ThumbViewerScrollUnit.AbsolutePixel;
            hugeScrollToolStripMenuItem.Checked = amount == 480 && unit == ThumbViewerScrollUnit.AbsolutePixel;
            _1lineScrollToolStripMenuItem.Checked = amount == 1 && unit == ThumbViewerScrollUnit.GridCeiling;
            _2lineScrollToolStripMenuItem.Checked = amount == 2 && unit == ThumbViewerScrollUnit.GridCeiling;
            _3lineScrollToolStripMenuItem.Checked = amount == 3 && unit == ThumbViewerScrollUnit.GridCeiling;
        }

        private void startInPreviousImageFilterSettingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            OpenInPreviousImageFilterSetting = !OpenInPreviousImageFilterSetting;
        }

        private void tinyOnscreenKeyboardToolStripMenuItem_Click(object sender, EventArgs e)
        {
            TinyOnScreenKeyboardVisible = !TinyOnScreenKeyboardVisible;
        }

        private void ignoreArchivesInArchiveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            changeArchivesInArchiveMode(ArchivesInArchiveMode.Ignore);
        }

        private void onlyIfThereIsNoOtherImageToolStripMenuItem_Click(object sender, EventArgs e)
        {
            changeArchivesInArchiveMode(ArchivesInArchiveMode.IfNoOther1Level);
        }

        private void untilFoundToolStripMenuItem_Click(object sender, EventArgs e)
        {
            changeArchivesInArchiveMode(ArchivesInArchiveMode.UntilFound2Level);
        }

        private void alwaysLoadArchivesInArchiveToolStripMenuItem_Click(object sender, EventArgs e)
        {
            changeArchivesInArchiveMode(ArchivesInArchiveMode.Always1Level);
        }

        private void changeArchivesInArchiveMode(ArchivesInArchiveMode mode)
        {
            if (mode != ArchivesInArchiveMode)
            {
                ArchivesInArchiveMode = mode;
                if (InArchive || ArchiveLoadLevel != ItemLoadLevel.Ignore)
                {
                    UpdatePreview();
                }
            }
        }
        
        private void loadWholeArchiveIntoMemoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (ReadOnMemoryMode != ReadOnMemoryMode.None)
            {
                ReadOnMemoryMode = ReadOnMemoryMode.None;
            }
            else if (exceptReadAheadProcessToolStripMenuItem.Checked)
            {
                ReadOnMemoryMode = ReadOnMemoryMode.ExceptLookAhead;
            }
            else
            {
                ReadOnMemoryMode = ReadOnMemoryMode.Always;
            }
        }

        private void exceptReadAheadProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (exceptReadAheadProcessToolStripMenuItem.Checked)
            {
                ReadOnMemoryMode = ReadOnMemoryMode.Always;
            }
            else
            {
                ReadOnMemoryMode = ReadOnMemoryMode.ExceptLookAhead;
            }
        }

        private void standardToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DoubleClickFileOpenMode = DoubleClickMode.Standard;
        }

        private void ignoreMouseMovementToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DoubleClickFileOpenMode = DoubleClickMode.IgnoreMouseMove;
        }

        private void selectAndClickItemToolStripMenuItem_Click(object sender, EventArgs e)
        {
            DoubleClickFileOpenMode = DoubleClickMode.SelectAndClick;
        }

        private void tvCatalog_DragAttempted(object sender, MouseEventArgs e)
        {
            var mk = simplifiedKeyBoard.GetModifierKeys(upHeldKeys: true); // mouseUp が後で呼び出されるが今は使用していない
            if ((e.Button & MouseButtons.Right) == MouseButtons.Right)
            {
                rightClickContextMenuPrepareAndShow(tvCatalog.PointToScreen(e.Location), mk);
            }
        }


        private void dgvFileList_DragAttempted(object sender, MouseEventArgs e)
        {
            var mk = simplifiedKeyBoard.GetModifierKeys(upHeldKeys: true); // mouseUp が後で呼び出されるが今は使用していない
            if ((e.Button & MouseButtons.Right) == MouseButtons.Right)
            {
                rightClickContextMenuPrepareAndShow(dgvFileList.PointToScreen(e.Location), mk);
            }
        }

        private bool dragOuting = false;
        private void tvCatalog_DragReady(object sender, MouseEventArgs e)
        {
            DragReady(sender, e);
        }

        private void DragReady(object sender, MouseEventArgs e)
        {
            try
            {
                DataObject dataObj;
                DragDropEffects effects;
                GetSelectedDataObject(out dataObj, out effects, forClipboard: false);
                if (dataObj != null)
                {
                    dragOuting = true;
                    //string[] files = null;
                    bool isNormalDrag = false;
                    if (!(dataObj is DataObjectEx) && dataObj.GetDataPresent(DataFormats.FileDrop))
                    {
                        //files = dataObj.GetData(DataFormats.FileDrop, false) as string[];
                        isNormalDrag = dataObj.GetData(DataFormats.FileDrop, false) is string[];
                    }
                    //var dragGuid = Guid.Empty;
                    //if (files != null)
                    if (isNormalDrag)
                    {
                        StopLookAheadProcess();

                        // ドラッグは同期的なので不要
                        //dragGuid = new Guid();
                        //OpendByExternalApplication_Dictionary[dragGuid] = files;
                    }

                    (sender as Control).DoDragDrop(dataObj, effects);

                    //if (files != null)
                    if (isNormalDrag)
                    {
                        PrepareLookAheadProcess();
                    }
                    /*
                    if (dragGuid != Guid.Empty)
                    {
                        OpendByExternalApplication_Dictionary.Remove(dragGuid);
                    }*/

                    dragOuting = false;
                }
                else
                {
                    dragOuting = true;
                    (sender as Control).DoDragDrop(new string[0], DragDropEffects.None);
                    dragOuting = false;
                }
            }
            catch
            {
            }
        }

        private DataObject GetSelectedDataObject(bool forClipboard)
        {
            DataObject result;
            DragDropEffects dummy;
            GetSelectedDataObject(out result, out dummy, forClipboard);
            return result;
        }

        private PackedImageLoaderWithEntries packedImageLoaderForClipboard;
        private readonly object packedImageLoaderForClipboardLocker = new object();

        private void packedImageLoaderForClipboard_Dispose()
        {
            lock (packedImageLoaderForClipboardLocker)
            {
                packedImageLoaderForClipboard?.Dispose();
                packedImageLoaderForClipboard = null;
            }
        }

        readonly Guid GetSelectedDataObject_ClipboardGuid = new Guid();
        private void GetSelectedDataObject(out DataObject dataObject, out DragDropEffects effects, bool forClipboard)
        {
            dataObject = null;
            effects = DragDropEffects.None;
            PackedImageLoaderWithEntries pil;
            string archivePath = null;
            if (InDirectoryVirtualDirectoryOrSmartDirectory)
            {
                pil = null;
            }
            else if (InArchive)
            {
                pil = loadingPackedImageLoader;
                if (pil == null) return;
                archivePath = currentLocation;
                if (archivePath == null || !PackedImageLoader.Supports(archivePath)) return;
            }
            else return;
            if (CreatingZipPathArray) return;
            var indices = tvCatalog.SelectedIndices;
            if (indices == null || indices.Length == 0) return;

            if (pil == null)
            {
                var paths = ZipPathArray;
                if (paths == null) return;
                var files = new string[indices.Length];
                for (var i = 0; i < indices.Length; i++)
                {
                    var index = indices[i];
                    if (index < 0 || index >= paths.Length) return;
                    var file = paths[index];
                    if (file.Contains(Path.AltDirectorySeparatorChar)) return;
                    files[i] = file;
                }
                dataObject = new DataObject(DataFormats.FileDrop, files);

                effects = DragDropEffects.All | DragDropEffects.Link;
                return;
            }
            else
            {
                DataObjectEx.SelectedItem[] SelectedItems = new DataObjectEx.SelectedItem[indices.Length];
                var entries = pil.Entries;
                object locker;
                if (forClipboard)
                {
                    locker = packedImageLoaderForClipboardLocker;
                    lock (locker)
                    {
                        packedImageLoaderForClipboard?.Dispose();
                        packedImageLoaderForClipboard = null;
                        var pureLoader = new PackedImageLoader(archivePath, packedImageLoaderLeftHierarchies, packedImageLoaderSearchMode);
                        try
                        {
                            packedImageLoaderForClipboard = new PackedImageLoaderWithEntries(pureLoader, needToExecOnTask: true);
                        }
                        catch
                        {
                            pureLoader.Dispose();
                            return;
                        }
                    }
                    var entries2 = pil.Entries;
                    var diff = false;
                    if (entries.Length != entries2.Length) diff = true;
                    if (!diff)
                    {
                        for (var i = 0; i < entries.Length; i++)
                        {
                            var e1 = entries[i];
                            var e2 = entries2[i];
                            if (e1.Path != e2.Path)
                            {
                                diff = true;
                                break;
                            }
                        }
                    }
                    if (diff)
                    {
                        lock (locker)
                        {
                            packedImageLoaderForClipboard.Dispose();
                            packedImageLoaderForClipboard = null;
                        }
                        return;
                    }
                    pil = packedImageLoaderForClipboard;
                }
                else
                {
                    locker = loadingPackedImageLoaderLocker;
                }
                var pil0 = pil.PackedImageLoader;
                var now = default(DateTime);
                for (Int32 ItemCount = 0; ItemCount < SelectedItems.Length; ItemCount++)
                {
                    var index = indices[ItemCount];
                    if (index >= entries.Length)
                    {
                        if (forClipboard)
                        {
                            lock (locker)
                            {
                                packedImageLoaderForClipboard.Dispose();
                                packedImageLoaderForClipboard = null;
                            }
                        }
                        return;
                    }
                    var entry = entries[index];

                    // TODO: Get virtual file name
                    SelectedItems[ItemCount].FileName = Path.GetFileName(entry.Path);
                    // TODO: Get virtual file date
                    if (entry.LastWriteTime != DateTime.MinValue)
                    {
                        SelectedItems[ItemCount].WriteTime = entry.LastWriteTime;
                    }
                    else
                    {
                        if (now == default(DateTime)) now = DateTime.Now;
                        SelectedItems[ItemCount].WriteTime = now;
                    }
                    // TODO: Get virtual file size
                    SelectedItems[ItemCount].FileSize = entry.Size;
                }

                var GetFileContentsResults = new MemoryStream[SelectedItems.Length];

                DataObjectEx dataObjectEx = new DataObjectEx(SelectedItems);
                var RecalcItemsCalled = false;
                dataObjectEx.RecalcItems = selectedItems =>
                {
                    if (RecalcItemsCalled) return;
                    RecalcItemsCalled = true;

                    var baseLoader = forClipboard ? packedImageLoaderForClipboard : loadingPackedImageLoader;
                    lock (locker)
                    {
                        if (baseLoader == pil)
                        {
                            string digits = null;
                            for (var i = 0; i < selectedItems.Length; i++)
                            {
                                var item = selectedItems[i];
                                if (item.FileSize < 0)
                                {
                                    var entry = entries[indices[i]];
                                    var result0 = pil0.GetStream(entry, out var extension, callback: true);
                                    MemoryStream r = null;
                                    if (digits == null)
                                    {
                                        digits = "0";
                                        var count = entries.Length;
                                        while (count >= 10)
                                        {
                                            digits += "0";
                                            count /= 10;
                                        }
                                    }
                                    try
                                    {
                                        r = ConvertToMemoryStream(result0);
                                        result0 = null;
                                        //string extension;
                                        //r = GetImageType(r, out extension);
                                        item.FileName = digits.Substring(item.FileName.Length) + item.FileName + extension;
                                        item.FileSize = r.Length;
                                        selectedItems[i] = item;
                                        GetFileContentsResults[i] = r;
                                    }
                                    catch
                                    {
                                        result0?.Dispose();
                                        r?.Dispose();
                                        for (var j = 0; j < GetFileContentsResults.Length; j++)
                                        {
                                            var result = GetFileContentsResults[j];
                                            if (result != null)
                                            {
                                                result.Dispose();
                                                GetFileContentsResults[j] = null;
                                            }
                                            else break;
                                        }
                                        return;
                                    }
                                }
                            }
                        }
                    }
                };
                dataObjectEx.GetFileContents = (item, itemCount) =>
                {
                    var result0 = GetFileContentsResults[itemCount];
                    if (result0 != null)
                    {
                        GetFileContentsResults[itemCount] = null;
                        return result0;
                    }
                    else
                    {
                        try
                        {
                            var entry = entries[indices[itemCount]];
                            var baseLoader = forClipboard ? packedImageLoaderForClipboard : loadingPackedImageLoader;
                            lock (locker)
                            {
                                if (baseLoader == pil)
                                {
                                    var stream = pil0.GetStream(entry, out var dummy, callback: true);
                                    try
                                    {
                                        return ConvertToMemoryStream(stream);
                                    }
                                    catch
                                    {
                                        stream.Dispose();
                                        throw;
                                    }
                                }
                                else
                                {
                                    // 例外のスローでコピーをキャンセル
                                    /*
                                    Task.Run(() =>
                                    {
                                        MessageBox.Show(
                                            Message.ToCopyAndPasteItemInCompressedFileKeepItOpenUntilPastingIsCompleted,
                                            null, MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1,
                                            MessageBoxOptions.DefaultDesktopOnly);
                                    });
                                    */
                                    throw new Exception();
                                }
                            }
                        }
                        catch
                        {
                            for (var j = 0; j < GetFileContentsResults.Length; j++)
                            {
                                var result = GetFileContentsResults[j];
                                if (result != null)
                                {
                                    result.Dispose();
                                    GetFileContentsResults[j] = null;
                                }
                            }
                            throw;
                        }
                    }
                };
                dataObjectEx.SetData(NativeMethods.CFSTR_FILEDESCRIPTORW, null);
                dataObjectEx.SetData(NativeMethods.CFSTR_FILECONTENTS, null);
                dataObjectEx.SetData(NativeMethods.ZIPPLA_FILECONTENTS, null);
                dataObjectEx.SetData(NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT, null);
                dataObjectEx.SetData(NativeMethods.CFSTR_PERFORMEDDROPEFFECT, null);
                dataObject = dataObjectEx;
                effects = DragDropEffects.Copy;
                return;
            }
        }

        public static MemoryStream ConvertToMemoryStream(Stream stream)
        {
            var result = stream as MemoryStream;
            if (result != null) return result;
            result = new MemoryStream();
            try
            {
                stream.CopyTo(result);
            }
            catch
            {
                result.Dispose();
                throw;
            }
            stream.Dispose();
            return result;
        }

        private void dgvFileList_DragReady(object sender, MouseEventArgs e)
        {
            DragReady(sender, e);
        }

        private void pasteOnBackGroundToolStripMenuItem_Click(object sender, EventArgs e)
        {
            pasteToCurrentLocation();
        }

        private void cbSortBy_KeyDown(object sender, KeyEventArgs e)
        {
            // FocusIfRightness が使われており、なおかつコピーなどの操作が意味を持たないので
            var mk = ModifierKeys;
            if (commonKeyAction(e, mk))
            {
                return;
            }
            /*
            if (e.KeyCode == Keys.Delete)
            {
                //deleteonlyForListFileToolStripMenuItem_Click(sender, e);
                //deleteSelectedItems(mk);
                deleteKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.X)
            {
                //cutSelection(mk);
                CutKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.C)
            {
                //copySelection(mk);
                CopyKeyAction(mk);
            }
            else if (e.Control && e.KeyCode == Keys.V)
            {
                //pasteToCurrentLocation();
                PasteKeyAction(mk);
            }
            */
        }

        private void clearFilterWhenMovingLocationToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (FilterRemovingMode == FilterRemovingMode.WhenMovingLocation)
                FilterRemovingMode = FilterRemovingMode.Never;
            else
                FilterRemovingMode = FilterRemovingMode.WhenMovingLocation;
        }

        private void fromTheLongestNameToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.Full, refresh: true);
        }

        private void automaticlessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.Automatic1, refresh: true);
        }

        private void automaticgreaterToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.Automatic2, refresh: true);
        }

        private void NumOfLineOfName1toolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.One, refresh: true);
        }

        private void NumOfLineOfName2toolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.Two, refresh: true);
        }

        private void NumOfLineOfName3toolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetNumberOfLinesOfName(NumberOfLinesOfName.Three, refresh: true);
        }

        private void noneFolderArrangeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetFolderSortMode(FolderSortMode.None, reSort: true);
        }

        private void displayFirstToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetFolderSortMode(FolderSortMode.Ahead, reSort: true);
        }

        private void displayLastToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetFolderSortMode(FolderSortMode.Behind, reSort: true);
        }

        private void fitToDirectionOfSortToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SetFolderSortMode(FolderSortMode.FitToDirectionOfSort, reSort: true);
        }

        /*
        private Rectangle? RestoreBounds_ForceValue = null;
        private new Rectangle RestoreBounds
        {
            get => RestoreBounds_ForceValue ?? base.RestoreBounds;
        }

        private Rectangle? CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = null;
        private void CatalogForm_LocationChanged(object sender, EventArgs e)
        {
            
            var windowState = WindowState;
            if (windowState == FormWindowState.Maximized)
            {
                var restoreBounds = base.RestoreBounds;
                var workingArea = Bounds;
                RestoreBounds_ForceValue = workingArea.Contains(restoreBounds) ? null as Rectangle? : ViewerForm.Pack(restoreBounds, workingArea);
                CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = null;
            }
            else if (RestoreBounds_ForceValue is Rectangle restoreBounds)
            {
                if (windowState == FormWindowState.Normal)
                {
                    var bounds = Bounds;
                    if (bounds == base.RestoreBounds)
                    {
                        RestoreBounds_ForceValue = null;
                        var newBounds = CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds ?? restoreBounds;
                        CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = null;
                        if (bounds != newBounds)
                        {
                            Task.Run(() =>
                            {
                                try
                                {
                                    Invoke(((MethodInvoker)(() =>
                                    {
                                        Bounds = newBounds;
                                    })));
                                }
                                catch (ObjectDisposedException) { }
                            });
                        }
                    }
                    else
                    {
                        CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = bounds;
                    }
                }
                else
                {
                    CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = null;
                }
            }
            else
            {
                CatalogForm_LocationChanged_RectangleBeforeMovedByBaseRestoreBounds = null;
            }
        }
    */
        

        private void loadLastViewedPageFromHistoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            LoadLastViewedPageFromHistory = !LoadLastViewedPageFromHistory;
            SetFileListPageHeaderWidth();
            if (ArchiveLoadLevel != ItemLoadLevel.Ignore || IsDisplay(SubfolderMode))
            {
                UpdatePreview();
            }
        }

        private void allowReadaheadProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowReadAheadProcess = !AllowReadAheadProcess;
        }

        private void standardRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RightClickContextMenu = CatalogFormConetxtMenu.ZipPla;
        }

        private void standardMiddleclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MiddleClickContextMenu = CatalogFormConetxtMenu.ZipPla;
        }

        private void standardCtrlRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ControlRightClickContextMenu = CatalogFormConetxtMenu.ZipPla;
        }

        private void OnlyTagRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RightClickContextMenu = CatalogFormConetxtMenu.Tag;
        }

        private void OnlyTagMiddleclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MiddleClickContextMenu = CatalogFormConetxtMenu.Tag;
        }

        private void onlyTagCtrlRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ControlRightClickContextMenu = CatalogFormConetxtMenu.Tag;
        }

        private void explorerRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            RightClickContextMenu = CatalogFormConetxtMenu.Explorer;
        }

        private void explorerMiddleclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            MiddleClickContextMenu = CatalogFormConetxtMenu.Explorer;
        }

        private void explorerCtrlRightclickToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ControlRightClickContextMenu = CatalogFormConetxtMenu.Explorer;
        }

        private void alwaysAutomaticallyHideUIToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AlwaysHideUI = !AlwaysHideUI;
        }

        private void sortFilesWithTheSameOrderAsThumbnailWindowToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SortSyncMode = SortSyncMode == SortSyncMode.None ? SortSyncMode.Directory : SortSyncMode.None;
        }

        private void noneItemSelectionFeedbackToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ItemSelectionFeedback = ItemSelectionFeedback.None;
        }

        private void inAppropriateCasesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ItemSelectionFeedback = ItemSelectionFeedback.IfSortMayBeSame;
        }

        private void alwaysItemSelectionFeedbackToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ItemSelectionFeedback = ItemSelectionFeedback.Always;
        }

        private void tvCatalog_Paint(object sender, PaintEventArgs e)
        {
            if (showStartHelpMessage && tvCatalog.Visible)
            {
                drawInitialMessage(e, tvCatalog.ClientRectangle, tvCatalog.BackColor);
            }
        }

        Font drawInitialMessageFont = null;
        private Font GetDrawInitialMessageFont()
        {
            if (drawInitialMessageFont == null)
            {
                drawInitialMessageFont = new Font(DefaultFont.FontFamily, DefaultFont.SizeInPoints * 1.7f);
            }
            return drawInitialMessageFont;
        }

        private void drawInitialMessage(PaintEventArgs e, Rectangle rect, Color backColor)
        {
            // ファイルリストにも表示させる場合共通設定終了時に描画を追加すること
            var drawInitialMessageFont = GetDrawInitialMessageFont();

            if (dragAndDropAction == DragAndDropAction.ShowThumbnails)
            {
                // アンチエイリアスが効かない
                //TextRenderer.DrawText(e.Graphics, Message.FolderOpenDescription.Replace("\\n", "\n"), drawInitialMessageFont, rect, SystemColors.GrayText, backColor,
                //    TextFormatFlags.HorizontalCenter | TextFormatFlags.VerticalCenter | TextFormatFlags.WordBreak);

                var preMode = e.Graphics.TextRenderingHint;
                e.Graphics.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;

                var message = Message.FolderOpenDescription.Replace("\\n", "\n");
                var size = e.Graphics.MeasureString(message, drawInitialMessageFont, rect.Size);
                var rect2 = new RectangleF(rect.X + (rect.Width - size.Width) / 2, rect.Y + (rect.Height - size.Height) / 2, size.Width, size.Height);

                e.Graphics.DrawString(message, drawInitialMessageFont, SystemBrushes.GrayText, rect2);

                e.Graphics.TextRenderingHint = preMode;
            }
            else
            {

            }

        }

        private void explorerTreeView_NodeMouseClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                AllowFullpower = false;

                if (cmsRightClick.Visible)
                {
                    cmsRightClick.Close();
                }

                try
                {
                    explorerTreeView.SelectedNode = e.Node;
                    var path = ((ShellItem)e.Node.Tag).Path;
                    explorerContextMenu.ShowContextMenu(new FileInfo[] { new FileInfo(path) }, explorerTreeView.PointToScreen(e.Location));
                }
                catch { }
                finally
                {
                    AllowFullpower = true;
                }
            }
            else if (e.Button == MouseButtons.Left)
            {
                if (synchroFromTreeToBar)
                {
                    var bound = e.Node.Bounds;
                    bound.X -= bound.Height;
                    bound.Width = explorerTreeView.TreeViewWnd.Right - bound.Left;
                    if (bound.Contains(e.Location))
                    {
                        explorerTreeView.SelectedNode = e.Node;
                        var path = ((ShellItem)e.Node.Tag).Path;
                        if (IsSupportedByCatalogFormAndExists(path))
                        {
                            zabLocation.Text = path;
                            MakePreview(needToSynchroTree: false);
                        }
                    }
                }
            }
            //var node = e.Node;
            //explorerTreeView.TreeViewWnd.SelectedNode
            //MessageForm.Show($"{e.Button}\n{e.Location}\n{(e.Node.Tag as ShellItem).Path}", "cap", "OK", MessageBoxIcon.None);
        }

        private void explorerTreeView_DragEnter(object sender, DragEventArgs e)
        {
            if (explorerTreeView_TreeWndItemDrag_DragOuting)
            {
                e.Effect = DragDropEffects.None;
                return;
            }
            dropToMoveCopyControl_DragEnter(sender, e);
        }

        enum DragDropFileType { None, RealDefault, RealAlt, Virtual }
        DragDropFileType explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
        string[] explorerTreeView_TreeWndDragEnter_Files = null;
        private bool explorerTreeView_AllowDropVirtualFile = true;

        private void dropToMoveCopyControl_DragEnter(object dummySender, DragEventArgs e)
        {
            explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
            try
            {
                var data = e.Data;
                if (e.KeyState == DragEventKeyState_LeftButton || e.KeyState == (int)Keys.RButton)
                {
                    if (data.GetDataPresent(DataFormats.FileDrop))
                    {
                        explorerTreeView_TreeWndDragEnter_Files = data.GetData(DataFormats.FileDrop, false) as string[];
                        if (explorerTreeView_TreeWndDragEnter_Files != null && explorerTreeView_TreeWndDragEnter_Files.Length > 0)
                        {
                            explorerTreeView_TreeWndDragEnter_FileType = e.KeyState == (int)Keys.LButton ? DragDropFileType.RealDefault : DragDropFileType.RealAlt;
                        }
                    }
                    //else if (explorerTreeView_AllowDropVirtualFile && data.GetDataPresent(NativeMethods.ZIPPLA_FILECONTENTS))
                    else if (explorerTreeView_AllowDropVirtualFile && e.KeyState == DragEventKeyState_LeftButton && data.GetDataPresent(NativeMethods.ZIPPLA_FILECONTENTS))
                    {
                        explorerTreeView_TreeWndDragEnter_FileType = e.KeyState == (int)Keys.LButton ? DragDropFileType.Virtual : DragDropFileType.None;
                    }
                }
            }
            catch
            {
                explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
            }

            if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.None)
            {
                explorerTreeView_TreeWndDragEnter_Files = null;
                e.Effect = DragDropEffects.None;
            }
            else
            {
                Activate();
            }
        }

        enum SameDirEffectMode { None, Link, Ignore }
        private DragDropEffects getDragEffect(string path, DragDropEffects allowedEffect, SameDirEffectMode sameDirMode)
        {
            if (!string.IsNullOrEmpty(path))
            {
                try
                {
                    if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.Virtual)
                    {
                        if ((allowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                        {
                            return DragDropEffects.Copy;
                        }
                    }
                    else
                    {
                        var pathInLower = path.ToLower();
                        if (pathInLower.Last() == ':') pathInLower += Path.DirectorySeparatorChar;
                        //var pathInLower2 = pathInLower.Last() == Path.DirectorySeparatorChar ? pathInLower : (pathInLower + Path.DirectorySeparatorChar);
                        if (explorerTreeView_TreeWndDragEnter_Files != null)
                        {
                            var sameCheck = sameDirMode == SameDirEffectMode.Ignore;
                            if (!sameCheck)
                            {
                                sameCheck = explorerTreeView_TreeWndDragEnter_Files.All(file =>
                                {
                                    var f = file.ToLower();
                                    return Path.GetDirectoryName(f) != pathInLower && f != pathInLower && !pathInLower.StartsWith(f.Last() == Path.DirectorySeparatorChar ? f : (f + Path.DirectorySeparatorChar));
                                });
                            }
                            if (sameCheck || sameDirMode == SameDirEffectMode.Link)
                            {
                                var dstRoot = Path.GetPathRoot(pathInLower);
                                if ((allowedEffect & DragDropEffects.Move) == DragDropEffects.Move && explorerTreeView_TreeWndDragEnter_Files.All(file => Path.GetPathRoot(file).ToLower() == dstRoot))
                                {
                                    return sameCheck ? DragDropEffects.Move : DragDropEffects.Link;
                                }
                                else if ((allowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                                {
                                    return sameCheck ? DragDropEffects.Copy : DragDropEffects.Link;
                                }
                            }
                        }
                    }
                }
                catch
                {
                    return DragDropEffects.None;
                }
            }
            return DragDropEffects.None;
        }

        private void explorerTreeView_TreeWndMouseLeave(object sender, EventArgs e)
        {
            // ドラッグに MouseMove を使わない限り不要
            //explorerTreeView_TreeWndDragEnter_Files = null;
            //explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
        }

        private void explorerTreeView_TreeWndDragOver(object sender, DragEventArgs e)
        {
            if (explorerTreeView_TreeWndItemDrag_DragOuting)
            {
                e.Effect = DragDropEffects.None;
                return;
            }
            if (explorerTreeView_TreeWndDragEnter_FileType != DragDropFileType.None)
            {
                var treeViewWnd = explorerTreeView.TreeViewWnd;
                var pos = treeViewWnd.PointToClient(Cursor.Position);
                var hit = treeViewWnd.HitTest(pos);
                var node = hit.Node;
                if (node != null)
                {
                    treeViewWnd.SelectedNode = node;
                    var path = (node.Tag as ShellItem)?.Path;
                    e.Effect = getDragEffect(path, e.AllowedEffect, SameDirEffectMode.None);
                    if (!node.IsExpanded && node.Nodes.Count > 0)
                    {
                        var bounds = node.Bounds;
                        //var imageBound = treeViewWnd.ImageList.ImageSize; // 通常の ImageList ではない
                        if (pos.X < bounds.Left - bounds.Height)
                        //if (pos.X < bounds.Left - imageBound.Width)
                        {
                            node.Expand();
                        }
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            else
            {
                e.Effect = DragDropEffects.None;
            }
        }

        private void dropToMoveCopyControl_DragDrop(DragEventArgs e, Func<DragEventArgs, string> pathGetter, Action finallyAction)
        {
            if (explorerTreeView_TreeWndItemDrag_DragOuting)
            {
                return;
            }
            if (explorerTreeView_TreeWndDragEnter_FileType != DragDropFileType.None)
            {
                var path = pathGetter(e);
                if (!string.IsNullOrEmpty(path))
                {
                    if (path.Last() == ':') path += Path.DirectorySeparatorChar;
                    try
                    {
                        if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.Virtual)
                        {
                            if ((e.AllowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                            {
                                pasteToTarget(this, path, e.Data, DragDropEffects.Copy);
                            }
                        }
                        else
                        {
                            var pathInLower = path.ToLower();
                            if (explorerTreeView_TreeWndDragEnter_Files != null &&
                                explorerTreeView_TreeWndDragEnter_Files.All(file => Path.GetDirectoryName(file).ToLower() != pathInLower))
                            {
                                var dstRoot = Path.GetPathRoot(pathInLower);
                                DragDropEffects defaultEffect;
                                if ((e.AllowedEffect & DragDropEffects.Move) == DragDropEffects.Move && explorerTreeView_TreeWndDragEnter_Files.All(file => Path.GetPathRoot(file).ToLower() == dstRoot))
                                {
                                    defaultEffect = DragDropEffects.Move;
                                    //pasteToTarget(this, path, e.Data, DragDropEffects.Move);
                                }
                                else if ((e.AllowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                                {
                                    defaultEffect = DragDropEffects.Copy;
                                    //pasteToTarget(this, path, e.Data, DragDropEffects.Copy);
                                }
                                else
                                {
                                    defaultEffect = DragDropEffects.None;
                                }
                                if (defaultEffect != DragDropEffects.None)
                                {
                                    if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.RealDefault)
                                    {
                                        pasteToTarget(this, path, e.Data, defaultEffect);
                                    }
                                    else if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.RealAlt)
                                    {
                                        //var name = SimpleBookmark.GetDisplayName(path);
                                        //moveHereToolStripMenuItem.Text = Message.Movehe
                                        //copyHereToolStripMenuItem.Text = Message.CopyTo1.Replace("$1", name);
                                        var req = Tuple.Create(path, e.Data, finallyAction);
                                        //Activate(); // 非アクティブ状態でコンテクストメニューを出すとそれが残る → これを実行する時点で別のメニューが表示されていると正常に動作しなくなるので MouseEnter に移動
                                        if (this != ActiveForm) Activate();
                                        cmsRightClickDrop.Show(e.X, e.Y);
                                        cmsRightClickDrop_Request = req;
                                        finallyAction = null;
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
                explorerTreeView_TreeWndDragEnter_Files = null;
            }
            finallyAction?.Invoke();
        }

        private Tuple<string, System.Windows.Forms.IDataObject, Action> cmsRightClickDrop_Request = null;

        private void cmsRightClickDrop_Closed(object sender, ToolStripDropDownClosedEventArgs e)
        {
            if (e.CloseReason != ToolStripDropDownCloseReason.ItemClicked && cmsRightClickDrop_Request != null)
            {
                cmsRightClickDrop_Request.Item3?.Invoke();
                cmsRightClickDrop_Request = null;
            }
            AllowFullpower = true;
        }

        private void copyHereToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (cmsRightClickDrop_Request != null)
            {
                try
                {
                    pasteToTarget(this, cmsRightClickDrop_Request.Item1, cmsRightClickDrop_Request.Item2, DragDropEffects.Copy);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                finally
                {
                    cmsRightClickDrop_Request.Item3?.Invoke();
                    cmsRightClickDrop_Request = null;
                }
            }
        }

        private void moveHereToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (cmsRightClickDrop_Request != null)
            {
                try
                {
                    pasteToTarget(this, cmsRightClickDrop_Request.Item1, cmsRightClickDrop_Request.Item2, DragDropEffects.Move);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                finally
                {
                    cmsRightClickDrop_Request.Item3?.Invoke();
                    cmsRightClickDrop_Request = null;
                }
            }
        }

        private void explorerTreeView_TreeWndDragDrop(object sender, DragEventArgs e)
        {
            dropToMoveCopyControl_DragDrop(e, explorerTreeView_PathGetter, finallyAction: null);
        }

        private string explorerTreeView_PathGetter(DragEventArgs e)
        {
            var treeViewWnd = explorerTreeView.TreeViewWnd;
            var pos = treeViewWnd.PointToClient(Cursor.Position);
            var hit = treeViewWnd.HitTest(pos);
            var node = hit.Node;
            if (node != null)
            {
                treeViewWnd.SelectedNode = node;
                return (node.Tag as ShellItem)?.Path;
            }
            else
            {
                return null;
            }
        }

        /*
        private void explorerTreeView_TreeWndDragDrop(object sender, DragEventArgs e)
        {
            if (explorerTreeView_TreeWndDragEnter_FileType != DragDropFileType.None)
            {
                var treeViewWnd = explorerTreeView.TreeViewWnd;
                var pos = treeViewWnd.PointToClient(Cursor.Position);
                var hit = treeViewWnd.HitTest(pos);
                var node = hit.Node;
                if (node != null)
                {
                    treeViewWnd.SelectedNode = node;
                    var path = (node.Tag as ShellItem)?.Path;
                    if (!string.IsNullOrEmpty(path))
                    {
                        try
                        {
                            if (explorerTreeView_TreeWndDragEnter_FileType == DragDropFileType.Virtual)
                            {
                                if ((e.AllowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                                {
                                    pasteToTarget(this, path, e.Data, DragDropEffects.Copy);
                                }
                            }
                            else
                            {
                                var pathInLower = path.ToLower();
                                if (explorerTreeView_TreeWndDragEnter_Files != null &&
                                    explorerTreeView_TreeWndDragEnter_Files.All(file => Path.GetDirectoryName(file).ToLower() != pathInLower))
                                {
                                    var dstRoot = Path.GetPathRoot(pathInLower);
                                    if ((e.AllowedEffect & DragDropEffects.Move) == DragDropEffects.Move && explorerTreeView_TreeWndDragEnter_Files.All(file => Path.GetPathRoot(file).ToLower() == dstRoot))
                                    {
                                        pasteToTarget(this, path, e.Data, DragDropEffects.Move);
                                    }
                                    else if ((e.AllowedEffect & DragDropEffects.Copy) == DragDropEffects.Copy)
                                    {
                                        pasteToTarget(this, path, e.Data, DragDropEffects.Copy);
                                    }
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                    }
                }
                explorerTreeView_TreeWndDragEnter_FileType = DragDropFileType.None;
                explorerTreeView_TreeWndDragEnter_Files = null;
            }
        }
        }*/
        private void dgvFileList_CellPainting(object sender, DataGridViewCellPaintingEventArgs e)
        {
            if (e.ColumnIndex >= 0 && e.RowIndex < 0)
            {
                var column = dgvFileList.Columns[e.ColumnIndex];
                var dir = column.HeaderCell.SortGlyphDirection;
                if (dir != SortOrder.None)
                {
                    e.Paint(e.ClipBounds, e.PaintParts & ~DataGridViewPaintParts.ContentBackground & ~DataGridViewPaintParts.ContentForeground);

                    const float normalizedUpper = 0.37f;
                    const float normalizedLower = 0.63f;

                    var bound = e.CellBounds;
                    var top = bound.Top;
                    var height = bound.Height;
                    var center = bound.Right - tbcIconWidth / 2f;
                    var upper = top + normalizedUpper * height;
                    var lower = top + normalizedLower * height;
                    var halfOfWidth = lower - upper;


                    if (dir == SortOrder.Descending)
                    {
                        e.Graphics.FillPolygon(SystemBrushes.ButtonShadow, new PointF[]
                        {
                            new PointF(center - halfOfWidth, upper),
                            new PointF(center + halfOfWidth, upper),
                            new PointF(center , lower),
                        });
                    }
                    else
                    {
                        e.Graphics.FillPolygon(SystemBrushes.ButtonShadow, new PointF[]
                        {
                            new PointF(center - halfOfWidth, lower),
                            new PointF(center + halfOfWidth, lower),
                            new PointF(center , upper),
                        });
                    }

                    e.Paint(e.ClipBounds, e.PaintParts & DataGridViewPaintParts.ContentForeground);

                    e.Handled = true;
                }
                //var rect = e.CellBounds;
                //rect.X += tbcMargin;
                //TextRenderer.DrawText(e.Graphics, column.HeaderText, dgvFileList.DefaultCellStyle.Font, rect, e.CellStyle.ForeColor, TextFormatFlags.VerticalCenter);
            }
        }

        private void explorerTreeView_DrawNode(object sender, DrawTreeNodeEventArgs e)
        {
            // コントロールがフォーカスを失っても選択色を濃いままにすることが目的

            var node = e.Node;
            var treeView = (TreeView)sender;
            var g = e.Graphics;
            var bounds = node.Bounds;

            Color backColor, foreColor;
            if ((e.State & TreeNodeStates.Selected) != 0)
            {
                backColor = SystemColors.Highlight;
                foreColor = SystemColors.HighlightText;

                e.Graphics.FillRectangle(SystemBrushes.Highlight, bounds);
            }
            else
            {
                backColor = node.BackColor;
                foreColor = node.ForeColor;
                if (backColor == Color.Empty) backColor = treeView.BackColor;
                if (foreColor == Color.Empty) foreColor = treeView.ForeColor;
                using (var b = new SolidBrush(backColor))
                {
                    g.FillRectangle(b, bounds);
                }
            }

            // g.DrawString は枠内に収まらない
            // TextRenderer なら TextFormatFlags.NoPadding でなくとも枠内に収まる
            // TextFormatFlags.NoPadding にすると高解像度環境で正常に表示できない
            var text = node.Text;
            var font = node.NodeFont ?? treeView.Font;
            TextRenderer.DrawText(g, text, font, bounds, foreColor, backColor,
                 TextFormatFlags.VerticalCenter | TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPrefix);
        }

        private void cbLocation_DragEnter(object sender, DragEventArgs e)
        {

            //if (dragOuting)
            if (zabLocation.DragOuting)
            {
                e.Effect = DragDropEffects.None;
                return;
            }

            try
            {
                if (e.KeyState == (int)Keys.LButton && zabLocation.Enabled && !zabLocation.VisibleContextMenuStripSetHasElement && e.Data.GetDataPresent(DataFormats.FileDrop))
                {
                    string[] Files = ShortcutResolver.Exec((string[])e.Data.GetData(DataFormats.FileDrop, false)).ToArray();
                    if (Files.Length == 1)
                    {
                        e.Effect = DragDropEffects.Copy;
                        CloseVisibleContextMenuStrips(); // フォルダのドロップダウンが表示されていることがある
                        cbLocation.Focus();
                    }
                    else
                    {
                        e.Effect = DragDropEffects.None;
                    }
                }
                else
                {
                    e.Effect = DragDropEffects.None;
                }
            }
            catch (Exception error)
            {
                e.Effect = DragDropEffects.None;
                MessageBox.Show(this, error.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void cbLocation_DragLeave(object sender, EventArgs e)
        {
            focusVisibleMainList();
        }

        private void cbLocation_DragDrop(object sender, DragEventArgs e)
        {
            string path;
            try
            {
                path = ShortcutResolver.Exec(((string[])e.Data.GetData(DataFormats.FileDrop, false))[0]);
            }
            catch
            {
                return;
            }
            MoveLocation(ApplicationProviderUser.DragAndDrop, path);
        }

        private void cmsRightClickDrop_Opening(object sender, CancelEventArgs e)
        {
            AllowFullpower = false;
        }

        private void newFolderToolStripMenuItem_Click(object sender, EventArgs e)
        {
            createNewFolderToCurrentLocation();
        }

        private void createNewFolderToCurrentLocation()
        {
            createNewToCurrentLocation(Message.NewFolder + Path.DirectorySeparatorChar);
        }

        private void noneFolderTreeSynchronizingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setSynchroBetweenTreeAndBar(treeToBar: false, barToTree: false);
        }

        private void folderTreeToAddressbarToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setSynchroBetweenTreeAndBar(treeToBar: true, barToTree: false);
        }

        private void addressBarToFolderTreeToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setSynchroBetweenTreeAndBar(treeToBar: false, barToTree: true);
        }

        private void twowayToolStripMenuItem_Click(object sender, EventArgs e)
        {
            setSynchroBetweenTreeAndBar(treeToBar: true, barToTree: true);
        }

        private void collapseOthersWhenSynchronizingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            CollapseOthersWhenSynchronizing = !CollapseOthersWhenSynchronizing;
        }

        bool explorerTreeView_TreeWndItemDrag_DragOuting = false;

        private void createViewerShortcutFromCurrentSettingsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;
            viewToolStripMenuItem.DropDown.Close();
            var info = new ViewerForm.CommandLineOptionInfo();
            info.AlwaysHideUI = AlwaysHideUI;
            info.ArchivesInArchiveMode = ArchivesInArchiveMode;
            info.ReadOnMemoryMode = ReadOnMemoryMode;
            info.BackColor = backColorOfBuiltInViewer;
            info.CoverBindingMode = CoverBindingMode;
            info.DefaultBindingMode = currentBindingMode;
            info.InitialFullscreenMode = BuiltInViewerInitialFullscreenMode;
            info.OpenInPreviousImageFilterSetting = OpenInPreviousImageFilterSetting;
            ViewerForm.CreateShortcut(this, info, currentLocation);
            AllowFullpower = true;
        }

        private bool IsDisplay(SubfolderMode subfolderMode)
        {
            return subfolderMode == SubfolderMode.Display || subfolderMode == SubfolderMode.DisplayHeader || subfolderMode == SubfolderMode.DisplayAndSearch || subfolderMode == SubfolderMode.DisplayHeaderAndSearch;
        }

        // 自動でドロップダウンしない場合は空白になるのが妥当な使用と判断しコメントアウト
            /*
        private void cbFilter_DropDownClosed(object sender, EventArgs e)
        {
            var cb = (ComboBox)sender;
            var si = cb.SelectedIndex;
            if (si < 0)
            {
                // これをしないと空白になってしまう。
                var text = cb.Text;
                var items = cb.Items;
                if (!items.Contains(text))
                {
                    var last = items.Count;
                    items.Add(text);
                    cb.SelectedIndex = last;
                }
                return;
            }
        }
        */

        private void dgvDirectoryList_Paint(object sender, PaintEventArgs e)
        {
            if (showStartHelpMessageOfDirectoryList && dgvDirectoryList.Visible && dgvDirectoryList.RowCount == 0)
            {
                var message = Message.AddBookmarkDescription.Replace(@"\n", "\n");

                var g = e.Graphics;
                var preMode = g.TextRenderingHint;
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;
                var drawInitialMessageFont = GetDrawInitialMessageFont();

                var offset = (int)(drawInitialMessageFont.Size / 2);
                var rect = dgvDirectoryList.ClientRectangle;
                rect.X += offset;
                rect.Y += offset;
                rect.Width -= offset;
                rect.Height -= offset;

                using (var sf = new StringFormat())
                {
                    sf.FormatFlags = StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;
                    sf.LineAlignment = StringAlignment.Far;
                    g.DrawString(message, drawInitialMessageFont, SystemBrushes.GrayText, rect, sf);
                }
                
                g.TextRenderingHint = preMode;
            }
        }

        private void AddOnlyTheCurrentProfileColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AddBookmarkWithCurrentProfileColor(null);
        }

        private void addOnlyANewProfileColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AddBookmarkWithNewProfileColor(null);
        }

        private void aboutAccessKeyToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;
            MessageForm.Show(this, Message.BookmarkAccessKeyUsageDescription.Replace("\\n", "\n").Replace("&", "&&"), Message.AboutAccessKey, Message.OK, MessageBoxIcon.Information);
            AllowFullpower = true;
        }

        private void loadOnlyProfileColorToolStripMenuItem_Click(object sender, EventArgs e)
        {
            var selectedRows = dgvDirectoryList.SelectedRows;
            if (selectedRows.Count != 1) return;
            
            moveToBookmark(selectedRows[0].Index, ApplicationProviderUser.EnterKey, loadOnlyProfileColor: true);
        }

        private void explorerTreeView_TreeWndItemDrag(object sender, ItemDragEventArgs e)
        {
            if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right)
            {
                try
                {
                    TreeView tv = (TreeView)sender;
                    var node = (TreeNode)e.Item;
                    //tv.SelectedNode = 
                    var item = (ShellItem)node.Tag;
                    if (!item.IsFolder) return;
                    var path = item.Path;
                    if (path == "") return;
                    var files = new string[1] { path };
                    //DataObjectを作成する
                    DataObject dataObj = new DataObject(DataFormats.FileDrop, files);
                    tv.SelectedNode = node;
                    //ノードのドラッグを開始する
                    explorerTreeView_TreeWndItemDrag_DragOuting = true;
                    DragDropEffects dde = tv.DoDragDrop(dataObj, DragDropEffects.All);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(this, ex.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                finally
                {
                    explorerTreeView_TreeWndItemDrag_DragOuting = false;
                }
            }
        }

        private void explorerTreeView_TreeWndQueryContinueDrag(object sender, QueryContinueDragEventArgs e)
        {
            if (((Keys)e.KeyState & (Keys.LButton | Keys.RButton)) == (Keys.LButton | Keys.RButton))
            {
                e.Action = DragAction.Cancel;
            }
        }

        private void explorerTreeView_TreeWndMouseDown(object sender, MouseEventArgs e)
        {
            simplifiedKeyBoard.UpHeldKey();
            if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right)
            {
                try
                {
                    var treeWnd = explorerTreeView.TreeViewWnd;
                    var hit = treeWnd.HitTest(e.Location);
                    treeWnd.SelectedNode = hit.Node;
                }
                catch { }
            }
        }

        private void explorerTreeView_TreeWndKeyDown(object sender, KeyEventArgs e)
        {
            var mk = ModifierKeys;
            if (commonKeyAction(e, mk))
            {
                return;
            }
        }

        /*
        private void aboutThumbnailCacheToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;
            MessageBox.Show(this, Message.ThumbnailCacheDescription.Replace(@"\n", "\n"), Message.AboutThumbnailCache, MessageBoxButtons.OK, MessageBoxIcon.Information);
            AllowFullpower = true;
        }
        */



        private static Size sizeProviderForOriginalSizeAsPossible(Fraction aspect, Size originalSize)
        {
            var pixelAspect = (Fraction)originalSize;
            if (aspect == pixelAspect) return originalSize;

            else if (aspect < pixelAspect)
            {
                return new Size((aspect * originalSize.Height).FloorOfPlusHalf(), originalSize.Height);
            }
            else
            {
                return new Size(originalSize.Width, (originalSize.Width / aspect).FloorOfPlusHalf());
            }
            // 誤り
            /*
            else if (aspect < pixelAspect)
            {
                return new Size((pixelAspect / aspect * originalSize.Width).FloorOfPlusHalf(), originalSize.Height);
            }
            else
            {
                return new Size(originalSize.Width, (aspect / pixelAspect * originalSize.Height).FloorOfPlusHalf());
            }
            */
        }

        public bool alertInvisibleItemsOnPaste(IEnumerable<string> dsts, bool checkPath, bool checkAttribute)
        {
            if (dsts == null) return false;
            int dummy;
            /*
            var archiveSkip = !archivesFilesPDFFielsToolStripMenuItem.Checked;
            var imageSkip = !imageFilesToolStripMenuItem.Checked;
            var videoSkip = !videoFilesToolStripMenuItem.Checked;
            var otherSkip = !otherFilesToolStripMenuItem.Checked;
            */
            var archiveSkip = ArchiveLoadLevel == ItemLoadLevel.Ignore;
            var imageSkip = ImageLoadLevel == ItemLoadLevel.Ignore;
            var videoSkip = VideoLoadLevel == ItemLoadLevel.Ignore;
            var otherSkip = OtherLoadLevel == ItemLoadLevel.Ignore;
            var ffmpegExists = MovieThumbnailLoader.ffmpegExists();

            if (checkAttribute && checkPath)
            {
                bool becauseOfAtt = false;
                if (dsts.Any(path => ShouldBeSkipForFileAndDirWithCheckAttributes(path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpegExists, out becauseOfAtt)))
                {
                    if (becauseOfAtt)
                    {
                        return MessageBox.Show(this, Message.ItemsCanBeMovedCopiedButSomeOfThemWillNotBeDisplayedBecauseOfItsAttribute,
                            Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK;
                    }
                    else
                    {
                        return MessageBox.Show(this, Message.ItemsCanBeMovedCopiedButSomeOfThemWillNotBeDisplayedBecauseOfViewSetting,
                            Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK;
                    }
                }
                else return true;
            }
            else
            {
                if (checkPath && dsts.Any(path => ShouldBeSkipForFile(out dummy, path, archiveSkip, imageSkip, videoSkip, otherSkip, ffmpegExists)))
                {
                    return MessageBox.Show(this, Message.ItemsCanBeMovedCopiedButSomeOfThemWillNotBeDisplayedBecauseOfViewSetting,
                        Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK;
                }
                else if (checkAttribute && dsts.Any(path => ShouldBeSkipForFileAndDirWithCheck_Only_Attributes(path, ffmpegExists)))
                {
                    return MessageBox.Show(this, Message.ItemsCanBeMovedCopiedButSomeOfThemWillNotBeDisplayedBecauseOfItsAttribute,
                        Message.Information, MessageBoxButtons.OKCancel, MessageBoxIcon.Information) == DialogResult.OK;
                }
                else return true;
            }
        }

        public static DragDropEffects GetPreferredDropEffect(System.Windows.Forms.IDataObject data)
        {
            DragDropEffects dde = DragDropEffects.None;

            if (data != null)
            {
                try
                {
                    System.IO.MemoryStream ms =
                        (System.IO.MemoryStream)data.GetData("Preferred DropEffect");
                    if (ms != null)
                    {
                        dde = (DragDropEffects)ms.ReadByte();
                    }
                }
                catch { }
            }
            return dde;
        }

        private void mouseGestureSettingToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AllowFullpower = false;

            var edited = Program.OpenMouseGestureSetting(Icon, mgCatalog, getMouseGestureSettingTemplate(), this);

            if (edited)
            {
                mgFileList.Actions = mgCatalog.Actions;
                mgFileList.Enabled = mgCatalog.Enabled;
                mgFileList.Width = mgCatalog.Width;
                mgFileList.Color = mgCatalog.Color;
            }

            AllowFullpower = true;
        }


        public enum Command { GoBack, GoForward, GoUp, ScrollToTop, ResetFilter, ScrollToBottom, ScrollToSelection, Reload, Exit }
        public class MouseGestureCommand { public MouseGestureDirection[] Gesture; public Command Command; }
        private MouseGestureSettingTemplate[] getMouseGestureSettingTemplate()
        {
            return new MouseGestureSettingTemplate[]
            {
                new MouseGestureSettingTemplate( (int)Command.GoBack, Message.GoBack,
                   btnGoToBack.PerformClick),
                new MouseGestureSettingTemplate( (int)Command.GoForward, Message.GoForward,
                   btnGoToForward.PerformClick),
                new MouseGestureSettingTemplate( (int)Command.GoUp, Message.GoUp,
                   goUpFromCurrentLocation),
                new MouseGestureSettingTemplate( (int)Command.ResetFilter, Message.ResetFilter,
                   () => cbFilter.Text = ""),
                new MouseGestureSettingTemplate( (int)Command.ScrollToTop, Message.ScrollToTop,
                   () => {
                       if(tvCatalog.Focused)
                       {
                           tvCatalog.ScrollBarPercentage = 0;
                       }
                       else if(dgvFileList.Focused && dgvFileList.FirstDisplayedScrollingRowIndex > 0)
                       {
                           dgvFileList.FirstDisplayedScrollingRowIndex = 0;
                       }
                   }),
                new MouseGestureSettingTemplate( (int)Command.ScrollToBottom, Message.ScrollToBottom,
                   () => {
                       if(tvCatalog.Focused)
                       {
                           tvCatalog.ScrollBarPercentage = 100;
                       }
                       else if(dgvFileList.Focused && dgvFileList.FirstDisplayedScrollingRowIndex >= 0)
                       {
                           dgvFileList.FirstDisplayedScrollingRowIndex = dgvFileList.Rows.Count - 1;
                       }
                   }),
                new MouseGestureSettingTemplate( (int)Command.ScrollToSelection, Message.ScrollToSelection,
                   () => {
                       if(tvCatalog.Focused)
                       {
                           var index = tvCatalog.SelectedIndex;
                           if(index >= 0)
                           {
                                tvCatalog.ScrollBarToIndexWithMinimalMove(tvCatalog.DataIndexToShowIndex[index]);
                           }
                       }
                       else if(dgvFileList.Focused)
                       {
                           selectionSynchronizingFromThumbnailToFileList(changeScroll: true);
                       }
                   }),
                new MouseGestureSettingTemplate( (int)Command.Reload, Message.Reload,
                   userReload),

                new MouseGestureSettingTemplate( (int)Command.Exit, Message.Exit,
                   Close),
            };
        }


        protected override void WndProc(ref System.Windows.Forms.Message m)
        {
            ActivateManager.WndProcOverrider(base.WndProc, ref m);
        }
    }

    public enum ClipMode { Letterbox, PanAndScan, PlaClip }
    public enum SortMode
    {
        TypeInAsc, TypeInDesc, NameInAsc, NameInDesc, RatingInAsc, RatingInDesc, CreatedInAsc, CreatedInDesc, AccessedInAsc, AccessedInDesc, ModifiedInAsc, ModifiedInDesc, SizeInAsc, SizeInDesc, Random,
        VPageInAsc, VPageInDesc, VResolutionInAsc, VResolutionInDesc, VRatioInAsc, VRatioInDesc, VWidthInAsc, VWidthInDesc, VHeightInAsc, VHeightInDesc, VLengthInAsc, VLengthInDesc, VFPSInAsc, VFPSInDesc// 揮発性（volatility）ソートは Random のあとに書く
    }
    public enum SubfolderMode { Display, DisplayHeader, Ignore, Search, DisplayAndSearch, DisplayHeaderAndSearch }
    public enum BindingMode { SinglePage, SinglePageWithoutScalingUp, LeftToRight, RightToLeft }
    public enum InitialFullscreenMode { ForceFullscreen, ForceWindow, Default }
    public enum ArchivesInArchiveMode { Ignore, IfNoOther1Level, UntilFound2Level, Always1Level }
    public enum CoverBindingMode { Default, ForceSingle }
    public enum SelectionHighlightMode { None, WhenMouseLeaves }
    public enum DoubleClickMode { SelectAndClick, IgnoreMouseMove, Standard }
    public enum FilterRemovingMode { Never, WhenMovingLocation }
    public enum NumberOfLinesOfName { Full, Automatic1, Automatic2, One, Two, Three }
    public enum FolderSortMode { None, Ahead, Behind, FitToDirectionOfSort }
    public enum CatalogFormConetxtMenu { ZipPla, Tag, Explorer }
    public enum ItemSelectionFeedback { None, IfSortMayBeSame, Always }
    public enum SortSyncMode { None, Directory }
    public enum ItemLoadLevel { Ignore = 0, /*Minimul = 1,*/ Header = 1, Full = 3 }
    public class CatalogFormConfig : Configuration
    {
        public const string NOCACHE = "<NOCACHE>";

        public SerializableRGB CurrentProfileColor = SystemColors.Menu;
        public bool Maximized;
        public Point? Point;
        public Size Size;
        public string Location;
        public double ThumbnailScrollbar;
        public int FileListScrollbar;
        public string SelectedFileName;
        public SortMode LastSortMode = SortMode.NameInAsc;
        public SortMode SortMode = SortMode.NameInAsc;
        public string RandomSeed = null;
        public string Filter;
        public int ThumbnailSize = 2;
        public double AspectRatio = Math.Sqrt(1 / 2.0);
        public bool ShowIcon = true;
        public bool ShowRating = true;
        public bool ShowTags = true;
        public bool ShowFilename = true;
        public ClipMode ClipMode = ClipMode.PlaClip;
        public ThumbViewerAligningMode AligningMode = ThumbViewerAligningMode.TotallyUniformedGrid;
        public NumberOfLinesOfName NumberOfLinesOfName = NumberOfLinesOfName.Full;
        public double MinimumFrameThickness = 4;
        public int ThumbnailMouseWheelScrollAmount = 120;
        public ThumbViewerScrollUnit ThumbnailMouseWheelScrollUnit = ThumbViewerScrollUnit.AbsolutePixel;
        public bool BookmarkVisible = true;
        public int BookmarkWidth = -1;
        public int BookmarkHeight = -1;
        public bool FolderTreeVisible = false;
        public bool ThumbnailListVisible = true;
        public bool FileListVisible = true;
        public DockStyle FileListDock = DockStyle.Bottom;
        public int FileListWidth = -1;
        public string[] FileListOrder = new string[0];
        public bool IconInFileList = true;
        public bool PageInFileList = false;
        public bool RatingInFileList = true;
        public bool DateCreatedInFileList = false;
        public bool DateAccessedInFileList = false;
        public bool DateModifiedInFileList = true;
        public bool SizeInFileList = true;
        public bool ResolutionInFileList = false;
        public bool RatioInFileList = false;
        public bool WidthInFileList = false;
        public bool HeightInFileList = false;
        public bool LengthInFileList = false;
        public bool FpsInFileList = false;
        public bool TinyOnScreenKeyboardVisible = false;
        public SelectionHighlightMode SelectionHighlightMode = SelectionHighlightMode.WhenMouseLeaves;
        public FilterRemovingMode? FilterRemovingMode;
        public bool LoadLastViewedPageFromHistory = false;
        //public DoubleClickMode DoubleClickFileOpenMode = DoubleClickMode.IgnoreMouseMove;
        public DoubleClickMode? DoubleClickFileOpenMode = null; // 移行用
        public CatalogFormConetxtMenu RightClickContextMenu = CatalogFormConetxtMenu.ZipPla;
        public CatalogFormConetxtMenu MiddleContextMenu = CatalogFormConetxtMenu.Tag;
        public CatalogFormConetxtMenu ControlRightClickContextMenu = CatalogFormConetxtMenu.Explorer;
        public ItemSelectionFeedback ItemSelectionFeedback = ItemSelectionFeedback.IfSortMayBeSame;
        public bool SynchroFromTreeToBar = true;
        public bool SynchroFromBarToTree = false;
        public bool CollapseOthersWhenSynchronizing = false;
        public FolderSortMode FolderSortMode = FolderSortMode.None;
        //public bool CheckDirectorySize = false;
        public ArchivesInArchiveMode ArchivesInArchiveMode = ArchivesInArchiveMode.Ignore;
        public ReadOnMemoryMode ReadOnMemoryMode = ReadOnMemoryMode.None;
        public bool OpenInPreviousImageFilterSetting = true;
        public BindingMode? DefaultBindingMode = null;
        public CoverBindingMode CoverBindingMode = CoverBindingMode.Default;
        public SortSyncMode SortSyncMode = SortSyncMode.Directory;
        public bool AlwaysHideUI = false;
        public bool AllowReadAheadProcess = true;
        public SerializableRGB BackColorOfBuiltInViewer = Color.Black;
        public SerializableRGB SelectedColorForBackColorOfBuiltInViewer = Color.LightSalmon;
        public InitialFullscreenMode BuiltInViewerInitialFullscreenMode = InitialFullscreenMode.Default;
        public int MaxCaptchaCountInOneVideo = 0;
        public string DisplayArchiveFiles = nameof(ItemLoadLevel.Full);
        public string DisplayImageFiles = nameof(ItemLoadLevel.Full);
        public string DisplayVideoFiles = nameof(ItemLoadLevel.Full);
        public string DisplayOtherFiles = nameof(ItemLoadLevel.Full);
        public string ThumbnailCacheRoot = null;
        public SubfolderMode SubfolderMode = SubfolderMode.Display;
        public string[] LocationHistory;
        public string[] FilterHistory;
        public int RatingReference = 3;
        public KeyAndValue<string, string>[] FilterAliasToString = new KeyAndValue<string, string>[0];
        public bool InvariantFilter = false;

        public bool MouseGestureEnabled = false;
        public double MouseGestureLineWidth = 5;
        public SerializableRGB MouseGestureLineColor = Color.Red;
        public CatalogForm.MouseGestureCommand[] MouseGestureCommands = null;

    }
    
    public class ColoredBookmarkConfig : Configuration
    {
        public SimpleBookmark[] Bookmarks;
        public SerializableRGB[] BookmarkColors;
        public CatalogProfile[] Profiles;
        public SerializableRGB[] ProfileColors;
    }

    public class ColoredBookmark
    {
        public ColoredBookmark(Color color, SimpleBookmark bookmark, CatalogProfile profile)
        {
            Color = color;
            SimpleBookmark = bookmark;
            Profile = profile;
        }

        public SimpleBookmark SimpleBookmark;
        public Color Color;
        public CatalogProfile Profile;

        public override string ToString()
        {
            return SimpleBookmark == null ? "" : SimpleBookmark.ToString();
        }
    }

    public enum SimpleBookmarkSpecialRole { None, Separator } // 数値付きでは XML に保存できない。 Separator がデフォルトにならないようこの順に。
    public class SimpleBookmark
    {
        public SimpleBookmark() { } // シリアライズ用

        public SimpleBookmark(string alias, string location)
        {
            Location = location;
            SetOrResetAlias(alias);
        }

        public SimpleBookmark(SimpleBookmarkSpecialRole specialRole)
        {
            SpecialRole = specialRole;
        }

        public const SimpleBookmarkSpecialRole Separator = SimpleBookmarkSpecialRole.Separator;
        public SimpleBookmarkSpecialRole SpecialRole = SimpleBookmarkSpecialRole.None;

        private bool locationChangedAfterGotDisplayName = false;
        private string location = null;
        public string Location
        {
            get { return location; }
            set
            {
                if (value != location)
                {
                    location = value;
                    locationChangedAfterGotDisplayName = true;
                }
            }
        }

        private string alias;
        public string Alias
        {
            get { return alias; }
            set { SetOrResetAlias(value); }
        }
        public void SetOrResetAlias(string alias)
        {
            if (Location != null && alias == GetDisplayName(Location).Replace("&", "&&"))
            {
                this.alias = null;
            }
            else
            {
                this.alias = alias;
            }
        }

        /// <summary>
        /// ToString() との違いは Location がない場合に末尾に * を付けること
        /// </summary>
        /// <returns></returns>
        public string GetDisplayString() => alias != null ?
                Location != null ? alias : (alias + "*") :
                privateGetDisplayName().Replace("&", "&&");
        
        public override string ToString() => alias ?? privateGetDisplayName().Replace("&", "&&");

        private string privateGetDisplayName_LastResult = "";
        private string privateGetDisplayName()
        {
            if (locationChangedAfterGotDisplayName)
            {
                locationChangedAfterGotDisplayName = false;
                return privateGetDisplayName_LastResult = GetDisplayName(location);
            }
            else
            {
                return privateGetDisplayName_LastResult;
            }
        }

        //private static readonly Regex MightHaveSpecialDisplayName = null;
        private static readonly string HistorySorPathInLowerCase = null;
        static SimpleBookmark()
        {
            try
            {
                HistorySorPathInLowerCase = Program.HistorySorPath.ToLower();
                var user = Path.GetDirectoryName(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile));
                if (user.EndsWith(Path.DirectorySeparatorChar.ToString()) || user.EndsWith(Path.DirectorySeparatorChar.ToString()))
                {
                    user = user.Substring(0, user.Length - 1);
                }
                //UserProfileNameInLowerCase = userProfile.ToLower();
                //UserProfileNameWithSeparatorInLowerCase = UserProfileNameInLowerCase + Path.DirectorySeparatorChar;
                var SepBody = Regex.Escape(Path.DirectorySeparatorChar.ToString()) + Regex.Escape(Path.AltDirectorySeparatorChar.ToString());
                var Sep = "[" + SepBody + "]";
                var NotSep = "[^" + SepBody + "]";
                var Dir = "(?:" + Sep + NotSep + "+)";
                //MightHaveSpecialDisplayName = new Regex($"^(?:{Regex.Escape(user)}{Dir}?{Dir}?|[A-Z]:){Sep}?$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
            }
            catch { }
        }
        private static readonly Dictionary<string, string> GetDisplayNameDictionary = new Dictionary<string, string>();
        public static string GetDisplayName(string path)
        {
            if (path == null) path = "";
            var pathToLower = path.ToLower();
            if (pathToLower == HistorySorPathInLowerCase)
            {
                return $"<{Message.History}>";
            }
            else
            {
                // desktop.ini の存在をチェック
                string result;
                if (GetDisplayNameDictionary.TryGetValue(pathToLower, out result))
                {
                    return result;
                }
                else if (isRoot(path) || HasDesktopIni(path) == true)
                {
                    try
                    {
                        result = FileTypeManager.GetDisplayName(path);
                        GetDisplayNameDictionary[pathToLower] = result;
                        return result;
                    }
                    catch { }
                }


                // ルート及びユーザーフォルダ以下のフォルダのみ FileTypeManager を使う
                /*
                if (MightBeSpecialDirectory(path))
                {
                    string result;
                    if (GetDisplayNameDictionary.TryGetValue(pathToLower, out result))
                    {
                        return result;
                    }
                    try
                    {
                        if (Directory.Exists(path))
                        {
                            result = FileTypeManager.GetDisplayName(path);
                            GetDisplayNameDictionary[pathToLower] = result;
                            return result;
                        }
                    }
                    catch { }
                }
                */

                // Path.GetFileName("C:"); が期待通りに動作しない
                //return Path.GetFileName(path);

                var sepPos = path.LastIndexOf(Path.DirectorySeparatorChar.ToString());
                if (sepPos >= 0 && sepPos < path.Length - 1) return path.Substring(sepPos + 1);
                else return path;
            }
        }

        private static bool isRoot(string path)
        {
            if (path == null) return false;
            var len = path.Length;
            return len == 2 && path[1] == ':' || len == 3 && path[1] == ':' && path[2] == Path.DirectorySeparatorChar;
        }

        public static bool? HasDesktopIni(string path)
        {
            try
            {
                return File.Exists(Path.Combine(path, "desktop.ini"));

            }
            catch
            {
#if !AUTOBUILD
                throw;
#else
                return null;
#endif
            }
        }

        /*
        public static bool MightBeSpecialDirectory(string path)
        {
            return MightHaveSpecialDisplayName != null && MightHaveSpecialDisplayName.IsMatch(path);
        }
        */
    }

    public class CatalogProfile
    {
        //public string Location;
        public SortMode? LastSortMode;
        public SortMode? SortMode;
        public string RandomSeed;
        public string Filter;
        public int? ThumbnailSize;
        public double? AspectRatio;
        public bool? ShowIcon;
        public bool? ShowRating;
        public bool? ShowTags;
        public bool? ShowFilename;
        public ClipMode? ClipMode;
        public ThumbViewerAligningMode? AligningMode;
        public NumberOfLinesOfName? NumberOfLinesOfName;
        public double? MinimumFrameThickness;
        public int? ThumbnailMouseWheelScrollAmount;
        public ThumbViewerScrollUnit? ThumbnailMouseWheelScrollUnit;
        public bool? ThumbnailListVisible;
        public bool? FileListVisible;
        public DockStyle? FileListDock;
        public int? FileListWidth;
        public string[] FileListOrder;
        public bool? IconInFileList;
        public bool? PageInFileList;
        public bool? RatingInFileList;
        public bool? DateCreatedInFileList;
        public bool? DateAccessedInFileList;
        public bool? DateModifiedInFileList;
        public bool? SizeInFileList;
        public bool? ResolutionInFileList;
        public bool? RatioInFileList;
        public bool? WidthInFileList;
        public bool? HeightInFileList;
        public bool? LengthInFileList;
        public bool? FpsInFileList;
        public bool? TinyOnScreenKeyboardVisible;
        public SelectionHighlightMode? SelectionHighlightMode;
        public FilterRemovingMode? FilterRemovingMode;
        public bool? LoadLastViewedPageFromHistory;
        public DoubleClickMode? DoubleClickFileOpenMode;
        public CatalogFormConetxtMenu? RightClickContextMenu;
        public CatalogFormConetxtMenu? MiddleClickContextMenu;
        public CatalogFormConetxtMenu? ControlRightClickContextMenu;
        public ItemSelectionFeedback? ItemSelectionFeedback;
        public bool? SynchroFromTreeToBar;
        public bool? SynchroFromBarToTree;
        public bool? CollapseOthersWhenSynchronizing;
        public FolderSortMode? FolderSortMode;
        // public bool? CheckDirectorySize;
        public ArchivesInArchiveMode? ArchivesInArchiveMode;
        public ReadOnMemoryMode? ReadOnMemoryMode;
        public bool? OpenInPreviousImageFilterSetting;
        public BindingMode? DefaultBindingMode;
        public CoverBindingMode? CoverBindingMode;
        public SortSyncMode? SortSyncMode;
        public bool? AlwaysHideUI;
        public bool? AllowReadAheadProcess;
        public SerializableRGB? BackColorOfBuiltInViewer;
        public SerializableRGB? SelectedColorForBackColorOfBuiltInViewer;
        public InitialFullscreenMode? BuiltInViewerInitialFullscreenMode;
        public int? MaxCaptchaCountInOneVideo;
        public string DisplayArchiveFiles;
        public string DisplayImageFiles;
        public string DisplayVideoFiles;
        public string DisplayOtherFiles;
        public string ThumbnailCacheRoot;
        public SubfolderMode? SubfolderMode;
        public string[] FilterHistory;
        public bool? InvariantFilter;
        public KeyAndValue<string, string>[] FilterAliasToString;

        public ZipTag[] Tags;

        // シリアル化のため
        public CatalogProfile()
        {
        }

        /*
        public CatalogProfile(string location)
        {
            Location = location;
        }
        */

        public CatalogProfile(
            SortMode? lastSortMode,
            SortMode? sortMode,
            string randomSeed,
            string filter,
            int? thumbnailSize,
            double? aspectRatio,
            bool? showIcon,
            bool? showRating,
            bool? showTags,
            bool? showFilename,
            ClipMode? clipMode,
            ThumbViewerAligningMode? aligningMode,
            NumberOfLinesOfName numberOfLinesOfName,
            double? minimumFrameThickness,
            int thumbnailMouseWheelScrollAmount,
            ThumbViewerScrollUnit thumbnailMouseWheelScrollUnit,
            bool? thumbnailListVisible,
            bool? fileListVisible,
            DockStyle? fileListDock,
            int? fileListWidth,
            string[] fileListOrder,
            bool? iconInFileList,
            bool? pageInFileList,
            bool? ratingInFileList,
            bool? dateCreatedInFileList,
            bool? dateAccessedInFileList,
            bool? dateModifiedInFileList,
            bool? sizeInFileList,
            bool? resolutionInFileList,
            bool? ratioInFileList,
            bool? widthInFileList,
            bool? heightInFileList,
            bool? lengthInFileList,
            bool? fpsInFileList,
            bool tinyOnScreenKeyboardVisible,
            SelectionHighlightMode selectionHighlightMode,
            FilterRemovingMode filterRemovingMode,
            bool loadLastViewedPageFromHistory,
            DoubleClickMode doubleClickFileOpenMode,
            CatalogFormConetxtMenu rightClickContextMenu,
            CatalogFormConetxtMenu middleClickContextMenu,
            CatalogFormConetxtMenu controlRightClickContextMenu,
            ItemSelectionFeedback itemSelectionFeedback,
            bool synchroFromTreeToBar,
            bool synchroFromBarToTree,
            bool collapseOthersWhenSynchronizing,
            FolderSortMode folderSortMode,
            // bool checkDirectorySize,
            ArchivesInArchiveMode archivesInArchiveMode,
            ReadOnMemoryMode readOnMemoryMode,
            bool openInPreviousImageFilterSetting,
            BindingMode defaultBindingMode,
            CoverBindingMode coverBindingMode,
            SortSyncMode sortSyncMode,
            bool alwaysHideUI,
            bool allowReadAheadProcess,
            Color backColorOfBuiltInViewer,
            Color selectedColorForBackColorOfBuiltInViewer,
            InitialFullscreenMode? builtInViewerInitialFullscreenMode,
            int? maxCaptchaCountInOneVideo,
            ItemLoadLevel archiveLoadLevel,
            ItemLoadLevel imageLoadLevel,
            ItemLoadLevel videoLoadLevel,
            ItemLoadLevel otherLoadLevel,
            string thumbnailCacheRoot,
            SubfolderMode? subfolderMode,
            string[] filterHistory,
            bool invariantFilter,
            KeyAndValue<string, string>[] filterAliasToString,
            ZipTag[] tags
            )
        {
            LastSortMode = lastSortMode;
            SortMode = sortMode;
            RandomSeed = randomSeed;
            Filter = filter;
            ThumbnailSize = thumbnailSize;
            AspectRatio = aspectRatio;
            ShowIcon = showIcon;
            ShowRating = showRating;
            ShowTags = showTags;
            ShowFilename = showFilename;
            ClipMode = clipMode;
            AligningMode = aligningMode;
            NumberOfLinesOfName = numberOfLinesOfName;
            MinimumFrameThickness = minimumFrameThickness;
            ThumbnailMouseWheelScrollAmount = thumbnailMouseWheelScrollAmount;
            ThumbnailMouseWheelScrollUnit = thumbnailMouseWheelScrollUnit;
            ThumbnailListVisible = thumbnailListVisible;
            FileListVisible = fileListVisible;
            //if (fileListVisible != false)
            {
                FileListDock = fileListDock;
                FileListWidth = fileListWidth;
                FileListOrder = fileListOrder;
                IconInFileList = iconInFileList;
                PageInFileList = pageInFileList;
                ratingInFileList = RatingInFileList;
                DateCreatedInFileList = dateCreatedInFileList;
                DateAccessedInFileList = dateAccessedInFileList;
                DateModifiedInFileList = dateModifiedInFileList;
                SizeInFileList = sizeInFileList;
                ResolutionInFileList = resolutionInFileList;
                RatioInFileList = ratioInFileList;
                WidthInFileList = widthInFileList;
                HeightInFileList = heightInFileList;
                LengthInFileList = lengthInFileList;
                FpsInFileList = fpsInFileList;
            }
            TinyOnScreenKeyboardVisible = tinyOnScreenKeyboardVisible;
            SelectionHighlightMode = selectionHighlightMode;
            FilterRemovingMode = filterRemovingMode;
            LoadLastViewedPageFromHistory = loadLastViewedPageFromHistory;
            DoubleClickFileOpenMode = doubleClickFileOpenMode;
            RightClickContextMenu = rightClickContextMenu;
            MiddleClickContextMenu = middleClickContextMenu;
            ControlRightClickContextMenu = controlRightClickContextMenu;
            ItemSelectionFeedback = itemSelectionFeedback;
            SynchroFromTreeToBar = synchroFromTreeToBar;
            SynchroFromBarToTree = synchroFromBarToTree;
            CollapseOthersWhenSynchronizing = collapseOthersWhenSynchronizing;
            FolderSortMode = folderSortMode;
            //CheckDirectorySize = checkDirectorySize;
            ArchivesInArchiveMode = archivesInArchiveMode;
            ReadOnMemoryMode = readOnMemoryMode;
            OpenInPreviousImageFilterSetting = openInPreviousImageFilterSetting;
            DefaultBindingMode = defaultBindingMode;
            BackColorOfBuiltInViewer = backColorOfBuiltInViewer;
            SelectedColorForBackColorOfBuiltInViewer = selectedColorForBackColorOfBuiltInViewer;
            CoverBindingMode = coverBindingMode;
            SortSyncMode = sortSyncMode;
            AlwaysHideUI = alwaysHideUI;
            AllowReadAheadProcess = allowReadAheadProcess;
            BuiltInViewerInitialFullscreenMode = builtInViewerInitialFullscreenMode;
            MaxCaptchaCountInOneVideo = maxCaptchaCountInOneVideo;
            DisplayArchiveFiles = archiveLoadLevel.ToString();
            DisplayImageFiles = imageLoadLevel.ToString();
            DisplayVideoFiles = videoLoadLevel.ToString();
            DisplayOtherFiles = otherLoadLevel.ToString();
            ThumbnailCacheRoot = thumbnailCacheRoot == null ? CatalogFormConfig.NOCACHE : thumbnailCacheRoot;
            SubfolderMode = subfolderMode;
            FilterHistory = filterHistory;
            InvariantFilter = invariantFilter;
            FilterAliasToString = filterAliasToString;
            Tags = tags;
        }
    }


    public class ThumbViewerItem : IDisposable
    {
        private ThumbViewer owner = null;
        public ThumbViewer Owner { get { return owner; } }
        private int index = -1;
        public int Index { get { return index; } }
        private bool selected = false;
        public bool Selected { get { return selected; } }
        private Bitmap image;
        public Bitmap Image
        {
            get
            {
                return image;
            }
            set
            {
                if (image != null) image.Dispose();
                image = value;
                if (owner != null)
                {
                    owner.DrawItem(index, selected, onlyFrame: false);
                }
            }
        }
        private string text;
        public string Text
        {
            get
            {
                return text;
            }
            set
            {
                text = value;
                if (owner != null)
                {
                    //owner.DrawItem(g, index, selected, onlyFrame: false); // テキストの行数が変わった時のため
                    owner.DrawItem(index, selected, onlyFrame: true); // 現在の仕様ではテキストは画像に重なることはない
                }
            }
        }
        public void DrawItem(bool onlyFrame)
        {
            if (owner != null)
            {
                owner.DrawItem(index, selected, onlyFrame);
            }
        }
        public void SilentSet(Bitmap image, string text)
        {
            if (this.image != null) this.image.Dispose();
            this.image = image;
            this.text = text;
        }
        public void SilentSet(string text)
        {
            this.text = text;
        }

        public void Set(Bitmap image, string text)
        {
            if (this.image != null) this.image.Dispose();
            this.image = image;
            this.text = text;

            if (owner != null)
            {
                owner.DrawItem(index, selected, onlyFrame: false);
            }
        }

        public void Dispose()
        {
            if (Image != null)
            {
                Image.Dispose();
                Image = null;
            }
        }
    }

    public enum ThumbViewerAligningMode { TotallyUniformedGrid, HorizontallyUniformedGrid, LeftAlignedGrid, CenteredGrid }
    public enum ThumbViewerScrollUnit { AbsolutePixel, GridCeiling }

    public class ThumbViewer : ScrollableControl, IGraphicalList
    {
        private static readonly FieldInfo thumbViewerItemOwnerFieldInfo = typeof(ThumbViewerItem).GetField("owner", BindingFlags.NonPublic | BindingFlags.Instance);
        private static readonly FieldInfo thumbViewerItemIndexFieldInfo = typeof(ThumbViewerItem).GetField("index", BindingFlags.NonPublic | BindingFlags.Instance);
        public static readonly FieldInfo thumbViewerItemSelectedFieldInfo = typeof(ThumbViewerItem).GetField("selected", BindingFlags.NonPublic | BindingFlags.Instance);

        readonly List<ThumbViewerItem> items = new List<ThumbViewerItem>(); // サムネイル保存用

        public int MouseWheelScrollAmount = 120;
        public ThumbViewerScrollUnit MouseWheelScrollUnit = ThumbViewerScrollUnit.AbsolutePixel;

        public event EventHandler DisplayedChanged;
        public event EventHandler ShowIndexToDataIndexChanged;

        public enum DrawModeEnum { None = 0, User = 1, System, Full = 3 }
        public DrawModeEnum DrawMode = DrawModeEnum.Full;

        public int HorizontalLoopLevel = 1;

        private ThumbViewerAligningMode layoutMode = ThumbViewerAligningMode.TotallyUniformedGrid;
        public ThumbViewerAligningMode LayoutMode
        {
            get
            {
                return layoutMode;
            }
            set
            {
                if (layoutMode != value)
                {
                    layoutMode = value;
                    updateRowsCols();
                    Invalidate();
                }
            }
        }

        private byte unselectedItemAlphaChannel = 255;
        private Brush unselectedItemMaskBrush = null;
        public byte UnselectedItemAlphaChannel
        {
            get
            {
                return unselectedItemAlphaChannel;
            }
            set
            {
                if (unselectedItemAlphaChannel != value)
                {
                    unselectedItemAlphaChannel = value;
                    if (unselectedItemMaskBrush != null) unselectedItemMaskBrush.Dispose();
                    if (unselectedItemAlphaChannel == 255)
                    {
                        unselectedItemMaskBrush = null;
                    }
                    else
                    {
                        unselectedItemMaskBrush = new SolidBrush(Color.FromArgb(255 - unselectedItemAlphaChannel, BackColor));
                    }
                    Refresh();
                }
            }
        }

        Bitmap dummyImage = new Bitmap(1, 1);

        public int[] DataIndexToShowIndex
        {
            get
            {
                return dataIndexToShowIndex;
            }
        }

        public int[] ShowIndexToDataIndex
        {
            get
            {
                return showIndexToDataIndex;
            }
            set
            {
                var lenChanged = showIndexToDataIndex.Length != value.Length;
                showIndexToDataIndex = value;

                dataIndexToShowIndex = new int[items.Count];
                for (var i = 0; i < dataIndexToShowIndex.Length; i++)
                {
                    dataIndexToShowIndex[i] = -1;
                }
                var focusedLeft = false;
                for (var i = 0; i < showIndexToDataIndex.Length; i++)
                {
                    var dataIndex = showIndexToDataIndex[i];
                    dataIndexToShowIndex[dataIndex] = i;
                    if (dataIndex == focusedIndex) focusedLeft = true;
                }
                if (!focusedLeft) focusedIndex = -1;
                if (lenChanged) updateRowsCols();
                Invalidate();
                DisplayedChanged?.Invoke(this, null);

                var oldIndex = -2;

                for (var i = selectedIndices.Count - 1; i >= 0; i--)
                {
                    var index = SelectedIndices[i];
                    if (index >= dataIndexToShowIndex.Length || dataIndexToShowIndex[index] < 0)
                    {
                        if (oldIndex == -2) oldIndex = SelectedIndex;
                        removeSelectionAt(i);
                    }
                }

                if (oldIndex >= 0)
                {
                    ClearAllSelection();
                    var se = new SelectedIndexChangedEventArgs(oldIndex, -1);
                    SelectedIndexChanged?.Invoke(this, se);
                }

                ShowIndexToDataIndexChanged?.Invoke(this, null);
            }

        }
        private int[] dataIndexToShowIndex = new int[0];
        private int[] showIndexToDataIndex = new int[0];

        public void ClearAllSelection()
        {
            if (selectedIndices != null)
            {
                foreach (var index in selectedIndices)
                {
                    var item = items[index];
                    if (item != null) thumbViewerItemSelectedFieldInfo.SetValue(item, false);
                }
                selectedIndices.Clear();
            }
        }

        private void addSelection(int index) // 重複確認しない
        {
            if (selectedIndices != null)
            {
                selectedIndices.Add(index);
                var item = items[index];
                if (item != null) thumbViewerItemSelectedFieldInfo.SetValue(item, true);
            }
        }

        private void removeSelectionAt(int indexOnIndices)
        {
            if (selectedIndices != null)
            {
                var index = selectedIndices[indexOnIndices];
                selectedIndices.RemoveAt(indexOnIndices);
                var item = items[index];
                if (item != null) thumbViewerItemSelectedFieldInfo.SetValue(item, false);
            }
        }

        // デザイナでエラーが出るのでここでは設定しない
        int topPadding; // Program.DpiScaling(2); // グリッド内でのサムネイルの余白
        int sidePadding; // Program.DpiScaling(2);
        /// <summary>
        /// プログラムの最初以外で変更する場合ファイル名に合わせた行数を求める処理で不整合が起こらないように注意する
        /// </summary>
        public int bottomPadding; // = Program.DpiScaling(2);
        public int ThumbnailPadding
        {
            set
            {
                if (topPadding != value || sidePadding != value)
                {
                    topPadding = sidePadding = value;
                    updateRowsCols();
                    Invalidate();
                }
            }
        }

        int thumbWidth; // 表示中のサムネイルのサイズ
        int thumbHeight; // 表示中のサムネイルのサイズ
        int textHeight; // 表示中のテキスト用に確保する高さ
        int cols; // グリッドの列数
        int rows; // グリッドの行数
        public int gridOffsetH { get; private set; } // グリッドのサイズ
        public int gridSizeH { get; private set; } // グリッドのサイズ
        public int gridSizeV { get; private set; } // グリッドのサイズ
        bool showText = true;
        //int selectedIndex = -1; // 現在選択されているサムネイル、複数選択時は負に
        private readonly List<int> selectedIndices = new List<int>();

        public Color FrameColor
        {
            get
            {
                return frameColor;
            }
            set
            {
                if (frameColor != value)
                {
                    frameColor = value;
                    frameBrush.Dispose();
                    frameBrush = new SolidBrush(frameColor);
                    selectedForeColor = ZipTag.GetForeColor(frameColor);
                }
            }
        }
        Color frameColor = Color.LightSalmon;
        Color selectedForeColor;
        Brush frameBrush; // 選択用のブラシ
        Brush backBrush;

        public void SetBackAndForeColor(Color backColor)
        {
            BackColor = backColor;
            backBrush?.Dispose();
            backBrush = new SolidBrush(backColor);
            ForeColor = ZipTag.GetForeColor(backColor);
        }

        /// <summary>
        /// 必要なデザイナ変数です。
        /// </summary>
        private System.ComponentModel.Container components = null;

        public ThumbViewer()
        {
#if RUNTIME
            Program.RunTimeMeasure.Block("ThumbViewer Initialize");
#endif

            // この呼び出しは、Windows.Forms フォーム デザイナで必要です。
            InitializeComponent();

            // TODO: InitComponent 呼び出しの後に初期化処理を追加してください。

            // ダブルバッファリングによる描画の高速化
            this.SetStyle(ControlStyles.DoubleBuffer, true);
            this.SetStyle(ControlStyles.UserPaint, true);
            this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);

            this.BackColor = SystemColors.Window;

            frameBrush = new SolidBrush(frameColor);//new SolidBrush(Color.LightSalmon);
            backBrush = new SolidBrush(BackColor);
            selectedForeColor = ZipTag.GetForeColor(frameColor);

            // デフォルトのサムネイルのサイズを設定
            thumbWidth = thumbHeight = 64;

            // 他は CatalogForm が設定する
            //bottomPadding = Program.DpiScaling(2);

            gridSizeH = thumbWidth + 2 * sidePadding;

            //SetTextHeightFromSquareCharCount(16);
            SetTextHeight(refresh: false);

            // 選択されているサムネイルなし
            if (selectedIndices.Count > 0)
            {
                var se = new SelectedIndexChangedEventArgs(SelectedIndex, -1);
                ClearAllSelection();
                SelectedIndexChanged?.Invoke(this, se);
            }
            updateRowsCols();
#if RUNTIME
            Program.RunTimeMeasure.Block("InitializeComponent");
#endif
        }

        /// <summary>
        /// 使用されているリソースに後処理を実行します。
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                    components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region コンポーネント デザイナで生成されたコード 
        /// <summary>
        /// デザイナ サポートに必要なメソッドです。このメソッドの内容を 
        /// コード］エディタで変更しないでください。
        /// </summary>
        private void InitializeComponent()
        {
            // 
            // ThumbViewer
            // 
            this.Name = "ThumbViewer";
        }
        #endregion

        public double ScrollBarPercentage
        {
            get
            {
                /*
                var denum = OnPaint_VerticalScrollMax - OnPaint_VerticalScrollMin;
                if (denum != 0)
                {
                    return 100 * (OnPaint_VerticalScrollVal - OnPaint_VerticalScrollMin) / denum;
                }
                else
                {
                    return 0;
                }
                */
                return scrollBarPercentage;
            }
            set
            {
                if (value != ScrollBarPercentage)
                {
                    setScrollBarPercentage(value);
                }
            }
        }

        static double getOriginOffset(double height) => 0;

        double scrollBarPercentage;
        void setScrollBarPercentage(double v)
        {
            var height = Height;
            var top = VerticalScroll.Minimum;
            var bottom = VerticalScroll.Maximum;
            var fullHeight = bottom - top;
            var val = Math.Max(top, Math.Min(bottom - height, (v / 100 * fullHeight + top - getOriginOffset(height))));

            AutoScrollPosition = new Point(-AutoScrollPosition.X, (int)Math.Round(val)); // これで OnPaint → setScrollBarPercentageOnPaint が実行される
        }
        void setScrollBarPercentageOnPaint(double height, double top, double val, double fullHeight)
            => scrollBarPercentage = fullHeight > 0 ? 100 * (val - top + getOriginOffset(height)) / fullHeight : 0;

        public void ScrollBarToIndex(int dataIndex)
        {
            int showIndex = dataIndexToShowIndex[dataIndex];

            int val = Math.Max(VerticalScroll.Minimum, Math.Min(VerticalScroll.Maximum - Height, (showIndex / cols) * gridSizeV));
            AutoScrollPosition = new Point(-AutoScrollPosition.X, val);

            // ここで val を代入すると DisplayChanged が発動しないため代入してはならない。
            //OnPaint_VerticalScrollVal = val;
        }

        public void ScrollBarToIndexWithMinimalMove(int showIndex)
        {
            int val;

            int fullRowStart = (-this.AutoScrollPosition.Y + gridSizeV - 1) / gridSizeV;
            int fullStart = fullRowStart * cols;
            if (showIndex < fullStart)
            {
                val = Math.Max(VerticalScroll.Minimum, Math.Min(VerticalScroll.Maximum - Height, (showIndex / cols) * gridSizeV));
            }
            else
            {
                int fullRowEnd = (-this.AutoScrollPosition.Y + Height - gridSizeV + 1) / gridSizeV + 1;
                int fullStop = Math.Min(fullRowEnd * cols, showIndexToDataIndex.Length);
                if (showIndex >= fullStop)
                {
                    val = Math.Max(VerticalScroll.Minimum, Math.Min(VerticalScroll.Maximum - Height, (showIndex / cols) * gridSizeV - Height + gridSizeV - 1));
                }
                else
                {
                    return;
                }
            }

            AutoScrollPosition = new Point(-AutoScrollPosition.X, val);

            // ここで val を代入すると DisplayChanged が発動しないため代入してはならない。
            //OnPaint_VerticalScrollVal = val;
        }

        // 使用する場合 s2d 等の更新が必要
        /*
        public void Add(ThumbViewerItem item)
        {
            if (item != null)
            {
                thumbViewerItemOwnerFieldInfo.SetValue(item, this);
                thumbViewerItemIndexFieldInfo.SetValue(item, items.Count);
                thumbViewerItemSelectedFieldInfo.SetValue(item, selectedIndices?.Contains(items.Count) == true);
            }
            items.Add(item);
            updateRowsCols();

            // 追加されたサムネイルを表示
            using (Graphics g = this.CreateGraphics())
            {
                DrawItem(g, items.Count - 1, false);
            }
        }
        */

        public void SilentAdd(ThumbViewerItem item)
        {
            if (item != null)
            {
                thumbViewerItemOwnerFieldInfo.SetValue(item, this);
                thumbViewerItemIndexFieldInfo.SetValue(item, items.Count);

            }
            items.Add(item);
            var newD2S = new int[dataIndexToShowIndex.Length + 1];
            Array.Copy(dataIndexToShowIndex, newD2S, dataIndexToShowIndex.Length);
            newD2S[dataIndexToShowIndex.Length] = -1;
            return;
        }

        public void ItemBuffSizeChange(int newLength)
        {
            items.AddRange(new ThumbViewerItem[newLength - items.Count]);
            var newD2S = new int[newLength];
            Array.Copy(dataIndexToShowIndex, newD2S, dataIndexToShowIndex.Length);
            for (var i = dataIndexToShowIndex.Length; i < newLength; i++) newD2S[i] = -1;
            dataIndexToShowIndex = newD2S;
        }

        public int Count
        {
            get
            {
                return items.Count;
            }
        }

        public ThumbViewerItem this[int index]
        {
            get
            {
                return items[index];
            }
            set
            {
                if (index < items.Count)
                {
                    var item = items[index];
                    if (item != null) item.Dispose();
                    if (value != null)
                    {
                        thumbViewerItemOwnerFieldInfo.SetValue(value, this);
                        thumbViewerItemIndexFieldInfo.SetValue(value, index);
                        thumbViewerItemSelectedFieldInfo.SetValue(value, selectedIndices?.Contains(index) == true);
                    }
                    items[index] = value;
                    // 追加されたサムネイルを表示
                    using (Graphics g = this.CreateGraphics())
                    {
                        DrawItem(g, index, selectedIndices != null && selectedIndices.Contains(index));
                    }
                }
                else
                {
                    throw new IndexOutOfRangeException();
                    /*
                    while (index > items.Count)
                    {
                        items.Add(null);
                    }
                    Add(value);
                    */
                }
            }
        }

        public void SilentSet(int index, ThumbViewerItem item)
        {
            if (index < items.Count)
            {
                var oldItem = items[index];
                if (oldItem != null) oldItem.Dispose();
                if (item != null)
                {
                    thumbViewerItemOwnerFieldInfo.SetValue(item, this);
                    thumbViewerItemIndexFieldInfo.SetValue(item, index);
                }
                items[index] = item;
            }
            else
            {
#if DEBUG
                throw new IndexOutOfRangeException($"SilentSet({index}, itemIndex = {item?.Index}), itemsCount = {items.Count}");
#else
                throw new IndexOutOfRangeException();
#endif
                /*
                    while (index > items.Count)
                    {
                        items.Add(null);
                    }
                    SilentAdd(item);*/
            }
        }

        public class SelectedIndexChangedEventArgs
        {
            public int NewIndex { get; private set; }
            public int OldIndex { get; private set; }
            public SelectedIndexChangedEventArgs(int oldIndex, int newIndex)
            {
                NewIndex = newIndex;
                OldIndex = oldIndex;
            }
        }
        public delegate void SelectedIndexChangedEventHandler(object sender, SelectedIndexChangedEventArgs e);
        public event SelectedIndexChangedEventHandler SelectedIndexChanged;

        // 指定された点を左上にして画像を描画
        void drawImageUnscaled(Graphics g, Bitmap image, int x, int y)
        {
            g.DrawImageUnscaled(image, x, y);
        }

        // 指定された領域の中央に画像を描画
        /*
        void drawImageCenter(Graphics g, Image image, int x, int y, int w, int h)
        {
            float fw = (float)w / (float)image.Width;
            float fh = (float)h / (float)image.Height;

            float scale = Math.Min(fw, fh);
            fw = image.Width * scale;
            fh = image.Height * scale;

            // g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.High; // より高画質に

            g.DrawImage(image,
                x + (w - fw) / 2,
                y + (h - fh) / 2,
                fw, fh);

        }
        */

        public void DoMouseUp()
        {
            var pos = PointToClient(Cursor.Position);
            OnMouseUp(new MouseEventArgs(MouseButtons.Left, 1, pos.X, pos.Y, 0));
        }

        //public event PaintEventHandler PaintOne;
        public class ThumbnailPaintEventArgs : EventArgs { public Graphics Graphics; public int DataIndex; public Rectangle ThumbnailRectangle; }
        public delegate void ThumbnailPaintEventHandler(ThumbViewer sender, ThumbnailPaintEventArgs e);
        public event ThumbnailPaintEventHandler ThumbnailPaint;

        private Tuple<int, int> getFrameWidthPrimary()
        {
            var w = (gridSizeH - thumbWidthCurrent) / 2;
            return Tuple.Create(w, layoutMode == ThumbViewerAligningMode.TotallyUniformedGrid ? w : topPadding);
        }

        private Rectangle getThumbnailRectangle(int col, int row, int AutoScrollPositionY)
        {
            var frameWidthPrimary = getFrameWidthPrimary();
            int x = gridOffsetH + col * gridSizeH + frameWidthPrimary.Item1;
            int y = row * gridSizeV + frameWidthPrimary.Item2 + AutoScrollPositionY;
            int w = thumbWidthCurrent;
            int h = thumbHeight;
            return new Rectangle(x, y, w, h);
        }

        private Rectangle getLocalThumbnailRectangle()
        {
            var frameWidthPrimary = getFrameWidthPrimary();
            int x = frameWidthPrimary.Item1;
            int y = frameWidthPrimary.Item2;
            int w = thumbWidthCurrent;
            int h = thumbHeight;
            return new Rectangle(x, y, w, h);
        }

        private Rectangle getGridRectangle(int col, int row, bool cutOverflow)
        {
            int x = gridOffsetH + col * gridSizeH;
            int y = row * gridSizeV + this.AutoScrollPosition.Y;
            int w = gridSizeH;
            int h = gridSizeV;
            var result = new Rectangle(x, y, w, h);
            if (cutOverflow)
            {
                result.Intersect(ClientRectangle);
            }
            return result;
        }

        public bool DrawStop = false;

        protected override void OnBackColorChanged(EventArgs e)
        {
            base.OnBackColorChanged(e);

            if (BackColorBrush != null) BackColorBrush.Dispose();
            BackColorBrush = new SolidBrush(BackColor);
            preRenderScroll_AutoScrollPositionY = int.MinValue;
        }

        // 指定されたインデックス番号のサムネイルを表示
        private Bitmap DrawItem_canvas;
        private Bitmap DrawItem_slicedCanvas;
        private Brush BackColorBrush;
        public void DrawItem(int index, bool selected, bool onlyFrame = false, bool alreadyCheckedVisibleRegion = false, Rectangle clipRectangle = default(Rectangle), int AutoScrollPositionY = int.MinValue)
        {
            DrawItem(null, index, selected, onlyFrame, alreadyCheckedVisibleRegion, clipRectangle, AutoScrollPositionY);
        }
        public void DrawItem(Graphics g, int index, bool selected, bool onlyFrame = false, bool alreadyCheckedVisibleRegion = false, Rectangle clipRectangle = default(Rectangle), int AutoScrollPositionY = int.MinValue)
        {
            if (DrawStop) return;
            var showIndex = dataIndexToShowIndex[index];
            if (showIndex < 0) return;


            if (!alreadyCheckedVisibleRegion)
            {
                if (showIndex < DisplayedStartShowIndex || showIndex >= DisplayedStopShowIndex) return;
            }
            var item = items[index];
            Bitmap image = item?.Image;
            if (image == null) image = dummyImage;
            int col = showIndex % cols;
            int row = showIndex / cols;

            if (AutoScrollPositionY == int.MinValue) AutoScrollPositionY = AutoScrollPosition.Y;

            if (preRenderScroll_AutoScrollPositionY != int.MinValue)
            {
                var gRect = new Rectangle(col * gridSizeH, row * gridSizeV + AutoScrollPositionY, gridSizeH, gridSizeV);
                var abs1 = new Rectangle(preRenderScroll_ClipRectangle.X, preRenderScroll_ClipRectangle.Y - preRenderScroll_AutoScrollPositionY, preRenderScroll_ClipRectangle.Width, preRenderScroll_ClipRectangle.Height);
                var abs2 = new Rectangle(gRect.X, gRect.Y - AutoScrollPositionY, gRect.Width, gRect.Height);
                if (abs1.IntersectsWith(abs2))
                {
                    preRenderScroll_AutoScrollPositionY = int.MinValue;
                }
            }

            var tRect = getThumbnailRectangle(col, row, AutoScrollPositionY);

            // 枠以外で手動ダブルバッファリングする実装
            var gMustBeDisposed = false;
            if (!onlyFrame)
            {
                if (clipRectangle.IsEmpty)
                {
                    clipRectangle = ClientRectangle;
                }
                if (clipRectangle.Contains(tRect))
                {
                    if (DrawItem_canvas != null && !(DrawItem_canvas.Width == tRect.Width && DrawItem_canvas.Height == tRect.Height))
                    {
                        DrawItem_canvas.Dispose();
                        DrawItem_canvas = null;
                    }

                    if (DrawItem_canvas == null) DrawItem_canvas = new Bitmap(tRect.Width, tRect.Height);

                    using (var g2 = Graphics.FromImage(DrawItem_canvas))
                    {
                        g2.FillRectangle(BackColorBrush, 0, 0, tRect.Width, tRect.Height);

                        var tRect2 = new Rectangle(0, 0, tRect.Width, tRect.Height);

                        drawImageUnscaled(g2, image, tRect2.X, tRect2.Y);
                        if (ThumbnailPaint != null)
                        {
                            var e = new ThumbnailPaintEventArgs() { Graphics = g2, DataIndex = index, ThumbnailRectangle = tRect2 };
                            ThumbnailPaint(this, e);
                        }

                        if (!selected && unselectedItemMaskBrush != null)
                        {
                            g2.FillRectangle(unselectedItemMaskBrush, tRect2);
                        }
                    }
                    if (g == null)
                    {
                        gMustBeDisposed = true;
                        g = CreateGraphics();
                    }
                    g.DrawImageUnscaled(DrawItem_canvas, tRect.X, tRect.Y);
                }
                else
                {
                    var interSection = tRect;
                    interSection.Intersect(clipRectangle);
                    if (interSection.Width > 0 && interSection.Height > 0)
                    {
                        var dX = interSection.X - tRect.X;
                        var dY = interSection.Y - tRect.Y;

                        if (DrawItem_slicedCanvas != null && !(DrawItem_slicedCanvas.Width == interSection.Width && DrawItem_slicedCanvas.Height == interSection.Height))
                        {
                            DrawItem_slicedCanvas.Dispose();
                            DrawItem_slicedCanvas = null;
                        }

                        if (DrawItem_slicedCanvas == null) DrawItem_slicedCanvas = new Bitmap(interSection.Width, interSection.Height);

                        using (var g2 = Graphics.FromImage(DrawItem_slicedCanvas))
                        {
                            g2.FillRectangle(BackColorBrush, 0, 0, DrawItem_slicedCanvas.Width, DrawItem_slicedCanvas.Height);

                            var tRect2 = new Rectangle(-dX, -dY, tRect.Width, tRect.Height);

                            drawImageUnscaled(g2, image, tRect2.X, tRect2.Y);
                            if (ThumbnailPaint != null)
                            {
                                var e = new ThumbnailPaintEventArgs() { Graphics = g2, DataIndex = index, ThumbnailRectangle = tRect2 };
                                ThumbnailPaint(this, e);
                            }

                            if (!selected && unselectedItemMaskBrush != null)
                            {
                                g2.FillRectangle(unselectedItemMaskBrush, tRect2);
                            }

                        }

                        if (g == null)
                        {
                            gMustBeDisposed = true;
                            g = CreateGraphics();
                        }
                        g.DrawImageUnscaled(DrawItem_slicedCanvas, interSection.X, interSection.Y);
                    }
                }
            }
            if (g == null)
            {
                gMustBeDisposed = true;
                g = CreateGraphics();
            }
            drawFilledFrameGlobal(g, index, col, row, AutoScrollPositionY, tRect, selected, item?.Text);

            if (gMustBeDisposed) g.Dispose();

            // 枠ごと手動ダブルバッファリングする実装
            // 枠だけ描画する場合だけテキストを直接描画することになり
            // 外字のアンチエイリアスの一貫性が保たれなかったため廃止
            /*
            if (!onlyFrame)
            {
                var gRect = new Rectangle(col * gridSizeH, row * gridSizeV + this.AutoScrollPosition.Y, gridSizeH, gridSizeV);
                if (clipRectangle.IsEmpty)
                {
                    clipRectangle = ClientRectangle;
                }
                if (clipRectangle.Contains(gRect))
                {
                    if (DrawItem_canvas != null && !(DrawItem_canvas.Width == gridSizeH && DrawItem_canvas.Height == gridSizeV))
                    {
                        DrawItem_canvas.Dispose();
                        DrawItem_canvas = null;
                    }

                    if (DrawItem_canvas == null) DrawItem_canvas = new Bitmap(gridSizeH, gridSizeV);

                    using (var g2 = Graphics.FromImage(DrawItem_canvas))
                    {
                        g2.FillRectangle(BackColorBrush, 0, 0, gridSizeH, gridSizeV);

                        var tRect2 = getLocalThumbnailRectangle();

                        drawImageUnscaled(g2, image, tRect2.X, tRect2.Y);
                        if (ThumbnailPaint != null)
                        {
                            var e = new ThumbnailPaintEventArgs() { Graphics = g2, DataIndex = index, ThumbnailRectangle = tRect2 };
                            ThumbnailPaint(this, e);
                        }

                        if (!selected && unselectedItemMaskBrush != null)
                        {
                            g2.FillRectangle(unselectedItemMaskBrush, tRect2);
                        }
                        
                        // TextRenderer がグラフィックオブジェクトの種類によって描画方法を変え、主に外字で表示の一貫性がなくなる
                        //drawFilledFrameLocal(g2, index, col, row, 0, 0, tRect2, selected, item?.Text);
                    }

                    g.DrawImageUnscaled(DrawItem_canvas, col * gridSizeH, row * gridSizeV + this.AutoScrollPosition.Y);

                    drawFilledFrameGlobal(g, index, col, row, tRect, selected, item?.Text);
                }
                else
                {
                    var interSection = gRect;
                    interSection.Intersect(clipRectangle);
                    if (interSection.Width > 0 && interSection.Height > 0)
                    {
                        var dX = interSection.X - gRect.X;
                        var dY = interSection.Y - gRect.Y;

                        if (DrawItem_slicedCanvas != null && !(DrawItem_slicedCanvas.Width == interSection.Width && DrawItem_slicedCanvas.Height == interSection.Height))
                        {
                            DrawItem_slicedCanvas.Dispose();
                            DrawItem_slicedCanvas = null;
                        }

                        if (DrawItem_slicedCanvas == null) DrawItem_slicedCanvas = new Bitmap(interSection.Width, interSection.Height);

                        using (var g2 = Graphics.FromImage(DrawItem_slicedCanvas))
                        {
                            g2.FillRectangle(BackColorBrush, 0, 0, DrawItem_slicedCanvas.Width, DrawItem_slicedCanvas.Height);

                            var tRect2 = getLocalThumbnailRectangle();
                            tRect2.X -= dX;
                            tRect2.Y -= dY;

                            drawImageUnscaled(g2, image, tRect2.X, tRect2.Y);
                            if (ThumbnailPaint != null)
                            {
                                var e = new ThumbnailPaintEventArgs() { Graphics = g2, DataIndex = index, ThumbnailRectangle = tRect2 };
                                ThumbnailPaint(this, e);
                            }

                            if (!selected && unselectedItemMaskBrush != null)
                            {
                                g2.FillRectangle(unselectedItemMaskBrush, tRect2);
                            }

                            //drawFilledFrameLocal(g2, index, col, row, dX, dY, tRect2, selected, item?.Text);
                        }

                        g.DrawImageUnscaled(DrawItem_slicedCanvas, col * gridSizeH + dX, row * gridSizeV + dY + this.AutoScrollPosition.Y);

                        drawFilledFrameGlobal(g, index, col, row, tRect, selected, item?.Text);
                    }
                }
                
            }
            else
            {
                drawFilledFrameGlobal(g, index, col, row, tRect, selected, item?.Text);
            }
            */

        }

        // 指定されたインデックス番号の枠を表示／消去
        /*
        void drawFilledFrameLocal(Graphics g, int index, int col, int row, int dx, int dy, Rectangle thumbRect, bool draw, string text = null)
        {
            drawFilledFrame(g, index, col, row, -dx, -dy, thumbRect.X, thumbRect.Y, thumbRect.Width, thumbRect.Height, draw, text);
        }*/
        void drawFilledFrameGlobal(Graphics g, int index, int col, int row, int AutoScrollPositionY, Rectangle thumbRect, bool draw, string text = null)
        {
            drawFilledFrame(g, index, col, row, gridOffsetH + col * gridSizeH, row * gridSizeV + AutoScrollPositionY, thumbRect.X, thumbRect.Y, thumbRect.Width, thumbRect.Height, draw, text);
        }
        void drawFilledFrame(Graphics g, int index, int col, int row, Point gridLocation, Rectangle thumbRect, bool draw, string text = null)
        {
            drawFilledFrame(g, index, col, row, gridLocation.X, gridLocation.Y, thumbRect.X, thumbRect.Y, thumbRect.Width, thumbRect.Height, draw, text);
        }
        void drawFilledFrame(Graphics g, int index, int col, int row, int x0, int y0, int x, int y, int w, int h, bool draw, string text)
        {
            // x0 = col * gridSizeH;
            //y0 = row * gridSizeV + this.AutoScrollPosition.Y;
            var x1 = x0 + gridSizeH;
            var y1 = y0 + gridSizeV;

            var frameRectangles = new Rectangle[]
                {
                    new Rectangle(x0, y0, x - x0, y1 - y0),
                    new Rectangle(x + w, y0, x1 - x - w, y1 - y0),
                    new Rectangle(x, y0, w, y - y0),
                    new Rectangle(x, y + h, w, y1 - y - h)
                };

            // フレーム幅を固定しない方法
            if (draw)
            {
                Brush b = frameBrush;
                g.FillRectangles(b, frameRectangles);

                if (showText && text != null)
                {
                    var textRect = new Rectangle(x0 + bottomPadding, y + h + bottomPadding, gridSizeH - bottomPadding, y1 - (y + h) - bottomPadding); // 左も bottom でパディング、右はパディングしない
                    //TextRenderer.DrawText(g, text, Font, textRect, Color.Black, TextFormatFlags.NoPadding | TextFormatFlags.EndEllipsis);
                    //g.DrawString(text, Font, Brushes.Black, textRect, new StringFormat { Trimming = StringTrimming.EllipsisCharacter });
                    wrapAndEndAllipsis(g, text, DefaultFont, textRect, selectedForeColor, FrameColor);
                }
            }
            else
            {
                Brush b = backBrush;
                g.FillRectangles(b, frameRectangles);


                if (showText && text != null)
                {
                    var textRect = new Rectangle(x0 + bottomPadding, y + h + bottomPadding, gridSizeH - bottomPadding, y1 - (y + h) - bottomPadding); // 左も bottom でパディング、右はパディングしない
                    //TextRenderer.DrawText(g, text, Font, textRect, Color.Black, TextFormatFlags.NoPadding | TextFormatFlags.EndEllipsis);
                    //g.DrawString(text, Font, Brushes.Black, textRect, new StringFormat { Trimming = StringTrimming.EllipsisCharacter });
                    wrapAndEndAllipsis(g, text, DefaultFont, textRect, ForeColor, BackColor);
                }

                if (unselectedItemMaskBrush != null) g.FillRectangle(unselectedItemMaskBrush, new Rectangle(x0, y + h, gridSizeH, y1 - y - h));
            }


            // フレーム幅を固定する方法
            // ウインドウサイズのモジュロに依ってスキマができてしまう
            /*
            var frameWidth = Math.Min(Math.Min(Math.Min(x - x0, x1 - x - w), y - y0), y1 - y - h);
            if (draw)
            {
                Brush b = frameBrush;
                g.FillRectangles(b, new Rectangle[]
                {
                    new Rectangle(x - frameWidth, y - frameWidth, frameWidth, h + 2 * frameWidth),
                    new Rectangle(x + w,  y - frameWidth, frameWidth, h + 2 * frameWidth),
                    new Rectangle(x, y - frameWidth, w, frameWidth),
                    new Rectangle(x, y + h, w, frameWidth)
                });
            }
            else
            {
                using (Brush b = new SolidBrush(this.BackColor))
                {
                    g.FillRectangles(b, new Rectangle[]
                    {
                        new Rectangle(x - frameWidth, y - frameWidth, frameWidth, h + 2 * frameWidth),
                        new Rectangle(x + w,  y - frameWidth, frameWidth, h + 2 * frameWidth),
                        new Rectangle(x, y - frameWidth, w, frameWidth),
                        new Rectangle(x, y + h, w, frameWidth)
                    });
                }
            }
            */
        }

        private void wrapAndEndAllipsis(Graphics g, string text, Font font, Rectangle rect, Color foreColor, Color backColor)
        {
            var width = rect.Width;
            var first = true;
            var lineCount = 0;
            while (!string.IsNullOrEmpty(text))
            {
                lineCount++;
                var len = widthToStringLength(text, font, width);
                if (first && len == text.Length)
                {
                    TextRenderer.DrawText(g, text, font, rect, foreColor, backColor,
                        TextFormatFlags.NoPadding | TextFormatFlags.HorizontalCenter | TextFormatFlags.NoPrefix);
                    return;
                }
                first = false;
                var current = text.Substring(0, len);
                var currentHeight = TextRenderer.MeasureText(current, font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPrefix).Height;
                if (currentHeight * 2 + bottomPadding <= rect.Height)
                {
                    TextRenderer.DrawText(g, current, font, rect, foreColor, backColor, TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix);
                    text = text.Substring(len);
                    rect.Y += currentHeight + bottomPadding;
                    rect.Height -= currentHeight + bottomPadding;
                }
                else
                {
                    //TextRenderer.DrawText(g, text, font, rect, foreColor, TextFormatFlags.NoPadding | TextFormatFlags.EndEllipsis);
                    //DrawTextNoPaddingBaseNameEndEllipsis(g, text, font, rect, ForeColor);
                    TextRenderer.DrawText(g, GetTextBaseNameEndEllipsis(text, font, rect.Width, noPadding: true), font, rect, foreColor, backColor,
                        TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix | (lineCount == 1 ? TextFormatFlags.HorizontalCenter : 0));
                    return;
                }
            }
        }

        private int GetTextLines(string text)
        {
            // サムネイルサイズ設定後、updateRowsCols を呼び出す前に実行される可能性があるので
            // gridSizeH は自前で計算する必要あり

            // 現在の幅で決める方法
            /*
            if (this.ClientSize.Width <= 0) // 最小化時など
            {
                return 1;
            }

            var cols = this.ClientSize.Width / (thumbWidth + sidePadding * 2);
            if (cols == 0) cols = 1;

            var hUniformed = layoutMode == ThumbViewerAligningMode.TotallyUniformedGrid || layoutMode == ThumbViewerAligningMode.HorizontallyUniformedGrid;
            int gridSizeH;
            if (hUniformed)
            {
                gridSizeH = this.ClientSize.Width / cols;
            }
            else
            {
                gridSizeH = thumbWidth + sidePadding * 2;
            }
            */
            // 最悪のケースを想定する方法
            var gridSizeH = thumbWidth + 0 * 2;

            return GetTextLines(text, gridSizeH - bottomPadding);
        }

        private int GetTextLines(string text, int gridSizeH)
        {
            return GetTextLines(text, DefaultFont, gridSizeH - bottomPadding);
        }
        public static int GetTextLines(string text, Size thumbSize, int padding, int bottomPadding, ThumbViewerAligningMode align, Size screenSize)
        {
            // サムネイルサイズ設定後、updateRowsCols を呼び出す前に実行される可能性があるので
            // gridSizeH は自前で計算する必要あり
            /*
            if (screenSize.Width <= 0) // 最小化時など
            {
                return 0;
            }

            var cols = screenSize.Width / (thumbSize.Width + padding * 2);
            if (cols == 0) cols = 1;

            int gridSizeH;
            var hUniformed = align == ThumbViewerAligningMode.TotallyUniformedGrid || align == ThumbViewerAligningMode.HorizontallyUniformedGrid;
            if (hUniformed)
            {
                gridSizeH = screenSize.Width / cols;
            }
            else
            {
                gridSizeH = thumbSize.Width + padding * 2;
            }
            */

            // 最悪のケースを想定する方法
            var gridSizeH = thumbSize.Width + 0 * 2;

            return GetTextLines(text, DefaultFont, gridSizeH - bottomPadding);
        }
        private static int GetTextLines(string text, Font font, int width)
        {
            var first = true;
            var lineCount = 0;
            while (!string.IsNullOrEmpty(text))
            {
                lineCount++;
                var len = widthToStringLength(text, font, width);
                if (first && len == text.Length) break;
                first = false;
                var current = text.Substring(0, len);
                var currentHeight = TextRenderer.MeasureText(current, font, new Size(int.MaxValue, int.MinValue), TextFormatFlags.NoPrefix).Height;
                text = text.Substring(len);
            }
            return lineCount;
        }

        public static string GetTextBaseNameEndEllipsis(string text, Font font, int width, bool noPadding)
        {
            var f = (noPadding ? TextFormatFlags.NoPadding : 0) | TextFormatFlags.NoPrefix;

            var size = TextRenderer.MeasureText(text, font, new Size(int.MaxValue, int.MinValue), f);
            if (size.Width <= width)
            {
                return text;
            }

            string bas = null;
            string ext = null;
            for (var i = text.Length - 1; i >= 0; i--)
            {
                var c = text[i];
                if (c == '\\' || c == '/')
                {
                    if (i == text.Length - 1)
                    {
                        bas = text.Substring(0, i);
                        ext = text.Substring(i);
                    }
                    break;
                }
                if (c == '.')
                {
                    if (i < text.Length - 1)
                    {
                        bas = text.Substring(0, i);
                        ext = text.Substring(i + 1);
                    }
                    break;
                }
            }
            if (ext == null)
            {
                var dotsWidth = TextRenderer.MeasureText("...", font, new Size(int.MaxValue, int.MinValue), f).Width;
                return text.Substring(0, widthToStringLength(text, font, width - dotsWidth)) + "...";
            }
            ext = "..." + ext;
            var sizeExt = TextRenderer.MeasureText(ext, font, new Size(int.MaxValue, int.MinValue), f);
            var lenB = widthToStringLength(text, font, width - sizeExt.Width);
            return bas.Substring(0, lenB) + ext;
        }

        private static int widthToStringLength(string text, Font font, int width)
        {
            if (string.IsNullOrEmpty(text) || width <= 0) return 0;
            var a = 0;
            var c = text.Length;
            var b = c + 1;
            var preWidth = TextRenderer.MeasureText(text, font, new Size(int.MaxValue, int.MinValue),
                TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;
            while (a < b - 1)
            {
                c = c * width / preWidth;
                if (c <= a) c = a + 1; else if (c >= b) c = b - 1;
                preWidth = TextRenderer.MeasureText(text.Substring(0, c), font, new Size(int.MaxValue, int.MinValue),
                    TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width;
                if (preWidth <= width)
                {
                    a = c;
                }
                else
                {
                    b = c;
                }
            }
            return a;
        }

        private int widthToStringLength2(string text, Font font, int width)
        {
            var a = 0;
            var b = text.Length + 1;
            while (a < b - 1)
            {
                var c = (a + b) / 2;
                if (TextRenderer.MeasureText(text.Substring(0, c), font, new Size(int.MaxValue, int.MinValue),
                    TextFormatFlags.NoPadding | TextFormatFlags.NoPrefix).Width <= width)
                {
                    a = c;
                }
                else
                {
                    b = c;
                }
            }
            return a;
        }

        // グリッドの列数と行数を計算
        private int thumbWidthCurrent;
        public bool StopUpdateRowsCols = false;
        void updateRowsCols()
        {
            if (StopUpdateRowsCols) return;
            if (this.ClientSize.Width <= 0) // 最小化時など
            {
                return;
            }

            cols = this.ClientSize.Width / (thumbWidth + sidePadding * 2);
            if (cols == 0) cols = 1;

            var hUniformed = layoutMode == ThumbViewerAligningMode.TotallyUniformedGrid || layoutMode == ThumbViewerAligningMode.HorizontallyUniformedGrid;
            if (hUniformed)
            {
                gridSizeH = this.ClientSize.Width / cols;
            }
            else
            {
                gridSizeH = thumbWidth + sidePadding * 2;
            }

            rows = showIndexToDataIndex.Length / cols;
            if (showIndexToDataIndex.Length % cols > 0)
                rows++;

            if (thumbWidth > gridSizeH - sidePadding * 2)
            {
                thumbWidthCurrent = gridSizeH - sidePadding * 2;
            }
            else
            {
                thumbWidthCurrent = thumbWidth;
            }

            var frameWidth2 = hUniformed ? gridSizeH - thumbWidthCurrent : sidePadding * 2;

            thumbWidthCurrent = thumbWidth;

            //SetTextHeightFromSquareCharCount(16);
            SetTextHeight(refresh: false);

            if (layoutMode == ThumbViewerAligningMode.TotallyUniformedGrid)
            {
                if (showText)
                {
                    gridSizeV = frameWidth2 / 2 + Math.Max(textHeight + 2 * bottomPadding, (frameWidth2 + 1) / 2) + thumbHeight; // bottom が 2 つ

                }
                else
                {
                    gridSizeV = frameWidth2 + thumbHeight;
                }
            }
            else
            {
                if (showText)
                {
                    gridSizeV = topPadding + Math.Max(textHeight + 2 * bottomPadding, topPadding) + thumbHeight; // bottom が 2 つ

                }
                else
                {
                    gridSizeV = 2 * topPadding + thumbHeight;
                }
            }

            gridOffsetH = layoutMode == ThumbViewerAligningMode.LeftAlignedGrid ? 0 : (ClientSize.Width - cols * gridSizeH) / 2;

            // サムネイルの表示領域を設定
            AutoScrollMinSize = new Size(0, rows * gridSizeV);
        }

        public static int GetThumbnailCountInScreen(Size thumbSize, int padding, int bottomPadding, bool showText, int charHeight, int charCount, int textLines, ThumbViewerAligningMode align, Size screenSize)
        {
            if (screenSize.Width <= 0) // 最小化時など
            {
                return 0;
            }

            var cols = screenSize.Width / (thumbSize.Width + padding * 2);
            if (cols == 0) cols = 1;

            int gridSizeH;
            var hUniformed = align == ThumbViewerAligningMode.TotallyUniformedGrid || align == ThumbViewerAligningMode.HorizontallyUniformedGrid;
            if (hUniformed)
            {
                gridSizeH = screenSize.Width / cols;
            }
            else
            {
                gridSizeH = thumbSize.Width + padding * 2;
            }

            //var rows = showIndexToDataIndex.Length / cols;
            //if (showIndexToDataIndex.Length % cols > 0)
            //    rows++;

            int thumbWidthCurrent;
            if (thumbSize.Width > gridSizeH - padding * 2)
            {
                thumbWidthCurrent = gridSizeH - padding * 2;
            }
            else
            {
                thumbWidthCurrent = thumbSize.Width;
            }

            var frameWidth2 = hUniformed ? gridSizeH - thumbWidthCurrent : padding * 2;

            thumbWidthCurrent = thumbSize.Width;

            //SetTextHeightFromSquareCharCount(16);


            var w = gridSizeH - padding * 2;
            //const int charCount = 16;
            int textHeight;
            if (charCount > 0)
            {
                textHeight = (charCount * charHeight + w - 1) / w * (charHeight + bottomPadding) - bottomPadding; // top は使わない
            }
            else
            {
                textHeight = textLines * (charHeight + bottomPadding) - bottomPadding; // top は使わない
            }
            int gridSizeV;
            if (align == ThumbViewerAligningMode.TotallyUniformedGrid)
            {
                if (showText)
                {
                    gridSizeV = frameWidth2 / 2 + Math.Max(textHeight + 2 * bottomPadding, (frameWidth2 + 1) / 2) + thumbSize.Height; // bottom が 2 つ

                }
                else
                {
                    gridSizeV = frameWidth2 + thumbSize.Height;
                }
            }
            else
            {
                if (showText)
                {
                    gridSizeV = padding + Math.Max(textHeight + 2 * bottomPadding, padding) + thumbSize.Height; // bottom が 2 つ

                }
                else
                {
                    gridSizeV = 2 * padding + thumbSize.Height;
                }
            }

            return screenSize.Height / gridSizeV * cols;
        }

        /*
        void updateRowsCols()
        {
            if (this.ClientSize.Width <= 0)  // 最小化時など
            {
                return;
            }

            cols = this.ClientSize.Width / (thumbWidth + padding * 2);
            if (cols == 0)
                cols = 1;

            gridSizeH = this.ClientSize.Width / cols;

            rows = showIndexToDataIndex.Length / cols;
            if (showIndexToDataIndex.Length % cols > 0)
                rows++;

            if (thumbWidth > gridSizeH - padding * 2)
            {
                thumbWidthCurrent = gridSizeH - padding * 2;
            }
            else
            {
                thumbWidthCurrent = thumbWidth;
            }

            var frameWidth2 = gridSizeH - thumbWidthCurrent;

            thumbWidthCurrent = thumbWidth;

            SetTextHeightFromSquareCharCount(16);

            if (showText)
            {
                gridSizeV = frameWidth2 / 2 + Math.Max(textHeight + 2 * padding, (frameWidth2 + 1) / 2) + thumbHeight;

            }
            else
            {
                gridSizeV = frameWidth2 + thumbHeight;
            }

            // サムネイルの表示領域を設定
            AutoScrollMinSize = new Size(0, rows * gridSizeV);
        }
        */

        // 現在選択されているデータインデックス番号の取得（未選択時：-1）
        // set 時は範囲外のものを代入しようとするとエラーとはせず -1 を入れたものとみなされる
        public int SelectedIndex
        {
            get { return selectedIndices.Count == 1 ? selectedIndices[0] : -1; }
            set
            {
                var newSelected = value;

                //var drawCount = selectedIndices.Count;

                // サムネイルの存在しない場所がクリックされた場合
                if (newSelected < 0 || newSelected > items.Count - 1)
                {
                    if (selectedIndices.Any())
                    {
                        //if (drawCount == 1)
                        {
                            using (Graphics g = this.CreateGraphics())
                            {
                                foreach (var selected in selectedIndices)
                                {
                                    if (selected >= 0 && dataIndexToShowIndex != null && selected < dataIndexToShowIndex.Length)
                                    {
                                        DrawItem(g, selected, selected: false, onlyFrame: true);

                                        /*
                                        // 枠消去
                                        var index = dataIndexToShowIndex[selected];
                                        if (index < 0) return;
                                        int col2 = index % cols;
                                        int row2 = index / cols;
                                        var tRect = getThumbnailRectangle(col2, row2);

                                        drawFilledFrame(g, index, col2, row2, tRect, false);
                                        */
                                    }
                                }
                            }
                        }

                        var se = new SelectedIndexChangedEventArgs(SelectedIndex, -1);
                        ClearAllSelection();

                        //if (drawCount > 1) Invalidate();

                        SelectedIndexChanged?.Invoke(this, se);
                    }

                    return;
                }

                // 選択されているサムネイルを変更
                if (newSelected != SelectedIndex)
                {
                    //drawCount++;
                    //if (drawCount == 1)
                    {
                        using (Graphics g = CreateGraphics())
                        {
                            var needDrawSelection = true;
                            foreach (var selectedIndex in selectedIndices)
                            {
                                if (selectedIndex == newSelected)
                                {
                                    needDrawSelection = false;
                                }
                                else
                                {
                                    DrawItem(g, selectedIndex, selected: false, onlyFrame: true); // 枠のみ描画
                                }

                            }
                            if (needDrawSelection) DrawItem(g, newSelected, selected: true, onlyFrame: true); // 枠のみ描画
                        }
                    }


                    var se = new SelectedIndexChangedEventArgs(SelectedIndex, newSelected);
                    ClearAllSelection();
                    addSelection(newSelected);

                    /*
                    if (drawCount > 1) Invalidate();
                    else
                    {
                        using (Graphics g = CreateGraphics()) DrawItem(g, newSelected, selected: true, onlyFrame: true); // 枠のみ描画
                    }
                    */

                    SelectedIndexChanged?.Invoke(this, se);
                }
            }
        }

        public int FirstSelectedIndex
        {
            get
            {
                if (selectedIndices.Count == 0) return -1;
                var result = -1;
                var topShowIndex = showIndexToDataIndex.Length;
                foreach (var index in selectedIndices)
                {
                    var showIndex = dataIndexToShowIndex[index];
                    if (showIndex < topShowIndex)
                    {
                        topShowIndex = showIndex;
                        result = index;
                    }
                }
                return result;
            }
        }

        public int FirstDisplayedSelectedIndex
        {
            get
            {
                if (selectedIndices.Count == 0) return -1;
                var result = -1;
                var topShowIndex = showIndexToDataIndex.Length;
                var displayedStartShowIndex = DisplayedStartShowIndex;
                var displayedStopShowIndex = DisplayedStopShowIndex;
                foreach (var index in selectedIndices)
                {
                    var showIndex = dataIndexToShowIndex[index];
                    if (showIndex < topShowIndex && displayedStartShowIndex <= showIndex && showIndex < displayedStopShowIndex)
                    {
                        topShowIndex = showIndex;
                        result = index;
                    }
                }
                return result;
            }
        }

        public int FirstDisplayedSelectedShowIndex
        {
            get
            {
                if (selectedIndices.Count == 0) return -1;
                var topShowIndex = showIndexToDataIndex.Length;
                var displayedStartShowIndex = DisplayedStartShowIndex;
                var displayedStopShowIndex = DisplayedStopShowIndex;
                foreach (var index in selectedIndices)
                {
                    var showIndex = dataIndexToShowIndex[index];
                    if (showIndex < topShowIndex && displayedStartShowIndex <= showIndex && showIndex < displayedStopShowIndex)
                    {
                        topShowIndex = showIndex;
                    }
                }
                if (topShowIndex == showIndexToDataIndex.Length) return -1;
                return topShowIndex;
            }
        }

        public int SelectedIndicesCount
        {
            get
            {
                return selectedIndices.Count;
            }
        }

        public int[] SelectedIndices
        {
            get
            {
                return selectedIndices.ToArray();
            }
            set
            {
                if (value == null) value = new int[0];
                var oldSelectedIndex = SelectedIndex;
                //var selectedToNoselected = (from s in selectedIndices where !value.Contains(s) select s).ToArray();
                //var noselectedToSelected = (from s in value where !selectedIndices.Contains(s) select s).ToArray();
                GetChangeSelect(out var selectedToNoselected, out var noselectedToSelected, selectedIndices, value);
                var changed = selectedToNoselected.Any() || noselectedToSelected.Any();
                if (changed)
                {
                    changed = false;
                    using (Graphics g = this.CreateGraphics())
                    {
                        /*
                        foreach (var index in showIndexToDataIndex)
                        {
                            if (setSelectedWithoutEvent(index, value != null && value.Contains(index), selectedIndices.IndexOf(index), g))
                            {
                                changed = true;
                            }
                        }
                        */
                        foreach (var index in selectedToNoselected)
                        {
                            if (setSelectedWithoutEvent(index, false, selectedIndices.IndexOf(index), g)) changed = true;
                        }
                        foreach (var index in noselectedToSelected)
                        {
                            if (setSelectedWithoutEvent(index, true, selectedIndices.IndexOf(index), g)) changed = true;
                        }
                    }
                }
                //if (length > 1) Invalidate();
                if (changed)
                {
                    var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                    SelectedIndexChanged?.Invoke(this, se);
                }
            }
        }

        bool[] GetChangeSelect_Table = null;
        private void GetChangeSelect(out int[] selectedToNoselected, out int[] noselectedToSelected, IEnumerable<int> oldSelected, int[] newSelected, bool firstOutputRequired = true)
        {
            var tableSize = items.Count;
            {
                if (GetChangeSelect_Table == null || GetChangeSelect_Table.Length < tableSize)
                {
                    GetChangeSelect_Table = new bool[tableSize];
                }
                if (firstOutputRequired)
                {
                    foreach (var s in newSelected) GetChangeSelect_Table[s] = true;
                    selectedToNoselected = (from s in oldSelected where !GetChangeSelect_Table[s] select s).ToArray();
                    foreach (var s in newSelected) GetChangeSelect_Table[s] = false;
                }
                else
                {
                    selectedToNoselected = null;
                }

                foreach (var s in oldSelected) GetChangeSelect_Table[s] = true;
                noselectedToSelected = (from s in newSelected where !GetChangeSelect_Table[s] select s).ToArray();
                foreach (var s in oldSelected) GetChangeSelect_Table[s] = false;
            }
        }

        public bool setSelected(int index, bool selected, int indexOnIndices, Graphics graphics)
        {
            var oldSelectedIndex = SelectedIndex;
            if (setSelectedWithoutEvent(index, selected, indexOnIndices, graphics))
            {
                var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                SelectedIndexChanged?.Invoke(this, se);
                return true;
            }
            return false;
        }

        private bool setSelectedWithoutEvent(int index, bool selected, int indexOnIndices, Graphics graphics)
        {
            if (index < 0 || index > items.Count - 1) return false;
            var oldSelected = indexOnIndices >= 0;
            if (oldSelected && !selected)
            {

                var showIndex = dataIndexToShowIndex[index];
                if (showIndex >= 0)
                {
                    if (graphics == null)
                    {
                        using (Graphics g = this.CreateGraphics())
                        {
                            DrawItem(g, index, selected: false, onlyFrame: true);
                        }
                    }
                    else
                    {
                        DrawItem(graphics, index, selected: false, onlyFrame: true);
                    }
                }


                /*
                // 枠消去
                var showIndex = dataIndexToShowIndex[index];
                if (showIndex >= 0)
                {
                    int col2 = showIndex % cols;
                    int row2 = showIndex / cols;
                    var tRect = getThumbnailRectangle(col2, row2);

                    using (Graphics g = this.CreateGraphics())
                    {
                        drawFilledFrame(g, showIndex, col2, row2, tRect, false);
                    }
                }
                */

                removeSelectionAt(indexOnIndices);

                return true;
            }
            else if (!oldSelected && selected)
            {
                if (graphics == null)
                {
                    using (Graphics g = this.CreateGraphics())
                    {
                        DrawItem(g, index, selected: true, onlyFrame: true); // 枠のみ描画
                    }
                }
                else
                {
                    DrawItem(graphics, index, selected: true, onlyFrame: true); // 枠のみ描画
                }

                addSelection(index);

                return true;
            }
            else return false;
        }

        public int PointToIndex(Point clientPoint)
        {
            var showIndex = PointToShowIndex(clientPoint, getNearestIndex: false);
            return showIndex >= 0 ? showIndexToDataIndex[showIndex] : -1;
        }

        public Rectangle PointToContainerGridRectangle(Point clientPoint, bool cutOverflow)
        {
            if (!ClientRectangle.Contains(clientPoint)) return Rectangle.Empty;
            int col2 = Math.Max(0, Math.Min(cols - 1, (clientPoint.X - gridOffsetH) / gridSizeH));
            int row2 = (clientPoint.Y - AutoScrollPosition.Y) / gridSizeV;
            return getGridRectangle(col2, row2, cutOverflow);
        }

        public Rectangle PointToContainerImageRectangle(Point clientPoint)
        {
            if (!ClientRectangle.Contains(clientPoint)) return Rectangle.Empty;
            int col2 = Math.Max(0, Math.Min(cols - 1, (clientPoint.X - gridOffsetH) / gridSizeH));
            int row2 = (clientPoint.Y - AutoScrollPosition.Y) / gridSizeV;
            return getThumbnailRectangle(col2, row2, AutoScrollPosition.Y);
            /*
            int x = col2 * gridSizeH + (gridSizeH - thumbWidthCurrent) / 2;
            int y = row2 * gridSizeV + (gridSizeV - thumbHeight) / 2 + AutoScrollPosition.Y;
            int w = thumbWidthCurrent;
            int h = thumbHeight;
            return new Rectangle(x, y, w, h);
            */
        }

        public Rectangle IndexToContainerImageRectangle(int dataIndex)
        {
            if (dataIndex >= dataIndexToShowIndex.Length) return Rectangle.Empty;
            var showIndex = dataIndexToShowIndex[dataIndex];
            int col2 = showIndex % cols;
            int row2 = showIndex / cols;
            return getThumbnailRectangle(col2, row2, AutoScrollPosition.Y);
            /*
            int x = col2 * gridSizeH + (gridSizeH - thumbWidthCurrent) / 2;
            int y = row2 * gridSizeV + (gridSizeV - thumbHeight) / 2 + AutoScrollPosition.Y;
            int w = thumbWidthCurrent;
            int h = thumbHeight;
            return new Rectangle(x, y, w, h);
            */
        }

        private int PointToShowIndex(Point clientPoint, bool getNearestIndex)
        {
            if (!getNearestIndex && !ClientRectangle.Contains(clientPoint)) return -1;

            var slen = showIndexToDataIndex.Length;
            if (slen <= 0) return -1;
            var rows = (slen - 1) / cols + 1;

            int colNum = clientPoint.X - gridOffsetH;
            if (colNum < 0)
            {
                if (getNearestIndex)
                {
                    colNum = 0;
                }
                else
                {
                    return -1;
                }
            }
            int col = colNum / gridSizeH;
            if (col >= cols)
            {
                if (getNearestIndex)
                {
                    col = cols - 1;
                }
                else
                {
                    return -1;
                }
            }
            int row = (clientPoint.Y - AutoScrollPosition.Y) / gridSizeV;
            if (row < 0)
            {
                if (getNearestIndex)
                {
                    row = 0;
                }
                else
                {
                    return -1;
                }
            }
            else if (row >= rows)
            {
                if (getNearestIndex)
                {
                    row = rows - 1;
                }
                else
                {
                    return -1;
                }
            }
            var showIndex = row * cols + col; // 負にはならない
            if (showIndex < 0)
            {
                return -1; // ここへの到達は想定されない
            }
            else if (showIndex >= slen)
            {
                if (getNearestIndex)
                {
                    showIndex -= cols;
                    if (showIndex < 0) return slen - 1; // 一行に満たない場合
                    else if (showIndex < slen) return showIndex; // 上と左があれば常に上を選択
                    else return -1; // ここへの到達は想定されない
                }
                else
                {
                    return -1;
                }
            }
            else return showIndex;
        }

        public int FullDisplayedStartShowIndex
        {
            get
            {
                int rowStart = (-AutoScrollPosition.Y + gridSizeV - 1) / gridSizeV;
                return rowStart * cols;
            }
        }

        public int FullDisplayedStopShowIndex
        {
            get
            {
                int rowEnd = (-AutoScrollPosition.Y + Height - gridSizeV + 1) / gridSizeV + 1;
                return Math.Min(rowEnd * cols, showIndexToDataIndex.Length);
            }
        }

        public int DisplayedStartShowIndex
        {
            get
            {
                int rowStart = (-AutoScrollPosition.Y) / gridSizeV;
                return rowStart * cols;
            }
        }

        public int DisplayedStopShowIndex
        {
            get
            {
                int rowEnd = (-AutoScrollPosition.Y + Height) / gridSizeV + 1;
                return Math.Min(rowEnd * cols, showIndexToDataIndex.Length);
            }
        }

        // サムネイルを描画するサイズの設定と取得
        public int ThumbnailWidth
        {
            get { return thumbWidth; }
            set
            {
                thumbWidth = value;

                if (showIndexToDataIndex.Length == 0)
                    return;

                updateRowsCols();
                Invalidate();
            }
        }

        // サムネイルを描画するサイズの設定と取得
        public int ThumbnailHeight
        {
            get { return thumbHeight; }
            set
            {
                thumbHeight = value;

                if (showIndexToDataIndex.Length == 0)
                    return;

                updateRowsCols();
                Invalidate();
            }
        }

        // サムネイルを描画するサイズの設定と取得
        public Size ThumbnailSize
        {
            get { return new Size(thumbWidth, thumbHeight); }
            set
            {
                thumbWidth = value.Width;
                thumbHeight = value.Height;

                if (showIndexToDataIndex.Length == 0)
                    return;

                updateRowsCols();
                Invalidate();
            }
        }

        public bool ShowText
        {
            get { return showText; }
            set
            {
                showText = value;

                if (showIndexToDataIndex.Length == 0)
                    return;

                updateRowsCols();
                Invalidate();
            }
        }

        private int textLines = 0;
        public void SetTextLines(int textLines, bool refresh)
        {
            if (this.textLines != textLines || textLength != 0)
            {
                this.textLines = textLines;
                textLength = 0;
                SetTextHeightFromLines(refresh);
            }
        }

        public void SetTextLinesFromText(string text, bool refresh)
        {
            SetTextLines(Math.Max(1, GetTextLines(text)), refresh);
        }

        private int textLength = 16;
        public void SetTextLength(int textLength, bool refresh)
        {
            if (textLength != this.textLength || textLines != 0)
            {
                this.textLength = textLength;
                textLines = 0;
                SetTextHeightFromSquareCharCount(refresh);
            }
        }

        private void SetTextHeightFromLines(bool refresh)
        {
            var charHeight = GetCharHeight();
            var newHeight = GetTextHeightFromLines(textLines); // top は使わない
            if (textHeight != newHeight)
            {
                textHeight = newHeight;
                if (refresh)
                {
                    updateRowsCols();
                    Invalidate();
                }
            }
        }

        private bool SetTextHeightFromSquareCharCount_CharHeightNotSet = true;
        private int SetTextHeightFromSquareCharCount_CharHeight;
        public int GetCharHeight()
        {
            if (SetTextHeightFromSquareCharCount_CharHeightNotSet)
            {
                SetTextHeightFromSquareCharCount_CharHeightNotSet = false;
                SetTextHeightFromSquareCharCount_CharHeight = TextRenderer.MeasureText(".", DefaultFont).Height;
            }
            return SetTextHeightFromSquareCharCount_CharHeight;
        }
        private void SetTextHeightFromSquareCharCount(bool refresh)
        {
            var oldHeight = textHeight;
            textHeight = GetTextHeightFromSquareCharCount(textLength);
            if (refresh && oldHeight != textHeight)
            {
                updateRowsCols();
                Invalidate();
            }
        }

        private void SetTextHeight(bool refresh)
        {
            if (textLength > 0)
            {
                SetTextHeightFromSquareCharCount(refresh);
            }
            else
            {
                SetTextHeightFromLines(refresh);
            }
        }

        /*
        private static int GetTextHeight(int gridSizeH, int textLength, int textLines)
        {
            if (textLength > 0)
            {
                return GetTextHeightFromSquareCharCount(gridSizeH, textLength);
            }
            else
            {
                return GetTextHeightFromLines(textLines);
            }
        }
        */

        private int GetTextHeightFromSquareCharCount(int charCount)
        {
            var charHeight = GetCharHeight();
            var w = gridSizeH - sidePadding * 2;
            return (charCount * charHeight + w - 1) / w * (charHeight + bottomPadding) - bottomPadding; // top は使わない
        }

        private int GetTextHeightFromLines(int textLines)
        {
            var charHeight = GetCharHeight();
            return textLines * (charHeight + bottomPadding) - bottomPadding; // top は使わない
        }


        // サムネイル画像と画面のクリア
        bool Clearing = false;
        public void Clear(int initialImageCount, int initialSelectedIndex, double initialScroolbarPercentage, int[] showIndexToDataIndex, int tWidth, int tHeight, int tPadding)
        {
            //var sw = new Stopwatch();
            //var ss = "";
            //sw.Restart();

            Clearing = true;
            var imagesCount = items.Count;
            for (var i = 0; i < imagesCount; i++)
            {
                var item = items[i];
                if (item != null)
                {
                    item.Dispose();
                    items[i] = null;
                }
            }

            //sw.Stop(); ss += $"disEnd\t{sw.Elapsed}\n"; sw.Restart();

            Refresh();
            items.Clear();
            focusedIndex = -1;
            SelectedIndexChangedEventArgs se = null;
            if (selectedIndices.Count > 0)
            {
                se = new SelectedIndexChangedEventArgs(SelectedIndex, -1);
                //ClearAllSelection();
                selectedIndices.Clear(); // items はクリア済みで item.Index を変える必要がなく、また変えようとすると IndexOutOfRangeExeption
            }
            dataIndexToShowIndex = new int[initialImageCount];
            this.showIndexToDataIndex = showIndexToDataIndex;
            for (var i = 0; i < initialImageCount; i++)
            {
                items.Add(null);
                dataIndexToShowIndex[i] = -1;
            }
            //sw.Stop(); ss += $"pred2sEnd\t{sw.Elapsed}\n"; sw.Restart();
            for (var i = 0; i < showIndexToDataIndex.Length; i++)
            {
                dataIndexToShowIndex[showIndexToDataIndex[i]] = i;
            }
            //sw.Stop(); ss += $"d2sEnd\t{sw.Elapsed}\n"; sw.Restart();

            thumbWidth = tWidth;
            thumbHeight = tHeight;
            topPadding = sidePadding = tPadding;
            if (0 <= initialSelectedIndex && initialSelectedIndex < initialImageCount)
            {
                if (se == null) se = new SelectedIndexChangedEventArgs(SelectedIndex, -1);
                else se = new SelectedIndexChangedEventArgs(se.OldIndex, initialSelectedIndex);
                //ClearAllSelection();
                addSelection(initialSelectedIndex);
            }

            if (se != null) SelectedIndexChanged?.Invoke(this, se);

            updateRowsCols();

            setScrollBarPercentage(initialScroolbarPercentage);

            Invalidate();

            Clearing = false;

            //sw.Stop(); ss += $"evStart\t{sw.Elapsed}\n"; sw.Restart();
            ShowIndexToDataIndexChanged?.Invoke(this, null);

            //sw.Stop(); ss += $"fin\t{sw.Elapsed}\n";
            //MessageBox.Show(ss);
        }

        Form ownerForm = null;
        FormWindowState prevFormWindowState = FormWindowState.Normal;
        protected override void OnSizeChanged(EventArgs e)
        {
            base.OnSizeChanged(e);

            if (ownerForm == null)
            {
                ownerForm = FindForm();
            }
            var correctPosition = false;
            if (ownerForm != null)
            {
                var formWindowState = ownerForm.WindowState;
                correctPosition = formWindowState != FormWindowState.Minimized && prevFormWindowState != FormWindowState.Minimized;
                prevFormWindowState = formWindowState;
            }

            setScrollBarPercentage(scrollBarPercentage);
        }

        double OnPaint_VerticalScrollTop = 0;
        double OnPaint_VerticalScrollBottom = 0;
        double OnPaint_VerticalScrollVal = 0;
        protected override void OnPaint(PaintEventArgs e)
        {
            if (Clearing) return;

            var top = VerticalScroll.Minimum;
            var bottom = VerticalScroll.Maximum;
            var val = VerticalScroll.Value;
            var fullHeight = bottom - top;
            var changed = fullHeight > 0 && (OnPaint_VerticalScrollTop != top || OnPaint_VerticalScrollBottom != bottom || OnPaint_VerticalScrollVal != val);
            OnPaint_VerticalScrollTop = top;
            OnPaint_VerticalScrollBottom = bottom;
            OnPaint_VerticalScrollVal = val;
            setScrollBarPercentageOnPaint(Height, top, val, fullHeight);

            if (changed) DisplayedChanged?.Invoke(this, null);

            base.OnPaint(e);

            var sub = tryRenderWithPrerender(e.Graphics, e.ClipRectangle, AutoScrollPosition.Y);
            if (!sub.IsEmpty)
            {
                PaintPart(e.Graphics, sub, AutoScrollPosition.Y);
            }
        }

        private void PaintPart(Graphics g, Rectangle clipRectangle, int autoScrollPositionY)
        {
            int rowStart = (-autoScrollPositionY + clipRectangle.Y) / gridSizeV;
            int rowEnd = (-autoScrollPositionY + clipRectangle.Y + clipRectangle.Height) / gridSizeV + 1;

            for (int i = rowStart * cols; i < Math.Min(rowEnd * cols, showIndexToDataIndex.Length); i++)
            {
                var dataIndex = ShowIndexToDataIndex[i];

                var selected = selectedIndices.Contains(dataIndex);
                DrawItem(g, dataIndex, selected, alreadyCheckedVisibleRegion: true, clipRectangle: clipRectangle, AutoScrollPositionY: autoScrollPositionY);
            }
        }

        private int scrollByFloorGrid(MouseEventArgs e, int line)
        {
            var i = getScrollCount(e) * line;
            if (i > 0)
            {
                return (-AutoScrollPosition.Y + Height) / gridSizeV * gridSizeV - Height + i * gridSizeV;
            }
            else if (i < 0)
            {
                return (-AutoScrollPosition.Y - 1) / gridSizeV * gridSizeV + (i + 1) * gridSizeV;
            }
            else return -AutoScrollPosition.Y;
        }

        private int scrollByAbsolutePixel(MouseEventArgs e, int amount)
        {
            return -AutoScrollPosition.Y - e.Delta * amount / 120;
        }

        private static int getScrollCount(MouseEventArgs e)
        {
            var delta = -e.Delta;
            if (delta == 0) return 0;
            if (delta > 0) return (delta + 119) / 120;
            return -((-delta + 119) / 120);
        }

        private Bitmap preRenderScroll_Canvas;
        private Bitmap preRenderScroll_Canvas030;
        private Bitmap preRenderScroll_Canvas060;
        private Bitmap preRenderScroll_Canvas120;
        private Bitmap preRenderScroll_Canvas240;
        private Bitmap preRenderScroll_Canvas480;
        private Rectangle preRenderScroll_ClipRectangle;
        private int preRenderScroll_AutoScrollPositionY = int.MinValue;
        private void preRenderScroll(int newY, int preRenderHeightUBound)
        {
            var oldY = -AutoScrollPosition.Y;

            if (newY < 0) newY = 0;
            else
            {
                // 複数のサイズ（偶数と奇数を含む）で確認済み
                var AutoScrollPositionYAbsMaxValue = VerticalScroll.Maximum - Height + 1;
                if (newY > AutoScrollPositionYAbsMaxValue) newY = AutoScrollPositionYAbsMaxValue;
            }

            var d = newY - oldY;
            if (d == 0)
            {
                return;
            }

            var w = Width;
            var h = Math.Abs(d);
            if (preRenderHeightUBound > 480) preRenderHeightUBound = 480;
            if (h <= preRenderHeightUBound && preRenderScroll_AutoScrollPositionY == int.MinValue)
            {
                Bitmap canvas;
                if (h <= 30)
                {
                    preRenderScroll_Canvas030 = UpdateCanvas(preRenderScroll_Canvas030, w, h);
                    canvas = preRenderScroll_Canvas030;
                }
                else if (h <= 60)
                {
                    preRenderScroll_Canvas060 = UpdateCanvas(preRenderScroll_Canvas060, w, h);
                    canvas = preRenderScroll_Canvas060;
                }
                else if (h <= 120)
                {
                    preRenderScroll_Canvas120 = UpdateCanvas(preRenderScroll_Canvas120, w, h);
                    canvas = preRenderScroll_Canvas120;
                }
                else if (h <= 240)
                {
                    preRenderScroll_Canvas240 = UpdateCanvas(preRenderScroll_Canvas240, w, h);
                    canvas = preRenderScroll_Canvas240;
                }
                else
                {
                    preRenderScroll_Canvas480 = UpdateCanvas(preRenderScroll_Canvas480, w, h);
                    canvas = preRenderScroll_Canvas480;
                }


                if (d > 0)
                {
                    var o = Height - h;
                    preRenderScroll_ClipRectangle = new Rectangle(0, o, w, h);
                    var oClip = preRenderScroll_ClipRectangle;
                    oClip.Y = 0;
                    using (var g = Graphics.FromImage(canvas))
                    {
                        g.FillRectangle(backBrush, oClip);
                        PaintPart(g, oClip, -newY - o);
                    }
                }
                else
                {
                    preRenderScroll_ClipRectangle = new Rectangle(0, 0, w, h);
                    using (var g = Graphics.FromImage(canvas))
                    {
                        g.FillRectangle(backBrush, preRenderScroll_ClipRectangle);
                        PaintPart(g, preRenderScroll_ClipRectangle, -newY);
                    }
                }

                preRenderScroll_Canvas = canvas;
                preRenderScroll_AutoScrollPositionY = -newY;
            }

            AutoScrollPosition = new Point(-AutoScrollPosition.X, newY);

        }

        private Rectangle tryRenderWithPrerender(Graphics g, Rectangle clipRectangle, int autoScrollPositionY)
        {
            if (preRenderScroll_AutoScrollPositionY == int.MinValue)
            {
                return clipRectangle;
            }
            var dstAbs = new Rectangle(clipRectangle.X, clipRectangle.Y - autoScrollPositionY, clipRectangle.Width, clipRectangle.Height);
            var srcAbs = new Rectangle(preRenderScroll_ClipRectangle.X, preRenderScroll_ClipRectangle.Y - preRenderScroll_AutoScrollPositionY, preRenderScroll_ClipRectangle.Width, preRenderScroll_ClipRectangle.Height);
            Rectangle sub;
            if (srcAbs.Contains(dstAbs)) sub = Rectangle.Empty;
            else
            {
                sub = Substruct(dstAbs, srcAbs);
                if (sub.IsEmpty)
                {
                    preRenderScroll_AutoScrollPositionY = int.MinValue;
                    return clipRectangle;
                }
            }
            var intersect = dstAbs;
            intersect.Intersect(srcAbs);
            var dstRect = new Rectangle(intersect.X, intersect.Y + autoScrollPositionY, intersect.Width, intersect.Height);
            var srcRect = new Rectangle(intersect.X - preRenderScroll_ClipRectangle.X, intersect.Y - preRenderScroll_ClipRectangle.Y + preRenderScroll_AutoScrollPositionY, intersect.Width, intersect.Height);
            var temp = g.InterpolationMode;
            g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;
            g.DrawImage(preRenderScroll_Canvas, dstRect, srcRect, GraphicsUnit.Pixel);
            //g.FillRectangle(Brushes.Black, dstRect);
            g.InterpolationMode = temp;
            preRenderScroll_AutoScrollPositionY = int.MinValue;
            if (!sub.IsEmpty) sub.Y += autoScrollPositionY;
            return sub;
        }

        // 差が長方形の場合のみそれを返す。さもなければ Empty
        // ただし必要な分しか実装していないので他の用途には使わないこと
        public static Rectangle Substruct(Rectangle rect, Rectangle other)
        {
            if (rect.Left < other.Left || rect.Right > other.Right) return Rectangle.Empty;
            if (rect.Top < other.Top)
            {
                if (rect.Bottom <= other.Bottom)
                {
                    rect.Height = other.Top - rect.Top;
                    return rect;
                }
                else return Rectangle.Empty;
            }
            else if (rect.Bottom > other.Bottom)
            {
                rect.Height = rect.Bottom - other.Bottom;
                rect.Y = other.Bottom;
                return rect;
            }
            else return Rectangle.Empty;
        }

        private static Bitmap UpdateCanvas(Bitmap bmp, int width, int height)
        {
            var bmpn = bmp == null;
            if (bmpn || bmp.Width < width || bmp.Height < height)
            {
                var w = bmpn ? width : Math.Max(bmp.Width, width);
                var h = bmpn ? height : Math.Max(bmp.Height, height);
                bmp?.Dispose();
                return new Bitmap(w, h);
            }
            else return bmp;
        }

        protected override void OnMouseWheel(MouseEventArgs e)
        {
            //GuiUtil.BeginUpdate(this);
            //base.OnMouseWheel(e);

            switch (MouseWheelScrollUnit)
            {
                case ThumbViewerScrollUnit.AbsolutePixel:
                    preRenderScroll(scrollByAbsolutePixel(e, MouseWheelScrollAmount), preRenderHeightUBound: MouseWheelScrollAmount);
                    break;
                case ThumbViewerScrollUnit.GridCeiling:
                    preRenderScroll(scrollByFloorGrid(e, MouseWheelScrollAmount), preRenderHeightUBound: gridSizeV); // 天井の値が指定されてるならその床が移動量
                    break;
            }

            // スクロール量実験
            // → 結果、DPI にかかわらず e.Delta の単位は 120 で、
            // OnMouseWheel はその数をそのままスクロール量漁に使うと判明
            /*
            preRenderScroll(-AutoScrollPosition.Y +Math.Abs(e.Delta));
            base.OnMouseWheel(e);
            if(e.X < 30)
            {
                MessageBox.Show(e.Delta.ToString());
            }
            */

            //scrollByGrid(-e.Delta / 120);
            //GuiUtil.EndUpdate(this);
            if (0 <= mouseDownShowIndex && showIndexToDataIndex != null && mouseDownShowIndex < showIndexToDataIndex.Length)
            {
                var clientPosition = PointToClient(Cursor.Position);
                var e2 = new MouseEventArgs(MouseButtons.None, 0, clientPosition.X, clientPosition.Y, 0);
                OnMouseMove(e2);
            }
        }

        /*
        [System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        public const int WM_SETREDRAW = 0x000B;

        /// <summary>
        /// コントロール(子コントロールも含む)の描画を停止します。
        /// </summary>
        /// <param name="control">対象コントロール</param>
        public static void BeginUpdate(Control control)
        {
            SendMessage(control.Handle, WM_SETREDRAW, 0, 0);
        }

        /// <summary>
        /// コントロール(子コントロールも含む)の描画を開始します。
        /// </summary>
        /// <param name="control">対象コントロール</param>
        public static void EndUpdate(Control control)
        {
            SendMessage(control.Handle, WM_SETREDRAW, 1, 0);
            control.Refresh();
        }
        */

        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);

            updateRowsCols();
            Invalidate();
        }

        public int SelectedIndexDelay { get; private set; }

        private int focusedIndex = -1;
        public int FocusedIndex
        {
            get
            {
                if (0 <= focusedIndex && focusedIndex < items.Count)
                {
                    return focusedIndex;
                }
                else
                {
                    return -1;
                }
            }
            set
            {
                focusedIndex = value;
                focusedIndex = FocusedIndex;
            }
        }

        public MouseButtons SubMouseButtons = MouseButtons.Middle | MouseButtons.Right;

        public Func<Keys> GetModifierKeys;
        private new Keys ModifierKeys
        {
            get
            {
                return GetModifierKeys == null ? Control.ModifierKeys : GetModifierKeys();
            }
        }

        public bool DragOutSelection = false;
        public bool DragOutSingle = false;


        private int mouseDownShowIndex = -1;
        private Rectangle OnMouseDown_DragOutStartRectangle = Rectangle.Empty;
        private int OnMouseDown_DragOutStartIndex = -1;
        protected override void OnMouseDown(MouseEventArgs e)
        {
            /*
            int col = (e.X - gridOffsetH) / gridSizeH;
            int row = (e.Y - this.AutoScrollPosition.Y) / gridSizeV;


            var showIndex = col < 0 || col >= cols ? -1 : row * cols + col;
            int newSelected = showIndex < 0 || showIndex >= showIndexToDataIndex.Length ? -1 : showIndexToDataIndex[showIndex];
            */
            int newSelected = PointToIndex(e.Location);

            var indexOnIndices = newSelected < 0 ? -1 : selectedIndices.IndexOf(newSelected);
            var alreadySelected = indexOnIndices >= 0;

            if (!DragOutSelection || !alreadySelected || !(e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
            {
                SelectedIndexDelay = SelectedIndex;

                if (e.Button == MouseButtons.Left || ((e.Button & SubMouseButtons) != 0 &&  //(e.Button != MouseButtons.XButton1 && e.Button != MouseButtons.XButton2 &&
                    indexOnIndices < 0))
                //if (e.Button == MouseButtons.Left || (e.Button == MouseButtons.Right && !selectedIndices.Contains(newSelected)))
                {
                    var modifierKeys = ModifierKeys;
                    var focusShouldBeChanged = true;
                    if (modifierKeys == Keys.Control && e.Button == MouseButtons.Left)
                    {
                        if (indexOnIndices < 0)
                        {
                            var focused = FocusedIndex;
                            var showFocused = focused >= 0 ? dataIndexToShowIndex[focused] : -1;
                            var showNew = newSelected >= 0 ? dataIndexToShowIndex[newSelected] : -1;

                            setSelected(newSelected, true, -1, graphics: null);

                            if (e.Button == MouseButtons.Left)
                            {
                                mouseDownShowIndex = showNew;
                                OnMouseMove_PrevMousePoint = e.Location;
                            }
                        }
                        else
                        {
                            setSelected(newSelected, false, indexOnIndices, graphics: null);
                        }
                    }
                    else
                    {
                        var focused = FocusedIndex;
                        var showFocused = focused >= 0 ? dataIndexToShowIndex[focused] : -1;
                        var showNew = newSelected >= 0 ? dataIndexToShowIndex[newSelected] : -1;
                        if (showFocused >= 0 && showNew >= 0 && (modifierKeys & Keys.Shift) == Keys.Shift)
                        {
                            focusShouldBeChanged = selectedIndices.Count == 0;

                            var oldSelectedIndex = SelectedIndex;
                            var minShow = Math.Min(showFocused, showNew);
                            var maxShow = Math.Max(showFocused, showNew);
                            var clear = (modifierKeys & Keys.Control) != Keys.Control;

                            //var drawCount = (clear ? selectedIndices.Count : 0) + maxShow - minShow + 1;
                            //var drawSingle = drawCount == 1;
                            var newSelecedIndices = new int[maxShow - minShow + 1];
                            for (var i = minShow; i <= maxShow; i++) newSelecedIndices[i - minShow] = showIndexToDataIndex[i];
                            //var selectedToNoselected = clear ? (from s in selectedIndices where !newSelecedIndices.Contains(s) select s).ToArray() : null;
                            //var noselectedToSelected = (from s in newSelecedIndices where !selectedIndices.Contains(s) select s).ToArray();
                            GetChangeSelect(out var selectedToNoselected, out var noselectedToSelected, selectedIndices, newSelecedIndices, firstOutputRequired: clear);
                            if (clear && selectedToNoselected.Any() || noselectedToSelected.Any())
                            {
                                using (Graphics g = this.CreateGraphics())
                                {
                                    if (clear)
                                    {
                                        foreach (var index in selectedToNoselected)
                                        {
                                            setSelectedWithoutEvent(index, false, selectedIndices.IndexOf(index), g);
                                        }
                                    }

                                    foreach (var dataIndex in noselectedToSelected)
                                    {
                                        //var dataIndex = showIndexToDataIndex[i];
                                        setSelectedWithoutEvent(dataIndex, true, selectedIndices.IndexOf(dataIndex), g);
                                    }
                                }
                            }

                            //if (drawCount > 1) Invalidate();

                            var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                            SelectedIndexChanged?.Invoke(this, se);
                        }
                        else
                        {
                            SelectedIndex = newSelected; // ここはフィールドへの代入ではなくプロパティーへの代入でなければならない
                        }
                        if (e.Button == MouseButtons.Left)
                        {
                            mouseDownShowIndex = showNew;
                            OnMouseMove_PrevMousePoint = e.Location;
                        }
                    }
                    if (focusShouldBeChanged) focusedIndex = newSelected;
                }

                // インデックス変更後にイベント・ハンドラが呼び出されるようにする
                var e2 = new HandlableMouseEventArgs(e);
                base.OnMouseDown(e2);

                if (DragOutSingle && !alreadySelected && !e2.Handled)
                {
                    if (e.Button == MouseButtons.Left)
                    {
                        // 領域を出るまでは複数選択
                        OnMouseDown_DragOutStartIndex = newSelected;
                    }
                    else
                    {
                        // 初めからドラッグ
                        OnMouseDown_DragOutStartRectangle = PointToContainerGridRectangle(e.Location, cutOverflow: true);
                    }
                }

                SelectedIndexDelay = SelectedIndex;
            }
            else
            {
                var e2 = new HandlableMouseEventArgs(e);
                SelectedIndexDelay = SelectedIndex;
                base.OnMouseDown(e2);
                if (!e2.Handled)
                {
                    //OnMouseDown_DragOutStartRectangle = GetRectangleWithCenter(e.Location, SystemInformation.DragSize);
                    OnMouseDown_DragOutStartRectangle = PointToContainerGridRectangle(e.Location, cutOverflow: true);
                }
            }
        }

        private static Rectangle GetRectangleWithCenter(Point center, Size size)
        {
            var w = size.Width;
            var h = size.Height;
            return new Rectangle(center.X - w / 2, center.Y - h / 2, w, h);
        }

        private HashSet<int> selectedIndexByDrag = null;
        private Point OnMouseMove_PrevMousePoint = Point.Empty;
        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (OnMouseDown_DragOutStartIndex >= 0 && !ActivateManager.InVisibleRegion(this, e.Location)) //!ClientRectangle.Contains(e.Location))
            {
                mouseDownShowIndex = -1;
                selectedIndexByDrag = null;
                OnMouseMove_PrevMousePoint = Point.Empty;

                var d2s = dataIndexToShowIndex;
                if (d2s.Length > OnMouseDown_DragOutStartIndex)
                {
                    SelectedIndex = OnMouseDown_DragOutStartIndex;
                    DragReady?.Invoke(this, new MouseEventArgs(MouseButtons.Left, 1, 0, 0, 0));
                }
                OnMouseDown_DragOutStartIndex = -1;
            }
            else if (0 <= mouseDownShowIndex && showIndexToDataIndex != null && mouseDownShowIndex < showIndexToDataIndex.Length)
            {
                var dX = e.X - OnMouseMove_PrevMousePoint.X;
                var dY = e.Y - OnMouseMove_PrevMousePoint.Y;

                var showIndex = PointToShowIndex(e.Location, getNearestIndex: true);
                if (showIndex >= 0)
                {
                    var oldSelectedIndex = SelectedIndex;
                    var selectionChanged = false;
                    if (selectedIndexByDrag == null) selectedIndexByDrag = new HashSet<int>();
                    var minShow = Math.Min(mouseDownShowIndex, showIndex);
                    var maxShow = Math.Max(mouseDownShowIndex, showIndex);
                    //var drawCount = maxShow - minShow + 1 + selectedIndexByDrag.Count;
                    //var drawSingle = drawCount == 1;
                    //var drawNeeded = maxShow >= minShow;
                    //var selectArray = new int[Math.Max(0, maxShow - minShow + 1)];

                    if (maxShow >= minShow || selectedIndexByDrag.Any())
                    {
                        using (var g = CreateGraphics())
                        {
                            for (var i = minShow; i <= maxShow; i++)
                            {
                                //selectArray[i - minShow] = showIndexToDataIndex[i];
                                var dataIndex = showIndexToDataIndex[i];

                                if (setSelectedWithoutEvent(dataIndex, true, selectedIndices.IndexOf(dataIndex), g))
                                {
                                    selectedIndexByDrag.Add(dataIndex);
                                    selectionChanged = true;
                                }

                            }
                            // var noselectList = new List<int>();
                            foreach (var i in selectedIndexByDrag.ToArray())
                            {
                                var iShow = dataIndexToShowIndex[i];
                                if (iShow < minShow || maxShow < iShow)
                                {
                                    selectedIndexByDrag.Remove(i);
                                    //noselectList.Add(i);
                                    //drawNeeded = true;
                                    if (setSelectedWithoutEvent(i, false, selectedIndices.IndexOf(i), g))
                                    {
                                        selectionChanged = true;
                                    }
                                }
                            }
                        }
                    }

                    //if (drawNeeded && !drawSingle) Invalidate();

                    if (selectionChanged)
                    {
                        var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                        SelectedIndexChanged?.Invoke(this, se);
                    }
                }

                if (e.Y < ClientRectangle.Top)
                {
                    AutoScrollPosition = new Point(-AutoScrollPosition.X, -AutoScrollPosition.Y - Math.Abs(dX) - Math.Abs(dY));
                }
                else if (e.Y >= ClientRectangle.Bottom)
                {
                    AutoScrollPosition = new Point(-AutoScrollPosition.X, -AutoScrollPosition.Y + Math.Abs(dX) + Math.Abs(dY));
                }

                OnMouseMove_PrevMousePoint = e.Location;
            }
            else if (!OnMouseDown_DragOutStartRectangle.IsEmpty) // !OnMouseDown_DragOutStartRectangle.Contains(e.Location))
            {
                if (!OnMouseDown_DragOutStartRectangle.Contains(e.Location))
                //if (!ActivateManager.InVisibleRegion(this, e.Location))
                {
                    OnMouseDown_DragOutStartRectangle = Rectangle.Empty;
                    DragReady?.Invoke(this, e);
                }
            }

            base.OnMouseMove(e);
        }

        public event MouseEventHandler DragReady;
        public event MouseEventHandler DragAttempted;

        protected override void OnQueryContinueDrag(QueryContinueDragEventArgs e)
        {
            if (((Keys)e.KeyState & (Keys.LButton | Keys.RButton)) == (Keys.LButton | Keys.RButton))
            {
                e.Action = DragAction.Cancel;
            }
            base.OnQueryContinueDrag(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            mouseDownShowIndex = -1;
            selectedIndexByDrag = null;
            OnMouseMove_PrevMousePoint = Point.Empty;
            OnMouseDown_DragOutStartIndex = -1;


            int newSelected = PointToIndex(e.Location);


            var modifierKeys = ModifierKeys;
            if (!OnMouseDown_DragOutStartRectangle.IsEmpty)
            {
                OnMouseDown_DragOutStartRectangle = Rectangle.Empty;

                //var modifierKeys = ModifierKeys;
                if (e.Button == MouseButtons.Left)
                {
                    switch (modifierKeys)
                    {
                        case Keys.Control:
                            {
                                var indexOnIndices = newSelected < 0 ? -1 : selectedIndices.IndexOf(newSelected);
                                if (indexOnIndices < 0)
                                {
                                    var focused = FocusedIndex;
                                    var showFocused = focused >= 0 ? dataIndexToShowIndex[focused] : -1;
                                    var showNew = newSelected >= 0 ? dataIndexToShowIndex[newSelected] : -1;

                                    setSelected(newSelected, true, -1, graphics: null);

                                    if (e.Button == MouseButtons.Left)
                                    {
                                        mouseDownShowIndex = showNew;
                                        OnMouseMove_PrevMousePoint = e.Location;
                                    }
                                }
                                else
                                {
                                    setSelected(newSelected, false, indexOnIndices, graphics: null);
                                }
                            }
                            break;
                        default:
                            {
                                var focused = FocusedIndex;
                                var showFocused = focused >= 0 ? dataIndexToShowIndex[focused] : -1;
                                var showNew = newSelected >= 0 ? dataIndexToShowIndex[newSelected] : -1;
                                if (showFocused >= 0 && showNew >= 0 && (modifierKeys & Keys.Shift) == Keys.Shift)
                                {
                                    var oldSelectedIndex = SelectedIndex;

                                    if ((modifierKeys & Keys.Control) != Keys.Control)
                                    {
                                        var minShow = Math.Min(showFocused, showNew);
                                        var maxShow = Math.Max(showFocused, showNew);
                                        //var drawCount = selectedIndices.Count + maxShow - minShow + 1;
                                        //var drawSingle = drawCount == 1;

                                        var newSelecedIndices = new int[maxShow - minShow + 1];
                                        for (var i = minShow; i <= maxShow; i++) newSelecedIndices[i - minShow] = showIndexToDataIndex[i];
                                        //var selectedToNoselected = (from s in selectedIndices where !newSelecedIndices.Contains(s) select s).ToArray();
                                        //var noselectedToSelected = (from s in newSelecedIndices where !selectedIndices.Contains(s) select s).ToArray();
                                        GetChangeSelect(out var selectedToNoselected, out var noselectedToSelected, selectedIndices, newSelecedIndices);

                                        if (selectedToNoselected.Any() || noselectedToSelected.Any())
                                        {
                                            using (var g = CreateGraphics())
                                            {
                                                foreach (var index in selectedToNoselected)
                                                {
                                                    setSelectedWithoutEvent(index, false, selectedIndices.IndexOf(index), g);
                                                }

                                                foreach (var dataIndex in noselectedToSelected)
                                                {
                                                    //var dataIndex = showIndexToDataIndex[i];
                                                    setSelectedWithoutEvent(dataIndex, true, selectedIndices.IndexOf(dataIndex), g);
                                                }
                                            }
                                        }

                                        //if (drawCount > 1) Invalidate();
                                    }
                                    else
                                    {
                                        var minShow = Math.Min(showFocused, showNew);
                                        var maxShow = Math.Max(showFocused, showNew);
                                        //var drawCount = maxShow - minShow + 1;
                                        //var drawSingle = drawCount == 1;
                                        if (maxShow >= minShow)
                                        {
                                            using (var g = CreateGraphics())
                                            {
                                                for (var i = minShow; i <= maxShow; i++)
                                                {
                                                    var dataIndex = showIndexToDataIndex[i];
                                                    var indexindex = selectedIndices.IndexOf(dataIndex);
                                                    //setSelectedWithoutEvent(dataIndex, indexindex < 0, indexindex); // 反転
                                                    //setSelectedWithoutEvent(dataIndex, true, indexindex); // 追加
                                                    setSelectedWithoutEvent(dataIndex, false, indexindex, g); // 取り除き
                                                }
                                            }
                                        }

                                        //if (drawCount > 1) Invalidate();
                                    }
                                    var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                                    SelectedIndexChanged?.Invoke(this, se);
                                }
                                else
                                {
                                    SelectedIndex = newSelected; // ここはフィールドへの代入ではなくプロパティーへの代入でなければならない
                                }
                            }
                            break;
                    }
                }
                DragAttempted?.Invoke(this, e);

            }

            if ((modifierKeys & Keys.Shift) == 0) focusedIndex = newSelected;

            base.OnMouseUp(e);
        }

        protected override void OnMouseLeave(EventArgs e)
        {
            mouseDownShowIndex = -1;
            selectedIndexByDrag = null;
            OnMouseMove_PrevMousePoint = Point.Empty;
            OnMouseDown_DragOutStartIndex = -1;

            base.OnMouseLeave(e);
        }

        public Point GetUpperLeftClientcoordinateOf(int showIndex)
        {
            return GetCoordinateOf(showIndex, semiCenter: false);
        }

        public Point GetSemiCenterClientcoordinateOf(int showIndex)
        {
            return GetCoordinateOf(showIndex, semiCenter: true);
        }

        private Point GetCoordinateOf(int showIndex, bool semiCenter)
        {
            int col = showIndex % cols;
            int row = showIndex / cols;

            var x = gridOffsetH + col * gridSizeH;
            var y = row * gridSizeV + AutoScrollPosition.Y;

            if (semiCenter)
            {
                var m2 = Math.Min(gridSizeH, gridSizeV) / 2;
                x += m2;
                y += m2;
            }

            var rect = ClientRectangle;
            if (x < rect.Left) x = rect.Left;
            else if (x >= rect.Right) x = rect.Right - 1;
            if (y < rect.Top) y = rect.Top;
            else if (y >= rect.Bottom) y = rect.Bottom - 1;

            return new Point(x, y);
        }

        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);
        }


        protected override void OnPreviewKeyDown(PreviewKeyDownEventArgs e)
        {
            if (e.Alt) return;

            if (Clearing) return;

            if (focusedIndex < 0 || focusedIndex >= dataIndexToShowIndex.Length || dataIndexToShowIndex[focusedIndex] < 0)
            {
                focusedIndex = SelectedIndex;
            }

            if ((e.KeyCode == Keys.A && e.Modifiers == Keys.Control))
            {
                var showCount = showIndexToDataIndex.Length;
                if (e.Modifiers == Keys.Control && selectedIndices.Count < showCount)
                {
                    var oldSelectedIndex = SelectedIndex;
                    e.IsInputKey = true; // フォーカスの移動を禁止
                    //var drawSingle = showCount == 1;
                    if (showCount > 0)
                    {
                        using (var g = CreateGraphics())
                        {
                            for (var i = 0; i < showCount; i++)
                            {
                                var dataIndex = showIndexToDataIndex[i];
                                setSelectedWithoutEvent(dataIndex, true, selectedIndices.IndexOf(dataIndex), g);
                            }
                        }
                    }
                    //if (showCount > 1) Invalidate();
                    var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                    SelectedIndexChanged?.Invoke(this, se);
                }
            }
            else
            {
                int currentShowIndex;
                var fi = FocusedIndex;
                if (fi >= 0)
                {
                    currentShowIndex = dataIndexToShowIndex[fi];
                }
                else
                {
                    currentShowIndex = PointToShowIndex(new Point(0, 0), getNearestIndex: true);
                }
                if (currentShowIndex >= 0)
                {
                    int nextShowIndex = -1;
                    bool operated = true;

                    switch (e.KeyCode)
                    {
                        case Keys.Down:
                            nextShowIndex = currentShowIndex + cols;
                            if (HorizontalLoopLevel >= 1 && nextShowIndex >= showIndexToDataIndex.Length)
                            {
                                if (HorizontalLoopLevel >= 2 || currentShowIndex / cols < (showIndexToDataIndex.Length - 1) / cols)
                                {
                                    nextShowIndex = showIndexToDataIndex.Length - 1;
                                }
                            }
                            break;
                        case Keys.Up:
                            nextShowIndex = currentShowIndex - cols;
                            if (HorizontalLoopLevel >= 2 && nextShowIndex < 0)
                            {
                                nextShowIndex = 0;
                            }
                            break;
                        case Keys.Left:
                            if (HorizontalLoopLevel >= 1 || currentShowIndex % cols != 0)
                            {
                                nextShowIndex = currentShowIndex - 1;
                            }
                            break;
                        case Keys.Right:
                            if (HorizontalLoopLevel >= 1 || (currentShowIndex + 1) % cols != 0)
                            {
                                nextShowIndex = currentShowIndex + 1;
                            }
                            break;
                        case Keys.Home:
                            nextShowIndex = 0;
                            break;
                        case Keys.End:
                            nextShowIndex = showIndexToDataIndex.Length - 1;
                            break;
                        case Keys.PageUp:
                            int fullStart = FullDisplayedStartShowIndex;
                            if (currentShowIndex > fullStart) nextShowIndex = fullStart;
                            else nextShowIndex = Math.Max(0, currentShowIndex - (Height / gridSizeV) * cols);
                            break;
                        case Keys.PageDown:
                            int fullEnd = FullDisplayedStopShowIndex - 1;
                            if (currentShowIndex < fullEnd) nextShowIndex = fullEnd;
                            else nextShowIndex = Math.Min(showIndexToDataIndex.Length - 1, currentShowIndex + (Height / gridSizeV) * cols);
                            break;
                        default:
                            operated = false;
                            break;
                    }

                    if (operated)
                    {
                        e.IsInputKey = true; // フォーカスの移動を禁止
                        if (nextShowIndex != currentShowIndex && 0 <= nextShowIndex && nextShowIndex < showIndexToDataIndex.Length)
                        {

                            if (e.Modifiers == Keys.Shift)
                            {
                                var oldSelectedIndex = SelectedIndex;

                                // 選択解除を行う実装
                                var dir = nextShowIndex > currentShowIndex ? 1 : -1;
                                var stop = nextShowIndex + dir;
                                var nextDataIndex = showIndexToDataIndex[currentShowIndex];
                                var nextIndexIndex = selectedIndices.IndexOf(nextDataIndex);
                                var deletePhase = nextIndexIndex >= 0;
                                using (var g = CreateGraphics())
                                {
                                    for (var i = currentShowIndex; i != stop; i += dir)
                                    {
                                        var dataIndex = nextDataIndex;
                                        //var indexIndex = nextIndexIndex; // 一つ前でデリートされている可能性がある
                                        var indexIndex = deletePhase && nextIndexIndex > 0 && selectedIndices[nextIndexIndex - 1] == dataIndex ? nextIndexIndex - 1 : nextIndexIndex;
                                        var i2 = i + dir;
                                        if (i2 != stop)
                                        {
                                            nextDataIndex = showIndexToDataIndex[i2];
                                            nextIndexIndex = selectedIndices.IndexOf(nextDataIndex);
                                            deletePhase = nextIndexIndex >= 0;
                                        }
                                        else
                                        {
                                            deletePhase = false;
                                        }
                                        setSelectedWithoutEvent(dataIndex, !deletePhase, indexIndex, g);
                                    }
                                }

                                // 選択解除を行わない実装
                                /*
                                var start = Math.Min(currentShowIndex, nextShowIndex);
                                var stop = Math.Max(currentShowIndex, nextShowIndex);
                                //var drawCount = stop - start + 1;
                                //var drawSingle = drawCount == 1;
                                if (stop >= start)
                                {
                                    using (var g = CreateGraphics())
                                    {
                                        for (var i = start; i <= stop; i++)
                                        {
                                            var dataIndex = showIndexToDataIndex[i];
                                            setSelectedWithoutEvent(dataIndex, true, selectedIndices.IndexOf(dataIndex), g);
                                        }
                                    }
                                }
                                //if (drawCount > 1) Invalidate();
                                */

                                var se = new SelectedIndexChangedEventArgs(oldSelectedIndex, SelectedIndex);
                                SelectedIndexChanged?.Invoke(this, se);
                            }
                            else
                            {
                                SelectedIndex = showIndexToDataIndex[nextShowIndex];
                            }
                            ScrollBarToIndexWithMinimalMove(nextShowIndex);


                            focusedIndex = showIndexToDataIndex[nextShowIndex];
                        }
                    }
                }
            }
            base.OnPreviewKeyDown(e);
        }

        public event GraphicalListDragEventHandler GraphicalListDragEnter;
        public event GraphicalListDragEventHandler GraphicalListDragOver;
        public event EventHandler GraphicalListDragLeave;
        public event GraphicalListDragEventHandler GraphicalListDragDrop;

        protected override void OnDragEnter(DragEventArgs drgevent)
        {
            if (GraphicalListDragEnter != null)
            {
                var e = new GraphicalListDragEventArgs(drgevent);
                GraphicalListDragEnter(this, e);
                e.SetTo(drgevent);
            }
            base.OnDragEnter(drgevent);
        }

        protected override void OnDragOver(DragEventArgs drgevent)
        {
            if (GraphicalListDragOver != null)
            {
                var e = new GraphicalListDragEventArgs(drgevent, PointToShowIndex(PointToClient(new Point(drgevent.X, drgevent.Y)), getNearestIndex: false));
                GraphicalListDragOver(this, e);
                e.SetTo(drgevent);
            }
            base.OnDragOver(drgevent);
        }

        protected override void OnDragLeave(EventArgs e)
        {
            GraphicalListDragLeave?.Invoke(this, e);
            base.OnDragLeave(e);
        }

        protected override void OnDragDrop(DragEventArgs drgevent)
        {
            if (GraphicalListDragDrop != null)
            {
                var e = new GraphicalListDragEventArgs(drgevent, PointToShowIndex(PointToClient(new Point(drgevent.X, drgevent.Y)), getNearestIndex: false));
                GraphicalListDragDrop(this, e);
                e.SetTo(drgevent);
            }
            base.OnDragDrop(drgevent);
        }

        public void DrawHighlight(int index)
        {
            if (index >= 0 && showIndexToDataIndex != null && showIndexToDataIndex.Length > index)
            {
                var dIndex = showIndexToDataIndex[index];
                if (dIndex >= 0)
                {
                    var tempForeColor = selectedForeColor;
                    var tempFrameColor = frameColor;
                    var tempBrush = frameBrush;
                    selectedForeColor = SystemColors.HighlightText;
                    frameColor = SystemColors.Highlight;
                    frameBrush = SystemBrushes.Highlight;
                    DrawItem(dIndex, selected: true, onlyFrame: true);
                    selectedForeColor = tempForeColor;
                    frameColor = tempFrameColor;
                    frameBrush = tempBrush;
                }
            }
        }

        public void Invalidate(int index)
        {
            if (index >= 0 && showIndexToDataIndex != null && showIndexToDataIndex.Length > index)
            {
                var dIndex = showIndexToDataIndex[index];
                if (dIndex >= 0)
                {
                    items[dIndex].DrawItem(onlyFrame: true);
                }
            }
        }
    }

    public class UBigInteger : IComparable<UBigInteger>
    {
        ulong[] X;
        public UBigInteger(byte[] data)
        {
            var length = data == null ? 0 : (data.Length + 7) >> 3;
            X = new ulong[length];
            for (var i = 0; i < length; i++)
            {
                var i8 = i << 3;
                var stop = Math.Min(8, data.Length - i8);
                var x = (ulong)0;
                for (var j = 0; j < stop; j++)
                {
                    x |= (ulong)data[i8 + j] << (j << 3);
                }
                X[i] = x;
            }
        }

        public UBigInteger(ulong value)
        {
            X = new ulong[1] { value };
        }

        public static implicit operator UBigInteger(ulong value)
        {
            return new UBigInteger(value);
        }

        public static explicit operator ulong(UBigInteger value)
        {
            var X = value.X;
            return X.Length == 0 ? 0 : X[0];
        }

        public int CompareTo(UBigInteger other)
        {
            var Y = other.X;
            if (X.Length > Y.Length) return -other.CompareTo(this);

            for (var i = Y.Length - 1; i >= X.Length; i--)
            {
                if (Y[i] != 0) return -1;
            }

            for (var i = X.Length - 1; i >= 0; i--)
            {
                var result = X[i].CompareTo(Y[i]);
                if (result != 0) return result;
            }

            return 0;
        }
    }

    class FileInfoEx : FileSystemInfo
    {
        private FileInfo fileInfo;
        private string fullPath = null;
        private string entityPath;
        private string name = null;

        public FileInfoEx(string path)
        {
            var altPos = path.IndexOf(Path.AltDirectorySeparatorChar);
            if (altPos >= 0)
            {
                name = path.Substring(altPos + 1);
                fullPath = path;
                entityPath = path.Substring(0, altPos);
            }
            else
            {
                entityPath = path;
            }
            fileInfo = new FileInfo(entityPath);
        }


        public override bool Exists
        {
            get
            {
                return fileInfo.Exists;
            }
        }

        public override string Name
        {
            get
            {
                return name == null ? fileInfo.Name : name;
            }
        }

        public override void Delete()
        {
            fileInfo.Delete();
        }

        public long Length
        {
            get
            {
                return fileInfo.Length;
            }
        }

        /*
        public static long GetLength(FileSystemInfo fileInfo)
        {
            var fileInfo2 = fileInfo as FileInfo;
            if (fileInfo2 != null) return fileInfo2.Length;
            else return (fileInfo as FileInfoEx).fileInfo.Length;
        }
        */

        public override string FullName
        {
            get
            {
                return fullPath == null ? fileInfo.FullName : fullPath;
            }
        }

        public static FileInfo GetEntityFileInfo(FileSystemInfo fileInfo)
        {
            var fileInfo2 = fileInfo as FileInfo;
            if (fileInfo2 != null) return fileInfo2;
            else return (fileInfo as FileInfoEx).fileInfo;
        }

        /*
        public static string GetEntityPath(FileSystemInfo fileInfo)
        {
            var fileInfo2 = fileInfo as FileInfo;
            if (fileInfo2 != null) return fileInfo2.FullName;
            else return (fileInfo as FileInfoEx).entityPath;
        }

        public static string GetAttributes(FileSystemInfo fileInfo)
        {
            var fileInfo2 = fileInfo as FileInfo;
            if (fileInfo2 != null) return fileInfo2.FullName;
            else return (fileInfo as FileInfoEx).entityPath;
        }

        public override FileAttributes Attributes
        {

        }
        */
    }

    public class DataObjectEx : DataObject, System.Runtime.InteropServices.ComTypes.IDataObject
    {
        private static readonly TYMED[] ALLOWED_TYMEDS =
            new TYMED[] {
                TYMED.TYMED_HGLOBAL,
                TYMED.TYMED_ISTREAM,
                TYMED.TYMED_ENHMF,
                TYMED.TYMED_MFPICT,
                TYMED.TYMED_GDI};

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct FILEDESCRIPTOR
        {
            public UInt32 dwFlags;
            public Guid clsid;
            public System.Drawing.Size sizel;
            public System.Drawing.Point pointl;
            public UInt32 dwFileAttributes;
            public System.Runtime.InteropServices.ComTypes.FILETIME ftCreationTime;
            public System.Runtime.InteropServices.ComTypes.FILETIME ftLastAccessTime;
            public System.Runtime.InteropServices.ComTypes.FILETIME ftLastWriteTime;
            public UInt32 nFileSizeHigh;
            public UInt32 nFileSizeLow;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
            public String cFileName;

            public static readonly int FileDescriptorSize = Marshal.SizeOf(typeof(FILEDESCRIPTOR));

            private static bool FromStream(Stream stream, out FILEDESCRIPTOR fileDescriptor)
            {
                var data = new Byte[FileDescriptorSize];
                var read = stream.Read(data, 0, FileDescriptorSize);
                if (read == 0)
                {
                    fileDescriptor = default(FILEDESCRIPTOR);
                    return false;
                }
                if (read != FileDescriptorSize)
                {
                    throw new ArgumentException(null, "data");
                }
                IntPtr FileDescriptorPointer = Marshal.AllocHGlobal(FileDescriptorSize);
                Marshal.Copy(data, 0, FileDescriptorPointer, FileDescriptorSize);
                fileDescriptor = Marshal.PtrToStructure<FILEDESCRIPTOR>(FileDescriptorPointer);
                Marshal.FreeHGlobal(FileDescriptorPointer);
                return true;
            }

            public static FILEDESCRIPTOR[] FromStreamToArray(Stream stream)
            {
                var count = stream.ReadByte() | stream.ReadByte() << 8 | stream.ReadByte() << 16 | stream.ReadByte() << 24;
                var result = new FILEDESCRIPTOR[count];
                for (var i = 0; i < count; i++)
                {
                    FILEDESCRIPTOR fileDescriptor;
                    if (FromStream(stream, out fileDescriptor))
                    {
                        result[i] = fileDescriptor;
                    }
                    else
                    {
                        throw new ArgumentException(null, "stream");
                    }
                }
                return result;
            }
        }

        public struct SelectedItem
        {
            public String FileName;
            //public DateTime? CreationTime;
            //public DateTime? AccessTime;
            public DateTime? WriteTime;
            public Int64 FileSize;
        }

        private SelectedItem[] m_SelectedItems;
        private Int32 m_lindex;

        private Int32 indexForZipPla = 0;

        public DataObjectEx(SelectedItem[] selectedItems)
        {
            m_SelectedItems = selectedItems;
        }

        public override object GetData(string format, bool autoConvert)
        {
            if (String.Compare(format, NativeMethods.CFSTR_FILEDESCRIPTORW, StringComparison.OrdinalIgnoreCase) == 0 && m_SelectedItems != null)
            {
                base.SetData(NativeMethods.CFSTR_FILEDESCRIPTORW, GetFileDescriptor(m_SelectedItems));
            }
            else if (String.Compare(format, NativeMethods.CFSTR_FILECONTENTS, StringComparison.OrdinalIgnoreCase) == 0)
            {
                base.SetData(NativeMethods.CFSTR_FILECONTENTS, GetFileContents_Private(m_SelectedItems, m_lindex));
            }
            else if (String.Compare(format, NativeMethods.CFSTR_PERFORMEDDROPEFFECT, StringComparison.OrdinalIgnoreCase) == 0)
            {
                //TODO: Cleanup routines after paste has been performed
            }
            else if (String.Compare(format, NativeMethods.ZIPPLA_FILECONTENTS, StringComparison.OrdinalIgnoreCase) == 0)
            {
                base.SetData(NativeMethods.CFSTR_FILECONTENTS, GetFileContents_Private(m_SelectedItems, indexForZipPla++));
                format = NativeMethods.CFSTR_FILECONTENTS;
            }
            else if (String.Compare(format, NativeMethods.ZIPPLA_PERFORMEDDROPEFFECT, StringComparison.OrdinalIgnoreCase) == 0)
            {
                indexForZipPla = 0;
                format = NativeMethods.CFSTR_PERFORMEDDROPEFFECT;
            }
            return base.GetData(format, autoConvert);
        }

        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        void System.Runtime.InteropServices.ComTypes.IDataObject.GetData(ref System.Runtime.InteropServices.ComTypes.FORMATETC formatetc, out System.Runtime.InteropServices.ComTypes.STGMEDIUM medium)
        {
            if (formatetc.cfFormat == (Int16)DataFormats.GetFormat(NativeMethods.CFSTR_FILECONTENTS).Id)
                m_lindex = formatetc.lindex;

            medium = new System.Runtime.InteropServices.ComTypes.STGMEDIUM();
            if (GetTymedUseable(formatetc.tymed))
            {
                if ((formatetc.tymed & TYMED.TYMED_HGLOBAL) != TYMED.TYMED_NULL)
                {
                    medium.tymed = TYMED.TYMED_HGLOBAL;
                    medium.unionmember = NativeMethods.GlobalAlloc(NativeMethods.GHND | NativeMethods.GMEM_DDESHARE, 1);
                    if (medium.unionmember == IntPtr.Zero)
                    {
                        throw new OutOfMemoryException();
                    }
                    try
                    {
                        ((System.Runtime.InteropServices.ComTypes.IDataObject)this).GetDataHere(ref formatetc, ref medium);
                        return;
                    }
                    catch
                    {
                        NativeMethods.GlobalFree(new HandleRef((STGMEDIUM)medium, medium.unionmember));
                        medium.unionmember = IntPtr.Zero;
                        throw;
                    }
                }
                medium.tymed = formatetc.tymed;
                ((System.Runtime.InteropServices.ComTypes.IDataObject)this).GetDataHere(ref formatetc, ref medium);
            }
            else
            {
                Marshal.ThrowExceptionForHR(NativeMethods.DV_E_TYMED);
            }
        }

        private static Boolean GetTymedUseable(TYMED tymed)
        {
            for (Int32 i = 0; i < ALLOWED_TYMEDS.Length; i++)
            {
                if ((tymed & ALLOWED_TYMEDS[i]) != TYMED.TYMED_NULL)
                {
                    return true;
                }
            }
            return false;
        }

        public Action<SelectedItem[]> RecalcItems;

        private MemoryStream GetFileDescriptor(SelectedItem[] SelectedItems)
        {
            if (SelectedItems != null && RecalcItems != null)
            {
                RecalcItems(SelectedItems);
            }

            MemoryStream FileDescriptorMemoryStream = new MemoryStream();
            // Write out the FILEGROUPDESCRIPTOR.cItems value
            FileDescriptorMemoryStream.Write(BitConverter.GetBytes(SelectedItems.Length), 0, sizeof(UInt32));

            FILEDESCRIPTOR FileDescriptor = new FILEDESCRIPTOR();
            foreach (SelectedItem si in SelectedItems)
            {
                FileDescriptor.cFileName = si.FileName;
                Int64? FileTime;
                /*
                FileTimeUtc = si.CreationTime?.ToFileTimeUtc();
                if (FileTimeUtc != null)
                {
                    FileDescriptor.ftCreationTime.dwHighDateTime = (Int32)(FileTimeUtc >> 32);
                    FileDescriptor.ftCreationTime.dwLowDateTime = (Int32)(FileTimeUtc & 0xFFFFFFFF);
                }
                FileTimeUtc = si.AccessTime?.ToFileTimeUtc();
                if (FileTimeUtc != null)
                {
                    FileDescriptor.ftLastAccessTime.dwHighDateTime = (Int32)(FileTimeUtc >> 32);
                    FileDescriptor.ftLastAccessTime.dwLowDateTime = (Int32)(FileTimeUtc & 0xFFFFFFFF);
                }
                */
                //FileTime = si.WriteTime?.ToFileTimeUtc();
                FileTime = si.WriteTime?.ToFileTime();
                if (FileTime != null)
                {
                    FileDescriptor.ftLastWriteTime.dwHighDateTime = (Int32)(FileTime >> 32);
                    FileDescriptor.ftLastWriteTime.dwLowDateTime = (Int32)(FileTime & 0xFFFFFFFF);
                }
                FileDescriptor.nFileSizeHigh = (UInt32)(si.FileSize >> 32);
                FileDescriptor.nFileSizeLow = (UInt32)(si.FileSize & 0xFFFFFFFF);
                FileDescriptor.dwFlags = NativeMethods.FD_WRITESTIME | NativeMethods.FD_FILESIZE | NativeMethods.FD_PROGRESSUI;

                // Marshal the FileDescriptor structure into a byte array and write it to the MemoryStream.
                Int32 FileDescriptorSize = Marshal.SizeOf(FileDescriptor);
                IntPtr FileDescriptorPointer = Marshal.AllocHGlobal(FileDescriptorSize);
                Marshal.StructureToPtr(FileDescriptor, FileDescriptorPointer, true);
                Byte[] FileDescriptorByteArray = new Byte[FileDescriptorSize];
                Marshal.Copy(FileDescriptorPointer, FileDescriptorByteArray, 0, FileDescriptorSize);
                Marshal.FreeHGlobal(FileDescriptorPointer);
                FileDescriptorMemoryStream.Write(FileDescriptorByteArray, 0, FileDescriptorByteArray.Length);
            }
            return FileDescriptorMemoryStream;
        }

        private MemoryStream GetFileContents_Private(SelectedItem[] SelectedItems, Int32 FileNumber)
        {
            MemoryStream FileContentMemoryStream = null;
            if (SelectedItems != null && FileNumber < SelectedItems.Length)
            {
                /*
                FileContentMemoryStream = new MemoryStream();
                SelectedItem si = SelectedItems[FileNumber];

                // **************************************************************************************
                // TODO: Get the virtual file contents and place the contents in the byte array bBuffer.
                // If the contents are zero length then a single byte must be supplied to Windows
                // Explorer otherwise the transfer will fail.  If this is part of a multi-file transfer,
                // the entire transfer will fail at this point if the buffer is zero length.
                // **************************************************************************************

                Byte[] bBuffer;


                if (bBuffer.Length == 0)  // Must send at least one byte for a zero length file to prevent stoppages.
                    bBuffer = new Byte[1];
                FileContentMemoryStream.Write(bBuffer, 0, bBuffer.Length);
                */

                FileContentMemoryStream = GetFileContents(SelectedItems[FileNumber], FileNumber);
                if (FileContentMemoryStream == null) return null;
                if (FileContentMemoryStream.Length == 0) FileContentMemoryStream.WriteByte(0); // Must send at least one byte for a zero length file to prevent stoppages.
            }
            return FileContentMemoryStream;
        }

        public Func<SelectedItem, int, MemoryStream> GetFileContents;
    }

    public static class NativeMethods
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        public static extern IntPtr GlobalAlloc(int uFlags, int dwBytes);

        [DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        public static extern IntPtr GlobalFree(HandleRef handle);

        // Clipboard formats used for cut/copy/drag operations
        public const string CFSTR_PREFERREDDROPEFFECT = "Preferred DropEffect";
        public const string CFSTR_PERFORMEDDROPEFFECT = "Performed DropEffect";
        public const string CFSTR_FILEDESCRIPTORW = "FileGroupDescriptorW";
        public const string CFSTR_FILECONTENTS = "FileContents";

        public const string ZIPPLA_FILECONTENTS = "ZipPlaFileContents";
        public const string ZIPPLA_PERFORMEDDROPEFFECT = "ZipPlaPerformed DropEffect";

        // File Descriptor Flags
        public const Int32 FD_CLSID = 0x00000001;
        public const Int32 FD_SIZEPOINT = 0x00000002;
        public const Int32 FD_ATTRIBUTES = 0x00000004;
        public const Int32 FD_CREATETIME = 0x00000008;
        public const Int32 FD_ACCESSTIME = 0x00000010;
        public const Int32 FD_WRITESTIME = 0x00000020;
        public const Int32 FD_FILESIZE = 0x00000040;
        public const Int32 FD_PROGRESSUI = 0x00004000;
        public const Int32 FD_LINKUI = 0x00008000;

        // Global Memory Flags
        public const Int32 GMEM_MOVEABLE = 0x0002;
        public const Int32 GMEM_ZEROINIT = 0x0040;
        public const Int32 GHND = (GMEM_MOVEABLE | GMEM_ZEROINIT);
        public const Int32 GMEM_DDESHARE = 0x2000;

        // IDataObject constants
        public const Int32 DV_E_TYMED = unchecked((Int32)0x80040069);
    }

    public class DataGridViewDirectoryList : DataGridView
    {
        public SimplifiedKeyBoard SimplifiedKeyBoard;
        protected override void OnMouseDown(MouseEventArgs e)
        {
            DataGridViewFileList.MyOnMouseDown(this, mouseDown, base.OnMouseDown, SetCurrentCellAddressCore, SimplifiedKeyBoard, e);
        }

        public DataGridViewDirectoryList() : base()
        {
            DoubleBuffered = true;
        }

        private event MouseEventHandler mouseDown;
        public new event MouseEventHandler MouseDown
        {
            add
            {
                mouseDown += value;
                base.MouseDown += value;
            }
            remove
            {
                mouseDown -= value;
                base.MouseDown -= value;
            }
        }
    }

    /// <summary>
    /// 既存のコードを利用するためのクラス
    /// 新たにこのクラスを使用することを前提にコードを書くことはしない
    /// </summary>
    public class KeyMouseBinder
    {
        private ToolStripDropDown toolStripDropDown;
        private Func<ToolStripItem, bool> requiredBinding;

        public KeyMouseBinder(ToolStripDropDown toolStripDropDown, Func<ToolStripItem, bool> requiredBinding)
        {
            this.toolStripDropDown = toolStripDropDown ?? throw new ArgumentNullException(nameof(toolStripDropDown));
            this.requiredBinding = requiredBinding ?? throw new ArgumentNullException(nameof(requiredBinding));
            toolStripDropDown.PreviewKeyDown += ToolStripDropDown_PreviewKeyDown;
        }

        private void ToolStripDropDown_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                var selected = (from ToolStripItem item in toolStripDropDown.Items where item.Selected select item).FirstOrDefault();
                if (selected != null && requiredBinding(selected))
                {
                    var bounds = selected.Bounds;
                    var halfHeight = bounds.Height / 2;
                    var x = bounds.X + halfHeight;
                    var y = bounds.Y + halfHeight;
                    CatalogForm.PerformMouseDown(toolStripDropDown, new MouseEventArgs(MouseButtons.Left, 1, x, y, 0));
                }
            }
        }
    }

    public static class HintManager
    {
        private const string HintVersion = "1.4.3.0"; // 表示内容の主旨自体が変わらないかぎり増やさない
        private static Regex ShowDialog_ReplacerRegex;
        public static void ShowDialog(Form owner, Action preAction)
        {
            try
            {
                // ヒントを表示しない条件
                if (MovieThumbnailLoader.ffmpegExists())
                {
                    //saveReadHintVersion(owner);
                    return;
                }

                var config = new GeneralConfig();
                var vComp = UpdateCheck.VersionStringComp(HintVersion, config.ReadHintVersion);
                if (config.ShowHintOnlyOnce && vComp <= 0) return;
                preAction?.Invoke();
                //using (var hintForm = new HintForm()) (hintForm as Form).ShowDialog(owner);

                bool hiddenExtension;
                try
                {
                    var zippla = Application.ExecutablePath;
                    hiddenExtension = FileTypeManager.GetDisplayName(zippla).ToLower() ==
                        System.IO.Path.GetFileNameWithoutExtension(zippla).ToLower();
                }
                catch
                {
                    hiddenExtension = false;
                }

                string message;
                if (hiddenExtension)
                {
                    message = Message.RecommendFfmpeg + "\n\n\n" + Message.RecommendFfmpegRemarkForHiddenExtension;
                }
                else
                {
                    message = Message.RecommendFfmpeg;
                }
                var a = message.Split(new string[] { @"\n" }, StringSplitOptions.None);
                var str = "";
                if (ShowDialog_ReplacerRegex == null) ShowDialog_ReplacerRegex = new Regex(@"\$1|\{[^|]+\|[^|]+\}");
                var bitsString = Environment.Is64BitOperatingSystem ? "64" : "32"; // DLL 等の都合で 32bit で動作させても ffmpeg まで合わせる必要はないので Is64Bit"OperatingSystem"
                for (var i = 0; i < a.Length; i++)
                {
                    var ai = a[i];
                    if (ShowDialog_ReplacerRegex.IsMatch(ai))
                    {
                        var b = bitsString;
                        if (!string.IsNullOrEmpty(b))
                        {
                            str += SelectorReplace(ai.Replace("$1", b), b == "32" ? 0 : 1, 2);
                        }
                    }
                    else
                    {
                        str += ai;
                    }
                    if (i < a.Length - 1) str += "\n";
                }

                var checkBoxChecked0 = !config.ShowHintOnlyOnce;
                var checkBoxChecked = checkBoxChecked0;
                var res = MessageForm.Show(owner, str, Message.Information, Message.CheckExistenceOfFfmpegAtStartup, ref checkBoxChecked, Message.OK, MessageBoxIcon.Information);
                //if (res == 0 && (checkBoxChecked != checkBoxChecked0 || vComp > 0))
                if (res == 0 && checkBoxChecked != checkBoxChecked0 || vComp > 0) // 表示したバージョンの更新は常に行う。さもなければバツで閉じた後で共通設定の内容を無視したような挙動になる。
                {
                    Configuration.ClosePrepareMode();
                    config = new GeneralConfig(); // ポップアップ表示中に設定が書き換えられた場合のため
                    var changed = false;
                    if (UpdateCheck.VersionStringComp(HintVersion, config.ReadHintVersion) > 0)
                    {
                        config.ReadHintVersion = HintVersion;
                        changed = true;
                    }
                    if (res == 0 && checkBoxChecked != !config.ShowHintOnlyOnce)
                    {
                        config.ShowHintOnlyOnce = !checkBoxChecked;
                        changed = true;
                    }
                    if (changed)
                    {
                        var e = config.Save();
                        if (e != null) throw e;
                    }
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(owner, e.Message, null, MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
        }

        private static string SelectorReplace(string str, int zeroOriginIndex, int totalCount)
        {
            var ptn = @"\{([^|]*)";
            for (var i = 1; i < totalCount; i++) ptn += @"\|([^|]*)";
            ptn += @"\}";
            var m = Regex.Match(str, ptn);
            if (m.Success)
            {
                str = str.Replace(str.Substring(m.Index, m.Length), m.Groups[zeroOriginIndex + 1].Value);
            }
            return str;
        }
    }
}
